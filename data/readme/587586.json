{
  "README": "lie\n===\n\nA python module for computations with Lie groups, Lie algebras,\nrepresentations, root systems, and more.\n\nBasic Information\n-----------------\n\nlie is based on the computer algebra package [LiE](http://www-math.univ-poitiers.fr/~maavl/LiE/),\nwritten by M. A. A. van Leeuwen, A. M. Cohen and B. Lisser in the\nearly 90's.  LiE implemented a proprietary scripting language as a\nwrapper for its mathematical algorithms.  While this language is\nuseful for interactive computations and short scripts, python is more\nexpressive and powerful.\n\nlie provides python interfaces for the following objects in the LiE language:\n\n - grp: a Lie group\n - vec: a vector of integers\n - mat: a 2-dimensional matrix of integers\n - pol: a (multivariable) polynomial with integer coefficients\n\nIn addition, lie wraps some of these into abstract objects which\nare more mathematically natural:\n\n - AbstractVec: a vector in the rational span of a root system of some\n   Lie group. This includes roots, weights, and linear combinations.\n - weyl: a Weyl group element.\n - toral: a toral element.\n - rep : a Lie group representation.\n\nUsage\n-----\n\nlie implements most functions from LiE\n(see [the documentation](http://www-math.univ-poitiers.fr/~maavl/LiEman/manual.pdf)).\n\nThis example calculation shows how the 10 + 5bar + 1 representation of\nSU(5) [contains a single standard model generation](http://en.wikipedia.org/wiki/Grand_Unified_Theory).\n\n    Python 3.1 (r31:73578, Jun 27 2009, 21:49:46)\n    >>> from lie import *\n\nA4 is SU(5) in Cartan's classifiation, as we can see when we\npretty-print.\n\n    >>> g = A4; g.pprint()\n    'SU(5)'\n\nA representation is shown as \"group(highest-weight-vector)\",\nBut physicists usually label representations by their dimension\n(the b is for \"bar\", or \"dual\").\n\n    >>> r = g.fund().dual() + g.alt_tensor(2) + g.trivial()\n    >>> r\n    A4(0,0,0,0) + A4(0,0,0,1) + A4(0,1,0,0)\n    >>> r.pprint()\n    '(1) + (5b) + (10)'\n\nWe can see that SU(2)xSU(3) is a subgroup of SU(5).\nNext let's get the restriction matrix for SU(2)xSU(3) in SU(5), and\nadd the U(1) part by hand:\n\n    >>> [h.pprint() for h in g.max_subgrps()]\n    ['SU(4)', 'SO(5)', 'SU(2)xSU(3)']\n    >>> m = g.res_mat(A1*A2)\n    >>> m = m.transpose().concat(mat([[-2,1,-1,2]])).transpose()\n\nFinally, we decompose r under the group SU(2)xSU(3)xU(1).\nThe first two numbers are the SU(2) and SU(3) rep dimensions,\nand the third is the U(1) charge.\n\n    >>> r.branch(A1*A2*T1, m).pprint() \n    '(1,1,0) + (1,1,6) + (1,3b,-4) + (1,3b,2) + (2,1,-3) + (2,3,1)'\n\nInstallation\n------------\n\nRequirements:\n\n - Python 3.1 or later (<http://www.python.org/>)\n - Cython (<http://www.cython.org/>)\n - gcc\n\nUsers of Mac OS 10.6 and above should be able to just type \"make\" in\nthe root directory.  I have not had time to tune the Makefiles for\nother systems, so other users should try to make and be prepared for\nsome debugging.\n\nCredits\n-------\n\nWritten by David Simmons-Duffin in 2009 for use in:\n \n - D. Poland and D. Simmons-Duffin, \"Superconformal Flavor Simplified,\"\n   arXiv:0910.4585 [hep-ph].\n\nThis module basically wraps the C-source code from:\n\n - M. A. A. van Leeuwen, A. M. Cohen and B. Lisser, \"LiE, A Package for\n   Lie Group Computations\", Computer Algebra Nederland, Amsterdam, ISBN\n   90-74116-02-7, 1992\n\nC-python bridge made possible by [Cython](http://www.cython.org/)\n", 
  "read_at": 1462553084, 
  "description": "A python interface to the computer algebra package LiE, for computations with Lie groups, representations, etc..", 
  "README.md": "lie\n===\n\nA python module for computations with Lie groups, Lie algebras,\nrepresentations, root systems, and more.\n\nBasic Information\n-----------------\n\nlie is based on the computer algebra package [LiE](http://www-math.univ-poitiers.fr/~maavl/LiE/),\nwritten by M. A. A. van Leeuwen, A. M. Cohen and B. Lisser in the\nearly 90's.  LiE implemented a proprietary scripting language as a\nwrapper for its mathematical algorithms.  While this language is\nuseful for interactive computations and short scripts, python is more\nexpressive and powerful.\n\nlie provides python interfaces for the following objects in the LiE language:\n\n - grp: a Lie group\n - vec: a vector of integers\n - mat: a 2-dimensional matrix of integers\n - pol: a (multivariable) polynomial with integer coefficients\n\nIn addition, lie wraps some of these into abstract objects which\nare more mathematically natural:\n\n - AbstractVec: a vector in the rational span of a root system of some\n   Lie group. This includes roots, weights, and linear combinations.\n - weyl: a Weyl group element.\n - toral: a toral element.\n - rep : a Lie group representation.\n\nUsage\n-----\n\nlie implements most functions from LiE\n(see [the documentation](http://www-math.univ-poitiers.fr/~maavl/LiEman/manual.pdf)).\n\nThis example calculation shows how the 10 + 5bar + 1 representation of\nSU(5) [contains a single standard model generation](http://en.wikipedia.org/wiki/Grand_Unified_Theory).\n\n    Python 3.1 (r31:73578, Jun 27 2009, 21:49:46)\n    >>> from lie import *\n\nA4 is SU(5) in Cartan's classifiation, as we can see when we\npretty-print.\n\n    >>> g = A4; g.pprint()\n    'SU(5)'\n\nA representation is shown as \"group(highest-weight-vector)\",\nBut physicists usually label representations by their dimension\n(the b is for \"bar\", or \"dual\").\n\n    >>> r = g.fund().dual() + g.alt_tensor(2) + g.trivial()\n    >>> r\n    A4(0,0,0,0) + A4(0,0,0,1) + A4(0,1,0,0)\n    >>> r.pprint()\n    '(1) + (5b) + (10)'\n\nWe can see that SU(2)xSU(3) is a subgroup of SU(5).\nNext let's get the restriction matrix for SU(2)xSU(3) in SU(5), and\nadd the U(1) part by hand:\n\n    >>> [h.pprint() for h in g.max_subgrps()]\n    ['SU(4)', 'SO(5)', 'SU(2)xSU(3)']\n    >>> m = g.res_mat(A1*A2)\n    >>> m = m.transpose().concat(mat([[-2,1,-1,2]])).transpose()\n\nFinally, we decompose r under the group SU(2)xSU(3)xU(1).\nThe first two numbers are the SU(2) and SU(3) rep dimensions,\nand the third is the U(1) charge.\n\n    >>> r.branch(A1*A2*T1, m).pprint() \n    '(1,1,0) + (1,1,6) + (1,3b,-4) + (1,3b,2) + (2,1,-3) + (2,3,1)'\n\nInstallation\n------------\n\nRequirements:\n\n - Python 3.1 or later (<http://www.python.org/>)\n - Cython (<http://www.cython.org/>)\n - gcc\n\nUsers of Mac OS 10.6 and above should be able to just type \"make\" in\nthe root directory.  I have not had time to tune the Makefiles for\nother systems, so other users should try to make and be prepared for\nsome debugging.\n\nCredits\n-------\n\nWritten by [David Simmons-Duffin](http://davidsd.org) in 2009 for use in:\n \n - D. Poland and D. Simmons-Duffin, \"Superconformal Flavor Simplified,\"\n   arXiv:0910.4585 [hep-ph].\n\nThis module basically wraps the C-source code from:\n\n - M. A. A. van Leeuwen, A. M. Cohen and B. Lisser, \"LiE, A Package for\n   Lie Group Computations\", Computer Algebra Nederland, Amsterdam, ISBN\n   90-74116-02-7, 1992\n\nC-python bridge made possible by [Cython](http://www.cython.org/)\n", 
  "id": 587586
}
{
  "read_at": 1462553825, 
  "description": "Matlab and Python toolbox for fast Total Variation proximity operators", 
  "README.md": "#proxTV\n\nMatlab and Python toolbox for fast Total Variation proximity operators.\n\nFor an up-to-date version, check https://github.com/albarji/proxTV .\n\n##Index\n\n1. Introduction\n2. Referencing\n3. Matlab interface\n  1. Quickstart\n  2. Installation\n  3. Usage\n  4. Examples\n4. Python interface\n  1. Quickstart\n  2. Installation\n  3. Usage\n5. Demos\n5. Contact\n6. Acknowledgements\n\n##Introduction\n\n**proxTV** is a toolbox implementing blazing fast implementations of Total Variation proximity operators. While the core algorithms are implemented in C to achieve high efficiency, Matlab and Python interfaces are provided for ease of use.\n\nThe library provides efficient solvers for the following Total Variation proximity problems:\n\n| Problem | Formulation |\n| ------- | ----------- |\n| Standard (l1) Total Variation on a 1-dimensional signal | ![alt tag](docs/img/TV1.png) |\n| Quadratic (l2) Total Variation on a 1-dimensional signal | ![alt tag](docs/img/TV2.png) |\n| lp-norm Total Variation on a 1-dimensional signal | ![alt tag](docs/img/TVp.png) |\n| Weighted Total Variation on a 1-dimensional signal | ![alt tag](docs/img/TV1w.png) |\n| Anisotropic Total Variation on a 2-dimensional signal | ![alt tag](docs/img/TV2D.png) |\n| lp-norm Anisotropic Total Variation on a 2-dimensional signal | ![alt tag](docs/img/TV2Dp.png) |\n| Weighted Anisotropic Total Variation on a 2-dimensional signal | ![alt tag](docs/img/TV2Dw.png) |\n| Anisotropic Total Variation on a 3-dimensional signal | ![alt tag](docs/img/TV3D.png) |\n| Generalized N-dimensional Anisotropic Total Variation | ![alt tag](docs/img/TVND.png), with X(di) every possible 1-dimensional slice of X following dimension di.|\n\n##Referencing\n\nIf you find this toolbox useful please reference the following papers:\n\n* Fast Newton-type Methods for Total Variation Regularization. Alvaro Barbero, Suvrit Sra. ICML 2011 proceedings.\n    \n* Modular proximal optimization for multidimensional total-variation regularization. Alvaro Barbero, Suvrit Sra. http://arxiv.org/abs/1411.0589\n    \nwhose Bibtex entries are\n\n    @inproceedings{conf/icml/Barbero11,\n      added-at = {2011-12-16T00:00:00.000+0100},\n      author = {Barbero, \\'Alvaro and Sra, Suvrit},\n      biburl = {http://www.bibsonomy.org/bibtex/214ce9f5c15d1d462bd264d8af9e4c3c7/dblp},\n      booktitle = {ICML},\n      crossref = {conf/icml/2011},\n      editor = {Getoor, Lise and Scheffer, Tobias},\n      interhash = {5d6359b6c7f4d0fb6de36aada6827a3e},\n      intrahash = {14ce9f5c15d1d462bd264d8af9e4c3c7},\n      keywords = {dblp},\n      pages = {313-320},\n      publisher = {Omnipress},\n      timestamp = {2011-12-16T00:00:00.000+0100},\n      title = {Fast Newton-type Methods for Total Variation Regularization.},\n      url = {http://dblp.uni-trier.de/db/conf/icml/icml2011.html#JimenezS11},\n      year = 2011\n    }\n    \n    @Article{barberoTV14,\n      Title                    = {Modular proximal optimization for multidimensional total-variation regularization},\n      Author                   = {\\'Alvaro Barbero and Suvrit Sra},\n      Year                     = {2014},\n      Url                      = {http://arxiv.org/abs/1411.0589}\n    }\n\n##Matlab interface\n\n###Quick start guide\n\nTo install proxTV just type \"install\" at the Matlab prompt once located at proxTV folder. If any problem arises please refer to the \"Installation\" section in this file.\n\nAfter that the TV solver can be invoked easily through the general purpose \"TV\" function. For instance,\n\n    TV(X,lambda)\n    \nsolves TV for X signal and lambda regularizer. The dimensionality of X is automatically checked and an adequate solver is applied.\n\nTo solve TV for a general TV-Lp norm just add the value of p as a third argument,\n\n    TV(X,lambda,p)\n    \nWeighted versions of TV can also be solved by using exactly the same interface, but providing a vector of lambda weights instead of a scalar. For multidimensional signals the relevant weights are provided as a cell array; the \"Usage\" section for more detailts on this and more advanced uses of toolbox.\n\n###Installation\n\nTo install proxTV follow the steps:\n\n1. Open Matlab.\n2. Change directory to the folder where this README file is located.\n3. Type: \"install\"\n4. After compilation the message \"proxTV successfully installed\" will appear. If instead an error message shows up, check your mex compiler configuration (type \"mex -setup\"). If the error was produced by the \"openmp\" library, you might need to install it, or you can install proxTV with no multi-thread features by typing \"install(1)\". \n5. The install script automatically adds the relevant proxTV folders to your Matlab path. If this were to fail for some reason, you should manually add the /matlab subfolder to your Matlab path. You can do this e.g. by using the \"pathtool()\" utility. You may also add the /matlab/demos subfolder to try out the included demos.\n\n*Note*: this interface has only been tested under Linux. Installation might require LAPACK (http://www.netlib.org/lapack/) and BLAS (http://www.netlib.org/blas/) libraries.\n\n###Usage\n\nTwo main functions conform the Matlab interface of proxTV: **TV** and **TVgen**. The first one provides basic options over the Total Variation problem, while the second one allows a more advanced configuration. In general, the TV function should suffice for most uses.\n\n####TV\n\nSolves Total Variation proximity operators for n-dimensional signals, applying a TV-Lp norm. The inputs and outputs of this function are:\n\n    [x,info] = TV(y,lambda,p,threads)\n\nInputs\n* y: input of the proximity operator.\n* lambda: premultiplier of the norm.\n* (Optional) p: norm. Default is p = 1.\n* (Optional) threads: number of threads (default 1). Used only for 2-D or higher-dimensional signals.\n\nOutputs\n* x: solution of the proximity problem.\n* info: statistical info of the run algorithm:\n  * info.iters: number of iterations run (major iterations for the 2D case)\n  * info.stop: value of the stopping criterion.\n       \nFor 1-dimensional signals the problem solved is\n\n![alt tag](docs/img/TVp.png)\n    \nUsing p=1 results in the standard Total Variation regularizer, which generates a \"blocky\" reconstruction of the signal. Using p=2 instead produces a smoother reconstruction.\n\nFor 2-dimensional signals (e.g. images) the problem solved is\n\n![alt tag](docs/img/TV2Dp.png)\n    \nwhere X(i,:) is i-th row of X and X(:,j) is the j-th column of X. Using p=1 results in an anisotropic denoising filter.\n\nFor D-dimensional signals the problem being solved becomes\n    \n![alt tag](docs/img/TVNDuniform.png)\n    \nwhere X[d,i] is the i-th 1-dimensional fiber of X along its d-th dimension, and TV1D denotes the standard 1-dimensional Total Variation penalty applied over such fiber.\n\nIf a vector of weights *w* is provided for the lambda parameter instead of an scalar value, the special weighted version of TV is solved,\n\n![alt tag](docs/img/TV1w.png)\n    \nwere each difference among signal entries x_i and x_(i-1) is penalized using a different weight w_i.\n\nIn the case of 2D signals the weighted problem is\n\n![alt tag](docs/img/TV2Dw.png)\n    \nWeight matrices are provided in the TV function as the lambda parameter through a cell array in the form {w, v} (see the examples in the \"Examples\" section)\n\n####TVgen\n\nSolves a generalized TV proximity operator for a multidimensional signal, in the form\n    \n![alt tag](docs/img/TVND.png)\n, with X(di) every possible 1-dimensional slice of X following dimension di.\n    \nThe inputs and outputs of this function are:\n\n    [x,info] = TVgen(y,lambdas,ds,norms,threads)\n\nInputs:\n* y: input signal.\n* lambdas: vector of lambda penalties of each penalty term.\n* ds: vector of dimensions of application of each penalty term.\n* norms: vector of norms of each penalty term.\n* (Optional) threads: number of threads to use (default: 1)\n\nOutputs:\n* x: solution of the proximity problem.\n* info: statistical info of the run algorithm:\n  * info.iters: number of major iterations run.\n  * info.stop: value of the stopping criterion.\n       \nWhen possible, TV should be preferred. See the Examples section next for some specific examples on using this function.\n\n###Examples\n\n####1D examples\n\nFilter 1D signal using TV-L1 norm:\n\n    TV(x,lambda)\n    \nFilter 1D signal using weighted TV-L1 norm (for x vector of length N, weights vector of length N-1)\n\n    TV(x,weights)\n    \nFilter 1D signal using TV-L2 norm:\n\n    TV(x,lambda,2)\n    \nFilter 1D signal using both TV-L1 and TV-L2 norms:\n\n    TVgen(X,[lambda1 lambda2],[1 1],[1 2])\n    \n####2D examples\n\nFilter 2D signal using TV-L1 norm:\n\n    TV(X,lambda)\n    \nor\n        \n    TVgen(X,[lambda lambda],[1 2],[1 1])\n\nFilter 2D signal using TV-L2 norm:\n\n    TV(X,lambda,2)\n    \nor\n\n    TVgen(X,[lambda lambda],[1 2],[2 2])\n    \nFilter 2D signal using 4 parallel threads (last argument):\n\n    TV(X,lambda,1,4)\n    \nor\n\n    TVgen(X,[lambda lambda],[1 2],[1 1],4)\n\nFilter 2D signal using TV-L1 norm for the rows, TV-L2 for the columns, and different penalties:\n\n    TVgen(X,[lambdaRows lambdaCols],[1 2],[1 2])\n    \nFilter 2D signal using both TV-L1 and TV-L2 norms:\n\n    TVgen(X,[lambda1 lambda1 lambda2 lambda2],[1 2 1 2],[1 1 2 2])\n    \nFilter 2D signal using weighted TV-L1 norm (for X image of size MxN, W1 weights of size (M-1)xN, W2 weights of size Mx(N-1))\n\n    TV(X, {W1, W2})\n    \n####3D examples\n\nFilter 3D signal using TV-L1 norm:\n\n    TV(X,lambda)\n    \nor\n\n    TVgen(X,[lambda lambda lambda],[1 2 3],[1 1 1])\n\nFilter 3D signal using TV-L2 norm, not penalizing over the second dimension:\n\n    TVgen(X,[lambda lambda],[1 3],[2 2])\n\n## Python interface\n\n### Quickstart\n\nYou can install the latest version of proxTV through **pip** running\n\n    pip install prox-tv\n    \nPlease note that some prerequisites might not be installed in your system. In case of failure during pip install, refer to the Prerequisites section.\n\nIf you want to install from source, please refere to the Installation section.\n\n###Installation\n\n####Prerequisites\n\nTo use proxTV within Python the following prerequisites are necessary\n\n- **cffi**: https://cffi.readthedocs.org/en/latest/\n- **numpy**: http://www.numpy.org/\n\nYou can install **cffi** through **pip**:\n\n    pip install cffi\n  \nBe aware that other packages might be required to install cffi, such as **python-dev** and **libffi-dev**. For a full list of dependencies please refer to cffi documentation (https://cffi.readthedocs.org/en/latest/).\n\nAdditionally, in order to generate the toolbox documentation the following packages are needed as well:\n\n- **sphinxcontrib-napoleon**\n- **sphinx_rtd_theme**\n\nFinally, if you would like to run the provided demos you will also require the following packages:\n\n* **matplotlib**: http://matplotlib.org/\n* **scipy**: http://www.scipy.org/\n* **scikit-image**: http://scikit-image.org/\n\n####Manually installing proxTV Python package\n\nAfter prerequisites have been satisfied, just run\n\n    python setup.py install\n    \non the folder where this README file is located. You might need superuser permissions for a correct installation.\n\n####Generating docs\n\nDocumentation is available only at http://pythonhosted.org/prox_tv/. Nevertheless if you would like to compile the docs yourself you just need to run\n\n    make html\n    \nin the docs/ folder. The documentation will be generated in the doc/_build/html/index.html file.\n\n###Usage\n\nImport proxTV Python package as\n\n    import prox_tv as ptv\n    \nor\n\n    from prox_tv import *\n    \nfor direct access to all the package routines.\n    \nThe documentation of use of the package functions is maintained online at http://pythonhosted.org/prox_tv/.\n\n##Demos\n\nSome demos in the form of both Matlab and Python scripts showing how to work with proxTV are included in the subfolders /matlab/demos and /prox_tv/demos, respectively. They are:\n\n- **demo_filter_signal**: TV-L1, TV-L2 and weighted TV-L1 filtering of 1-dimensional signals.\n- **demo_filter_image**: TV-L1 filtering of 2-dimensional image.\n- **demo_filter_image_color**: TV-L1 filtering of 3-dimensional image (length, width and color).\n- **demo_filter_image_threads**: multi-thread TV-L1 filtering of 2-dimensional image.\n- **demo_filter_image_weighted**: weighted TV-L1 filtering of 2-dimensional image.\n\n## Contact\n\nFor any questions and comments, please email alvaro.barbero@uam.es\n\n## Acknowledgements\n\nWe wish to thank the following people for helping us in debugging and extending the toolbox:\n\n- **Zico Kolter** for pointing out a bug in our Projected Newton method.\n- **Sesh Kumar** for spotting and correcting a bug in our weighted 1D-TV method.\n- **Josip Djolonga** for implementing the Python bindings.\n- **Fabian Pedregosa** for improving MacOS support.\n", 
  "id": 26431011
}
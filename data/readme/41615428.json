{
  "read_at": 1462546033, 
  "description": "An Algorithm for Building Markov Models from Time Series", 
  "README.md": "CSSR\n=======\nCSSR tries to infer the minimal Markovian model capable of generating a\ntime-series, or set of time-series from the same source.  The program\nimplements the algorithm proposed in the paper \"Blind Construction of Optimal\nNonlinear Recursive Predictors for Discrete Sequences\", hereafter BC.  [Cosma\nRohilla Shalizi and Kristina Lisa Shalizi, pp. 504--511 of Max Chickering and\nJoseph Halpern (eds.), _Uncertainty in Artificial Intelligence: Proceedings of\nthe Twentieth Conference_, available from http://arxiv.org/abs/cs.LG/0406011.]\nWe won't describe the algorithm in any detail here (see BC for that), but the\nnext two paragraphs say a little about what it produces and how it does it.\n\nThe output of the algorithm is a set of states which form a Markov chain.  Each\nstate has a certain probability of emitting any of the symbols in the original\ntime series.  The current state and the symbol it emits fix the next state.\n(The states are \"future-resolving\", if you're from nonlinear dynamics, or\n\"deterministic\", if you're from automata theory.)  Each state, moreover,\ncorresponds to a distinct set of strings, in the following sense.  If the state\nA contains a string w, and at time t the time-series ends with w, then at time\nt the Markov chain is in state A.  The set of states, their transition\nprobabilities and connections, is called the state machine.\n\nThe algorithm uses a recursive inference procedure to find the simplest set of\nstates with the above properties that can reproduce the statistical properties\nof the data.  If we could give the algorithm an infinitely long time series,\nand let it consider infinitely long sub-strings, it would produce the causal\nstates of the process, which are its ideal predictors (see BC for a formal\ndefinition).  Since we have only finite data, there is always some probability\nthat the inferred or estimated states are not the true causal states.\nNonetheless, for the rest of this file, when we say \"causal states\", we mean\nthe estimated causal states.\n\n\n\nObtaining and Installing the Program\n--------------\nThe code for CSSR can be obtained from http://bactra.org/CSSR/.  If you'd like\nto set up a new archive for it, we'd appreciate hearing about it.\n\nFrom any site, download the CSSR-v0.1.tar.gz file for the code.  When gunzipped\nand untarred, this will produce a directory called CSSR-v0.1, containing all\nthe necessary header and source code files, a copy of this documentation, the\nrelease license, and a make file. Running make inside that directory will\nproduce an executable, which should be moved to someplace in the command\npath. On most Unix systems, the following sequence of commands will create the\nexecutable and put it in the your bin directory, usually part of your command\npath.\n\n    gunzip CSSR-v0.1.tar.gz\n    tar xvf CSSR-v0.1.tar\n    cd CSSR-v0.1\n    make\n    cp CSSR ~/bin/\n\nThe code has been successfully compiled with gcc 3.1 on Macintosh OS X (10.2),\nwith gcc 3.2 on Linux (Red Hat 9, SUSE 9), with gcc 3.3 on Macintosh OS X\n(10.3) and with Microsoft Visual C++ on Windows 98.  On some systems,\ncompilation may produce warnings about escape sequences or the use of\ndeprecated headers.  These can be safely ignored.\n\n\nUsage\n--------------------\nCSSR is a command-line program.\n\n    CSSR alphabetfile datafile maxlength [-m] [-s siglevel] [-ch]\n\nThe first argument is the name of a file which contains all the symbols in the\nalphabet used by your data.  The second argument is the name of the data file\nitself.  Only one data file can be used, but it may contain multiple lines.\nThe third argument is the maximum length of history to examine, which we will\nabbreviate by L here.  The three trailing flags are optional arguments.  Set\nthe -m flag if the data-file contains multiple lines (see below).  If the -s\nflag is set, it must be followed by a significance level; the default value is\n0.001.  (For more on setting parameters, see Section 4.)  If the -ch flag is\nset, the program will use the chi-squared significance test, rather than the\ndefault Kolmogorov-Smirnov test.\n\nIn multiple-line mode (entered through the -m flag), each line of the data file\nis treated as a distinct time series from the same source.  (Technically, as\nindependent realizations of a single stochastic process.)  The lines need not\nbe of equal length.\n\nThe program will create the following files after running, where\ndatafile is the name of the file the data is in:\n\n\t1. datafile_results\n\t2. datafile_info\n\t3. datafile_state_series\n\t4. datafile_inf.dot\n\n(1) contains the information on the inferred states and their properties.  For\neach state, it gives:\n\t* the histories of length $L-1$ and $L$ in the state\n\t* the probability that the state will emit different symbols (e.g.\nP(a) = x) and the states transitioned to when those symbols are emitted (e.g.\nT(a) = s)\n\t* the observed probability of the state in the data-stream\n\n(2) is the file containing the command-line settings and the metrics run on the\ncausal state machine.  These are:\n\t* the name of the alphabet file\n\t* the alphabet size\n\t* the name of the data file\n\t* the history length\n\t* the significance level\n\t* whether multi-line mode was used\n\t* whether the chi-squared test was used\n\t* the number of states\n\t* the statistical complexity (entropy of the states)\n\t* the entropy rate\n\t* three measures of the difference between the empirical distribution\nofsymbol sequences, and that generated by the inferred causal state machine.\nThese are: the divergence or relative entropy between the inferred and\nempirical distribution; the relative entropy rate, or increase per symbol in\nthe divergence; the total variational distance (\"variation\") between the two\ndistributions.\n\nNote that the relative entropy and the relative entropy rate can be infinite;\nthis indicates that the inferred model gives a probability of zero to a\nsequence in the data.\n\nNote that sometimes, when the relative entropy should be very small (order of\n1e-6 bits or less), numerical rounding errors result in a negative number being\ncalculated.  In these cases, the program outputs zero.  Similarly, the\ncomplexity of one-state machines is sometimes reported as -0.\n\n(3) is the series of causal states in the data.  That is, the program scans\nthrough the data, looks up which state the history-to-date is in, and writes\nthe corresponding symbol to this file.  What you see is then the trajectory\nthrough estimated causal state space of the data/process. Multiline data\nresults in a multiline state-series file.\n\n(4) represents the state machine as a labeled directed graph, where each state\nhas its own node, and each transition between states its own edge.  The file is\nfor use with the program dot, available from http://www.graphviz.org/.\n\n\nSome Suggestions About Parameters\n------------------------------\n\nIt is always good to use as much data as you can.  While it is generally good\npractice to hold back some data for testing or cross-validation, we recommend\nthat this be minimized.  High-entropy processes are especially data-hungry.\n(See BC.)  For reference, let us call the number of data-points N.\n\nThe two key parameters of the program are the maximum history length, L, and\nthe significance level used in the test, s. For any given process, there is a\nminimum history length M, such that the true states cannot be found if L < M.\nThe number of states returned may be less than the correct number or higher.\nIf L >= M, and there is enough data, there will generally be a \"plateau\" of\nvalues of L where the correct number of states is returned.  For fixed N, if we\nkeep increasing L, then past a certain point there are not enough examples of\neach string in the data.  This tends to erroneously create new states, which\nspawn others through determinization.  Thus there is generally a \"blow-up\" when\nL is too large (relative to N and s).  A rough guide-line is to limit L to no\nmore than log(N)/log(k), where k is the alphabet size (see BC for\ndetails).\n\nIn general, one should use as small an L as possible, since under-sampling,\neven before the blow-up, will reduce the accuracy of many probability\nestimates.  Blow-up can be delayed by reducing s --- that is, reducing the\nprobability of mistakenly splitting a state --- but this carries the risk of\nfailing to create valid new states.  We suggest exploring the data at low L and\nhigh s initially, and then increasing L and lowering s.  If a stable\narchitecture is found, it should be recorded at the lowest possible L.\n\n\nKnown Issues\n------------------------\nThere are a few known issues with CSSR's behavior.  These arise from certain\nunavoidable approximations in the determinization procedure.  (For details, see\nbelow.)\n\nAfter creating and determinizing the states, CSSR goes over the input data and\nattempts to produce the corresponding sequence of causal states, both as a\nfiltering procedure, and as part of estimating the fit of the causal-state\nmodel (see Section 3, item (3)). Typically there will be some initial number of\nsymbols which it must read before \"synchronizing\" to one of the causal states,\nafter which it will follow the transitions deterministically, and never\nde-synchronize.  Because of the approximations mentioned, it can happen that\ncertain transitions are deleted from the causal state model which shouldn't be.\nThis can lead to three kinds of problem: (1) CSSR can never synchronize to a\nstate at all; (2) it has to re-synchronize at some point; (3) it encounters an\napparently \"impossible\" sequence in the data.\n\nIn case (1), CSSR writes the message \"Error: Could not synchronize, cannot use\nthis data\" to standard error and halts execution.  In case (2), it produces a\nwarning message on both standard error and the info output file.  In case (3),\nit produces a warning, and discounts that particular string from various\ncalculations.\n\nThe best approach to these problems is to use a longer history length, if\npossible, and to provide more data.  In the case of a third error, it can\nsometimes arise if a particular string appears only once, at the very beginning\nof the data, and sometimes removing that string from the data-file fixes\nmatters.\n\nAll three errors arise because we have only finite-length histories available\nto us, while what we want are really infinite ones.  This forces us to make\ncertain approximations in our implementation of the theory. Specifically, in\nthe determinization procedure, we are forced to \"guess\" which state certain\nstrings belong to, even though we have not directly examined these strings.\nThe particular approximation scheme (or \"closure\") we have adopted may be\ninvestigated by consulting the code in AllStates.cpp. (Others are possible, but\nthis one seemed to give the best over-all results.) Sometimes this closure will\n\"guess wrong\", and possible transitions will be labeled forbidden, etc.  In\nthese cases, extending the history length _should_ solve the problem, if enough\ndata is available for reliable inference.  Similar approximations must be made\nin determining whether or not a given state is transient or recurrent on the\nbasis of finite data. This occasionally leads to a recurrent state being\nlabeled transient, which in turn is the most common cause of the code mistaking\nan actually-occurring string for an impossible one.  Again, the best approach\nis to provide more data, and a longer history.\n\n\nBug Reports, Fixes, Modifications\n-----------------------------\nWe welcome bug reports or reports of strange behavior.  These reports are\nwelcomed with more enthusiasm when accompanied by successful modifications to\nthe code!  (See the accompanying file on the Gnu Public License for information\nabout modifying the code.)  Even if you can't fix it, however, please do tell\nus about it; at the least it will be documented for other users.\n\nIf you modify CSSR, and want to make the resulting program available, please\nlet us know.  We are happy to provide a link, and have a (limited) capability\nto host alternate versions and descendants.  Also, if you use CSSR\nsuccessfully in some application, we'd love to hear about it.\n\nPlease check [bactra.org/CSSR][cssr] for up-to-date contact information.\n\n\nSome Details on the Code\n----------------------\nThere are twelve classes in the program. They are each comprised of a .cpp file\nand a .h file, except for `ArrayElem` (contained in `G_Array`) and `StringElem`\n(contained in `State`), as well as a source file `Main`, and header files\n`Common.h` and `Main.h`.\n\nClass       | Description\n------------|------------------------------------------------------------------\n`AllStates` | Contains and manipulates growable array of states\n`ArrayElem` | Each element in the growable array\n`G_Array`   | A generic growable array\n`Hash`      | Hash table which points from histories to their parent states\n`Hash2`     | Hash table which points from indices to symbol/alpha values\n`Machine`   | Manipulates the determinized state machine and runs metrics\n`ParseTree` | Reads in data file and stores all strings present in file up to length L (the maximum length input at the command line)\n`States`    | A state, contains all data for a single state\n`StringElem`| The element containing the history for a single state\n`Test`      | Performs statistical significance tests\n`TransTable`| Stores initially estimated transitions from all histories of length L in any given state. This class is used by AllStates to check for transient states before determinization\n\nFor brief descriptions of the classes, see the top of their source files.  Note\nthat the terms \"string\" and \"history\" are used interchangeably in the program.\nThe terms both correspond to the concept of a \"history\" (as described in\nBC), but the program implements these as strings of symbols.\n\nAlso, after initial state splitting, all strings/histories of less than maximum\nlength minus one are deleted.  This has no effect on the outcome of the\nalgorithm and saves time and space.\n\nLastly, the removal of transient states prior to determinization implemented in\nthe AllStates::CheckConnComponents procedure is not strictly necessary.  With a\ndifferent implementation, the deletion of these states could automatically\noccur during the determinization process itself (see the pseudocode in BC\nfor details), and the outcome of the algorithm would be the same.  As it is\nimplemented here the code is slightly redundant.\n\n", 
  "id": 41615428
}
{
  "read_at": 1462550783, 
  "description": "", 
  "README.md": "A Python library for fault tolerance simulations of the surface code\nusing the [Blossom 5 implementation by Kolgomorov](http://pub.ist.ac.at/~vnk/software.html) [1] of Edmond's perfect matching algorithm [2].\n\nThree different fault tolerance scenarios are covered by this library\n\n* Surface code (planar and toric) under random noise\n* Surface code (planar and toric) under noise defined by a superoperator description of noisy stabilizer measurements\n* Planar code implemented in solid state spins\n\n### Compiling the perfect matching code\n\nUse command ``make`` in directory blossom5/ to compile the perfect matching code to be used by the decoder. \n\n# Surface code under random noise\n\n\n## Toric code under random noise\n\n```python\n\nimport st\n\nsize = 8    # The lattice dimension, L. Number of qubits = 2*L^2\ntSteps = 8  # The number of complete rounds of stabilizer measurement\npErr = 0.1  # The probability of a physical error on each qubit in any one round of measurement\npLie = 0.05 # The probability that a stabilizer outcome is misreported\n\nresult = st.run3Drandom(size,tSteps,pErr,pLie)\n\n```\nThe result is a vector describing the state of the encoded logical qubits after error correction has been attempted. E.g. \n\n```python\nresult = [[1,1],[-1,1]]\n```\n\nThis means that the first logical qubit has no logical error, while the second logical qubit has ended up with an X flip. \n\nThis function should be run a large number of times to build up statistics on the success probability of the decoder under the given error rates.\n\n\n## Planar code under random noise\n\nThis functions very similarly to the toric code \n\n```python\n\nimport sp\n\nresult = sp.run3Drandom(size,tSteps,pErr,pLie)\n\n```\n\nSince the planar code only encodes one qubit, the result is now just an array of 2 elements, e.g.\n\n```python\nresult = [1,-1]\n```\nwould correspond to the case where a Z flip had occurred on the logical qubit after the attempted error correction. \n\n\n# Error described by a stabilizer superoperator\n\nThis variant of the code puts a more general form of errors into the code, characterised by the superoperator describing the true (noisy) process of measuring each stabilizer. This superoperator provides a full description of the noisy measurement, and if physical errors are made up of randomly applied Pauli operations, this superoperator can be decomposed into Kraus operators that are simply some product of Pauli operations on the qubits in the stabilizer combined with a possible misreported stabilizer outcome. For more detail see [[3](http://www.nature.com/ncomms/journal/v4/n4/abs/ncomms2773.html)], [[4](http://arxiv.org/abs/1406.0880)].\n\nThis superoperator decomposition is specified through a text file of the form found in ``` example_error_vec.txt ```. \n\n##Toric Code\n\n\n### Defining the noise model\n\nFor the toric code, all stabilizer measurements are 4 body operations, so only one superoperator must be specified. If we measure a stabilizer which, if noiseless, should return an EVEN (+1) parity outcome. Physical errors occuring during the measurement circuit, however, will sometimes result in a different operation even when an EVEN result is reported. The input to the toric code simulator takes as input the probabilities of the following possibilities, where for example EVEN,IIXX describes the case where an even parity projection is followed by X errors on 2 of the 4 qubits (in any configuration). Only errors of up to two qubits are specified since 3 or more qubit errors are very unlikely to occur in the low error regime. \n\n<table>\n  <thead>\n    <tr>\n      <td> Parity projection </td>\n      <td> Qubit errors </td>\n      <td> Probability </td>\n    </tr>\n  </thead>\n  <tbody>\n    <tr><td> EVEN </td><td> I I I I </td><td>p<sub>EVEN,0</sub></tr>\n    <tr><td> EVEN </td><td> I I I Z </td><td>p<sub>EVEN,1</sub></tr>\n    <tr><td> EVEN </td><td> I I I X </td><td>p<sub>EVEN,2</sub></tr>\n    <tr><td> EVEN </td><td> I I I Y </td><td>p<sub>EVEN,3</sub></tr>\n    <tr><td> EVEN </td><td> I I X X </td><td>p<sub>EVEN,4</sub></tr>\n    <tr><td> EVEN </td><td> I I X Y </td><td>p<sub>EVEN,5</sub></tr>\n    <tr><td> EVEN </td><td> I I Y Y </td><td>p<sub>EVEN,6</sub></tr>\n    <tr><td> EVEN </td><td> I I X Z </td><td>p<sub>EVEN,7</sub></tr>\n    <tr><td> EVEN </td><td> I I Y Z </td><td>p<sub>EVEN,8</sub></tr>\n    <tr><td> EVEN </td><td> I I Z Z </td><td>p<sub>EVEN,9</sub></tr>\n    <tr><td> ODD </td><td> I I I I </td><td>p<sub>ODD,0</sub></tr>\n    <tr><td> ODD </td><td> I I I Z </td><td>p<sub>ODD,1</sub></tr>\\\n    <tr><td> ODD </td><td> ... </td></tr>\n  </tbody>\n</table>\n\nThese probabilities are input through a text file with the following format: \n\n```\n#ERRORVEC4\n\np_error_1 p_EVEN,0  p_EVEN,1  p_EVEN,2 p_EVEN,3 .... p_ODD,0 p_ODD,1 ... p_ODD,9  \np_error_2 p_EVEN,0  p_EVEN,1  p_EVEN,2 p_EVEN,3 .... p_ODD,0 p_ODD,1 ... p_ODD,9  \np_error_3 p_EVEN,0  p_EVEN,1  p_EVEN,2 p_EVEN,3 .... p_ODD,0 p_ODD,1 ... p_ODD,9  \n...\n\n```\n\n### Simulating fault tolerance\n\nWith the superoperator defined in the textfile, these values can be imported using the ```load_errors``` module, and toric code error correction simulated using the ```st.run3D()``` function.\n\n```python\n\nimport st\nimport load_errors\n\nsize=6\ntSteps=5\ntimespace=[1,1]\nstabilizersNotComplete=0\n\n## Load error vector from file                                                                                           \nevecs3,evecs4 = load_errors.load(\"example_errorvec.txt\")\nerror_vector4 = evecs4[evecs4.keys()[0]]\n\n\n[x,z],[x2,z2] = st.run3D(size,tSteps,error_vector4,timespace,stabilizersNotComplete)\n\n\n```\n\nThe ```timespace``` parameter is a vector of two integers, that defines relative weightings between the time and space directions in the perfect matching attempt to correct this errors. This parameter should be optimised for the specific errors considered.\nThe ```stabilizersNotComplete``` parameter gives the probability that a given stabilizer is not evaluated. For example if ```stabilizersNotComplete=0.01```, the code will simulate the even that 1% of stabilizer measurements are not recorded, and the correction procedure will attempt to fix the code without any information about those stabilizer measurements.\n\n\n\n\n\n# Solid state spin implementation of the surface code\n\nSimulations of our solid state implementation of the surface code call only on the planar variant of the code. Each simulation generates a lattice of spins via ```arrayMaker.py``` which takes a number of parameters to construct a superoperator for each stabilizer on the defective lattice. For more detail on this model, see [[5](http://arxiv.org/abs/1406.5149)].\n\n```python\n\nimport sp\n\nsize=6                 # The size of the lattice\n\n# ----- ORBIT TYPE ------- #\norbit='circle'         # the orbit 'abrupt' or 'circle' determines the phase interpolating function used to generate error                               superoperator from spin misalignment\n\n# ----- POSITIONAL ERROR DISTRIBUTION ------- #\n# ------------------------------------------------------------#\n# ------- (distance from probe to data qubit is unity) ------- #\nerrortype= 'pillbox'   # the shape of the error distribution for qubit position on lattice\n                      #     'normal' - a 3D normal distribution of errors. Standard\n                      #         deviation in each dimension specified by parameters: sdInX, sdInY and sdInZ \n                   #     'disc' - a 2D uniform circlular distribution, the radius is specified by sdInX, sdInY\n                      #     'pillbox' - a 3D cylindrical (in z-dimension) uniform distribution\n                      #           the radius of the cylinder is specified by sdInX & sdInY, and the half-height of the\n                      #           cylinder by sdInZ\nsdInX=0.1              # in-plane (x) error parameter for qubit position\nsdInY=0.1              # in-plane (y) error parameter for qubit position\nsdInZ=0.05             # z-dirn or height error parameter for qubit position //note: physical location errors where average                     \n# ----- ERROR PARAMETERS ------- #                      \npJ=0.0004              # Phase Jitter - pJ = O(delta^2)\n                       # where delta is a small error in the phase accumulation on the probe, ideal phase being pi/2 with   \n                       # a symmetric distribution of possible phase errors parametrised by delta. This arises from an error in\n                       # the  interaction time between probe qubit and data qubit. The constants in front of delta^2 depend on \n                       #the  type of random distribution being considered. E.g. for a bimodal distribution {+delta ,-delta}\n                       #then pJ~delta^2/4, for a uniform distribution (-delta,+delta) then pJ~delta^2/12.  This manifests\n                       #itself as a phase error on both the data qubit and the probe qubit occuring with probability pJ.\n                       # This is described by an error map: \n                       # E(rho) = (1-pJ) rho + pJ* Z_data.Z_probe (rho) Z_data.Z_probe\n                       # where rho is the state after the ideal interaction.\n\npX=0.001/3              \npY=0.001/3\npZ=0.001/3             #three components (Pauli-X,Y,Z) of the probe flip error\n\nprep=0.01              #probe initialisation error - phi_probe = (1-prep) |+> + prep |->\n\npLie=0.05              # probability of a measurment error. Applies a measurement operator of the form\n                       #M_even(rho) = (1-pLie)|even><even| + pLie |odd><odd|\n                       \npErr=0.002             # data qubit decoherence - randomly apply an X,Y or Z with this probability between cycles             \n\n\ntSteps=20\ntimespace=[1,1]\nboundary=1\n\nresult = sp.run3Dspin(size,errortype,orbit,tSteps,[sdInX,sdInY,sdInZ,pJ,pX,pY,pZ,prep,meas,data],timespace,boundary)\n\n```\n\n\n[1] Kolmogorov, V. Blossom V: a new implementation of a minimum cost perfect matching algorithm. Math. Prog. Comp. 1, 43-67 (2009).<br>\n[2] Edmonds, J. Paths, Trees, and Flowers, Canad. J. Math. 17, 449-467 (1965) .<br>\n[3] [Topological quantum computing with a very noisy network and local error rates approaching one percent <br>\nNH Nickerson, Y Li, SC Benjamin Nature communications 4, 1756](http://www.nature.com/ncomms/journal/v4/n4/abs/ncomms2773.html) <br>\n[4] [Freely Scalable Quantum Technologies using Cells of 5-to-50 Qubits with Very Lossy and Noisy Photonic Links\nNH Nickerson, JF Fitzsimons, SC Benjamin arXiv preprint arXiv:1406.0880](http://arxiv.org/abs/1406.0880) <br>\n[5] [A silicon-based surface code quantum computer, J O'Gorman, NH Nickerson, P Ross, JJL Morton, SC Benjamin arXiv preprint arXiv:1406.5149](http://arxiv.org/abs/1406.5149)\n", 
  "id": 18768079
}
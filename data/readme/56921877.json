{
  "read_at": 1462548510, 
  "description": "Fast complex polynomial root finder, with support for arbitrary precision calculations", 
  "README.md": "# PolynomialRoots\n\n[![Travis Build Status on GNU/Linux and OS X](https://travis-ci.org/giordano/PolynomialRoots.jl.svg?branch=master)](https://travis-ci.org/giordano/PolynomialRoots.jl) [![Appveyor Build Status on Windows](https://ci.appveyor.com/api/projects/status/jfa9e54lv92rqd3m?svg=true)](https://ci.appveyor.com/project/giordano/polynomialroots-jl) [![Coverage Status](https://coveralls.io/repos/github/giordano/PolynomialRoots.jl/badge.svg?branch=master)](https://coveralls.io/github/giordano/PolynomialRoots.jl?branch=master) [![codecov.io](https://codecov.io/github/giordano/PolynomialRoots.jl/coverage.svg?branch=master)](https://codecov.io/github/giordano/PolynomialRoots.jl?branch=master) [![PolynomialRoots](http://pkg.julialang.org/badges/PolynomialRoots_0.4.svg)](http://pkg.julialang.org/?pkg=PolynomialRoots) [![PolynomialRoots](http://pkg.julialang.org/badges/PolynomialRoots_0.5.svg)](http://pkg.julialang.org/?pkg=PolynomialRoots)\n\nIntroduction\n------------\n\n`PolynomialRoots.jl` is a library for finding roots of complex polynomials,\nwritten in [Julia](http://julialang.org/).\n\nThis is an implementation in Julia of the\n[General Complex Polynomial Root Solver](http://www.astrouw.edu.pl/~jskowron/cmplx_roots_sg/),\nwritten in Fortran, by **Jan Skowron** and **Andrew Gould**.  All the credits\ngoes to them for the original algorithm.\n\nThe root finding algorithm employed in this library is described in\n\n* J. Skowron & A. Gould, 2012, \"General Complex Polynomial Root Solver and Its\n  Further Optimization for Binary Microlenses\",\n  [arXiv:1203.1034](http://arxiv.org/abs/1203.1034)\n\nThis algorithm aims to be fast and precise, more than the well known `zroots`\nprocedure described in *Numerical Recipes* books, whose implementations in C and\nFortran are not available as free software, according to the\n[definition](https://www.gnu.org/philosophy/free-sw.html) of the Free Software\nFoundation.\n\n`PolynomialRoots.jl` can also take advantage of native arbitrary precision\ncapabilities of Julia and achieve more precise results.\n\n**Note**: the adopted algorithm can give highly inaccurate results for\npolynomials of order above ~30.  This can be mitigated by using multiple\nprecision calculations (see example below).\n\nInstallation\n------------\n\n`PolynomialRoots.jl` is available for Julia 0.4 and later versions, and can be\ninstalled with\n[Julia built-in package manager](http://docs.julialang.org/en/stable/manual/packages/).\nIn a Julia session run the command\n\n```julia\njulia> Pkg.add(\"PolynomialRoots\")\n```\n\nYou may need to update your package list with `Pkg.update()` in order to get the\nlatest version of `PolynomialRoots.jl`.\n\nUsage\n-----\n\nAfter installing the package, run\n\n``` julia\nusing PolynomialRoots\n```\n\nor put this command into your Julia script.\n\n`PolynomialRoots.jl` provides two functions to find the roots of complex\npolynomials\n\n``` julia\nroots(polynomial[, roots, polish=true, epsilon=1e-20])\nroots5(polynomial[, roots, epsilon=1e-20])\n```\n\n`roots` can be used to solve polynomials of any degree, `roots5` is tailored to\n(and works only for) polynomials of degree 5.  This function exists because\n[one of the methods](http://dx.doi.org/10.1086/309566) to calculate\n[gravitational microlensing](https://en.wikipedia.org/wiki/Gravitational_microlensing)\namplification by a binary lens requires solving a fifth-order complex\npolynomial.  `roots5` should be more robust than `roots` for this class of\npolynomials.\n\nThe mandatory argument for both functions is:\n\n* `polynomial`, the vector holding coefficients of the polynomial you want to\n  solve, in ascending order, from the lowest to the highest.  Coefficients can\n  be complex and real\n\nOptional arguments are:\n\n* `roots`: if you roughly know in advance the position of the roots, you can\n  pass the vector with the known roots to speed up convergence.  `roots` vector\n  must be one element shorther than `polynomial`.  In `roots5`, the roots will\n  be only polished.  Elements of the vector can be complex and real\n* `polish` (boolean keyword, only for `roots`): if set to `true`, after all\n  roots have been found by dividing original polynomial by each root found, all\n  roots will be polished using full polynomial.  Default is `false`\n* `epsilon` (floating point optional keyword): this is used to determine the\n  stopping criterion described in Skowron & Gould paper.  If not set, it\n  defaults to machine precision of `polynomial` (and `roots`) argument(s).  This\n  is *not* the precision with which the roots will be calculated.\n\nThe functions return in output the `Complex` vector with all roots of\n`polynomial`.  **Note:** if `roots` optional argument is provided, it is *not*\nchanged in-place.\n\nExamples\n--------\n\nFind the roots of\n\n```\n(x - i)*(x - 2)*(x - 3*i)*(x - 4)*(x - 5*i) =\n  x^5 - (9*i + 6)*x^4 + (54*i - 15)*x^3 + (138 - 57*i)*x^2 - (184 + 90*i)*x + 120*i\n```\n\nThis is a fifth-order polynomial, so we can find its zeros with both `roots` and\n`roots5`:\n\n``` julia\njulia> roots([120im, -(184 + 90im), (138 - 57im), (54im - 15), -(6 + 9im), 1])\n5-element Array{Complex{Float64},1}:\n -1.55431e-15+5.0im\n 4.0+1.77636e-16im\n  1.55028e-15+3.0im\n -1.04196e-16+1.0im\n 2.0-2.00595e-16im\n\njulia> roots5([120im, -(184 + 90im), (138 - 57im), (54im - 15), -(6 + 9im), 1])\n5-element Array{Complex{Float64},1}:\n  5.92119e-16+5.0im\n  4.0-1.4803e-16im\n 2.0+1.88202e-16im\n -1.88738e-15+3.0im\n  2.10942e-15+1.0im\n```\n\n`PolynomialRoots.jl` handles polynomials with high-multiplicity roots as well.\nFor example, consider\n\n```\n(x + 1)^5 = x^5 + 5x^4 + 10x^3 + 10x^2 + 5x + 1\n```\n\nYou can find its roots with\n\n``` julia\njulia> roots([1, 5, 10, 10, 5, 1])\n5-element Array{Complex{Float64},1}:\n -1.0+0.0im\n -1.0+0.0im\n -1.0+0.0im\n -1.0+0.0im\n -1.0+0.0im\n\njulia> roots5([1, 5, 10, 10, 5, 1])\n5-element Array{Complex{Float64},1}:\n -1.0+0.0im\n -1.0+0.0im\n -1.0+0.0im\n -1.0+0.0im\n -1.0+0.0im\n```\n\n### Arbitrary precision ###\n\nDue to limited precision of `Float64` type, extraction of roots of polynomials\ncan give inaccurate results, even for low-order polynomials.  This is caused,\ni.e., by\n[catastrophic cancellation](https://en.wikipedia.org/wiki/Loss_of_significance)\nin computation of discriminant D = sqrt(b^2 - 4ac) of second-order polynomials.\n[For example](http://www.cs.berkeley.edu/~wkahan/Qdrtcs.pdf), the actual roots\nof\n\n```\n94906265.625*x^2 - 189812534*x + 94906268.375\n```\n\nare\n\n```\nx_1 = 1.000000028975958\nx_2 = 1.000000000000000\n```\n\nbut when you try to calculate them in double-precision you get\n\n``` julia\njulia> r = roots([94906268.375, -189812534, 94906265.625]);\n\njulia> r[1]\n1.0000000144879793 - 0.0im\n\njulia> r[2]\n1.0000000144879788 + 0.0im\n```\n\nIf you are interested in double-precision accuracy, you can work around this\nproblem by calculating the roots with higher precision and then transforming the\nresult to double-precision.  Julia natively supports multiple precision\ncalculations, so what you have to do is only to pass `BigFloat` numbers to\n`roots` function:\n\n``` julia\njulia> r = roots([BigFloat(94906268.375), BigFloat(-189812534), BigFloat(94906265.625)]);\n\njulia> Float64(r[1])\n1.0000000289759583\n\njulia> Float64(r[2])\n1.0\n```\n\nNote that in this case there is a trade-off between speed and higher accuracy\nand precision.\n\nRelated projects\n----------------\n\nAnother Julia package for finding roots of complex polynomials is\n[`Polynomials.jl`](https://github.com/Keno/Polynomials.jl), by Jameson Nash and\nother contributors.  This package does much more than finding roots of\npolynomials (among other features, it can integrate and differentiate\npolynomials).  In order to solve the polynomial, `Polynomials.jl` calculates\neigenvalues of its companion matrix, but `PolynomialRoots.jl` is usually faster\nby up to an order of magnitude and often slightly more precise.  In addition,\n`Polynomials` cannot extract roots in arbitrary precision.  If you are after\nspeed and precision, `PolynomialRoots.jl` can still be a better option.\n\nHow can I help?\n---------------\n\nFeel free to report bugs and sugges improvements at\nhttps://github.com/giordano/PolynomialRoots.jl/issues.  You can also implement\nother (possibly faster and/or more precise in more cases) root finding\nalgorithms and send a pull request at\nhttps://github.com/giordano/PolynomialRoots.jl/pulls.\n\nLicense\n-------\n\nThe `PolynomialRoots.jl` package is licensed under version 2.0 of the Apache\nLicense or the GNU Lesser General Public License version 3 or any later version,\nas well as under a \"customary scientific license\", which implies that if this\ncode was important in the scientific process or for the results of your\nscientific work, you are asked for the appropriate citation of the paper Skowron\n& Gould 2012 (http://arxiv.org/abs/1203.1034).  These are the same licenses used\nby the General Complex Polynomial Root Solver.\n\nThe authors of original Fortran library\n(http://www.astrouw.edu.pl/~jskowron/cmplx_roots_sg/) from which\n`PolynomialRoots.jl` has been translated are Jan Skowron, Andrew Gould.\n\nThe original author of `PolynomialRoots.jl` is Mose Giordano.\n", 
  "id": 56921877
}
{
  "read_at": 1462543147, 
  "description": "Fast maximum-minimum filters implemented in C++", 
  "README.md": "Fast running maximum-minimum filters implemented in C++.\r\n========================================================== \r\n[![Build Status](https://travis-ci.org/lemire/runningmaxmin.png)](https://travis-ci.org/lemire/runningmaxmin)\r\n\r\nThis code implements the algorithms described in the following paper:\r\n\r\nDaniel Lemire, Streaming Maximum-Minimum Filter Using No More than \r\nThree Comparisons per Element. Nordic Journal of Computing, 13 (4), pages 328-339, 2006. \r\n\r\nA preprint is available there:\r\n\r\nhttp://arxiv.org/abs/cs.DS/0610046\r\n\r\n\r\nContributors: Daniel Lemire, Kai Wolf\r\n\r\nUsage\r\n----- \r\n\r\nTo reproduce the numbers from the paper, do the following:\r\n\r\n  make\r\n  \r\n  ./unit\r\n  \r\n  ./runningmaxmin --sine 1000000 10000 --windowrange 4 100  --times 1\r\n  \r\n  ./runningmaxmin --white 1000000 --windowrange 4 100  --times 1\r\n\r\nSuitability \r\n------------\r\n\r\nThe new algorithm introduced in the manuscript is most suitable for piecewise monotonic\r\ndata or when low-latency is required. Otherwise, Gil-Kimmel and van Herk\r\nare good choices.\r\n\r\nSee also\r\n---------\r\n\r\nFor an application of this idea to rolling statistics in JavaScript, see\r\n\r\nhttps://github.com/shimondoodkin/efficient-rolling-stats\r\n\r\nFor an application in Go, please see \r\n\r\nhttps://github.com/notnot/movingminmax\r\n", 
  "id": 17032463
}
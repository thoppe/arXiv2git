{
  "README": "scallop\n\nCopyright 2012, 2013, 2014 by Alden Walker\n\nReleased under the GPL.\n\nSee INSTALL for installation instructions.\n\n\n******* Background\n\nscallop computes with surfaces in free groups and free products of\ncyclic groups.  The appropriate background material is contained \nin [1] (for the -local mode), [2] (for -train), and [3] (for -cyclic and -ball) \n\nThe original version of scallop was written by Danny Calegari, implementing \nthe algorithm described in [1], Chapter 4 to compute scl in free groups.  \nThe current version is a conglomeration of packages written by Alden Walker \nimplementing pieces of [1], [2], and [3], all using the basic principle that \nsurface maps into free groups factor through fatgraph maps, and we can \nusually produce these via linear programming.\n\n\n\n******** Installation\n\nSee the INSTALL file\n\n\n\n******** Executing scallop\n\nscallop is run by choosing one of four main modes, and then \nproviding more mode-specific arguments:\n\n./scallop [-cyclic, -ball, -local, -train] <mode-specific arguments>\n\nIt is not necessary to explicitly give a mode, in which case \nscallop will default to the original scallop algorithm for free \ngroups, which is equivalent to the options -local -pn, where n is 2*rank.\n\nWe discuss the four modes separately.  In all cases, giving no \noption-specific arguments will cause scallop to output a list of \npossible options and descriptions.  In an effort \nto produce a timeless document, we'll only discuss the options that \nare non-obvious or particularly important.  \n\nIn all modes, the option -v[n] is available, which gives verbose debug \ninformation.  The optional integer n says how much: default output (1), \nverbose output (2), really verbose (3), and so verbose you probably don't \nwant it (4).\n\n  *** A note on speed\n  \n  Scallop defaults to the nonrigorous original scallop algorithm because \n  for small rank it is much faster than the rigorous -cyclic.  At \n  rank approximately 3 or 4, -cyclic becomes faster.  Asymptotically, \n  -cyclic is polynomial time in the length, rank, and \n  orders of the finite factors.\n  \n  Gurobi is significantly faster than GLPK, so if possible, it's \n  worthwhile getting the free academic license.\n\n\n  ****** default (no mode specified) \n  \n  ./scallop chain \n  \n  Example:\n  \n  $ ./scallop abAB\n  scl( abAB ) = 1/2 = 0.5\n  \n  $ ./scallop AbaaBAAABabAAbAAABBBBaaababbabaBaabbABBA\n  scl( AbaaBAAABabAAbAAABBBBaaababbabaBaabbABBA ) = 245/146 = 1.67808\n  \n  With no mode specified, scallop defaults to -local, and the default \n  -local behavior is to compute in a free group with the maximum fatgraph \n  valence set to 2*rank.  This is nonrigorous (but generically correct, and \n  experimentally accurate with probability more than 0.95 for words of \n  length up through 100ish ).  In some cases, this mode can fail:\n  \n  $ ./scallop abAAABBB aa bb\n  No feasible solution found\n  \n  This is because a fatgraph bounding this chain must have valance at least 5.  \n  If the default mode fails, simply run scallop in -cyclic mode to get a rigorous \n  answer:\n  \n  $./scallop -cyclic abAAABBB aa bb\n  scl_{a*b}( 1abAAABBB 1aa 1bb ) = 3/4 = 0.75 \n \n\n  ****** -cyclic\n  \n  ./scallop -cyclic [options] [group] chain\n  \n  Examples: \n  \n  $ ./scallop -cyclic a0b0 abAB\n  scl_{a*b}( 1abAB ) = 1/2 = 0.5\n  \n  $ ./scallop -cyclic a0b0 abAAABBB aa bb\n  scl_{a*b}( 1abAAABBB 1aa 1bb ) = 3/4 = 0.75\n  \n  $ ./scallop -cyclic a3b2 ab\n  scl_{(a/3a)*(b/2b)}( 1ab ) = 1/12 = 0.0833333\n  \n  $ ./scallop -cyclic -mGUROBI a10b7 ab\n  scl_{(a/10a)*(b/7b)}( 1ab ) = 53/140 = 0.378571\n  \n  $ ./scallop -cyclic -C a0b0 abAABB ab\n  cl_{a*b}(1abAABB 1ab ) = 1 = 1\n  \n  $ ./scallop -cyclic -C a0b0c0 abcAABBCC abc\n  cl_{a*b*c}(1abcAABBCC 1abc ) = 2 = 2\n  \n  The -cyclic mode computes scl and cl in free products of cyclic groups.  \n  The group string lists the generators and their orders (0 means infinite).  \n  The option -C causes scallop to compute commutator length.  This involves \n  an integer programming problem, which is far harder than the linear programming \n  problem used to compute scl.  \n  The option -m[solver] lets the user choose GLPK (default), GUROBI (if compiled \n  with support), or EXLP (only available for free groups).  EXLP uses GMP for \n  exact solutions.   \n  \n  ****** -ball\n  \n  ./scallop -ball [options] filename [group] chain1 , chain2\n  \n  Examples:\n  \n  $ ./scallop -ball test.eps abAB , abAABB ab\n  Drew ball to file\n  \n  $ ./scallop -ball -mGUROBI test.eps a5b3 abAB , abAABB ab\n  Drew ball to file\n  \n  The -ball mode computes the scl norm ball in the subspace of B_1^H spanned \n  by the given chains.  It defaults to using -mEXLP as the solver to avoid \n  rounding errors.  However, to compute a ball in a group with finite cyclic \n  factors, the user must specify -mGLPK or -mGUROBI.  scallop will \n  write an eps file to whatever filename is specified.\n  \n  Theoretically, the algorithm can produce the ball in any dimension and \n  output the result as a polyhedron in CDD format (see http://www.inf.ethz.ch/personal/fukudak/cdd_home/).\n  However, CDD output is not currently implemented, so the only \n  possibility is a 2d ball output to an eps file.\n  \n  Make sure to include the output file name!  Omitting it will \n  almost certainly cause scallop to crash (it will assume the first word in \n  the chain is the output file name, which will probably render the rest \n  not homologically trivial.  Also, the commas are necessary!\n  \n  \n  \n  ****** -local\n  \n  ./scallop -local [options] chain\n  \n  Examples:\n  \n  $ ./scallop -local abAAABBB aa bb\n  scl = 3/4 = 0.75\n  \n  $ ./scallop -local -f abAAABBB aa bb\n  No feasible solution found\n  \n  $ ./scallop -local -p4 abAB\n  scl = 1/2 = 0.5\n  \n  $ ./scallop -local -p4 -e abAB\n  Feasible solution found\n  \n  $ ./scallop -local -p4 abcdABCD\n  No feasible solution found\n  \n  $ ./scallop -local -p8 abcdABCD\n  scl = 3/2 = 1.5\n  \n  $ ./scallop -local -ff1 abAB baBA a.ab.bAABB\n  scl = 1/2 = 0.5\n  \n  $ ./scallop -local -ff1 abAB a.ab.bAABB\n  No feasible solution found\n  \n  The -local option searchs for fatgraphs in a free group bounding the chain \n  which have the desired local properties.  The typical options are:\n  -f requires that the result be Stallings folded\n  -e only checks whether the surface exists, but does not find it (this is faster)\n     (this is accomplished by optimizing the function 0 rather than -chi)\n  -pn only searches for fatgraphs whose valence is at most n\n  -ffn only searches for surfaces whose f-vertices are isolated (see [2]) and \n       partial^- doesn't touch itself, where n is the number of words in \n       partial^-, and the f-vertices in the rest are marked with periods, \n       as indicated above.\n  -v[n]: verbose output (level n)\n\t-y: check if the chain is polygonal (overrides -f,-ff,-p)\n       \n\n  \n  \n  ****** -train\n  \n  ./scallop -train [-sup, -scl] length chain\n  \n  Examples:\n  \n  $ ./scallop -train 3 abAABB ab\n  scl( abA bAA AAB ABB BBa Bab aba bab ) = 1/2 = 0.5\n  \n  $ ./scallop -train -sup 3 abAABB ab\n  sup_{Q_3} phi(C)/2D(phi) = inf_t(w + tE) = (t->1/3); 1/2 = 0.5\n\n  $ ./scallop -train 4 abAABB ab\n  scl( abAA bAAB AABB ABBa BBab BabA abab baba ) = 2/3 = 0.666667  \n  \n  $ ./scallop -train -sup -mGUROBI 4 abAABB ab\n  sup_{Q_4} phi(C)/2D(phi) = inf_t(w + tE) = (t->523/5529); 2/3 = 0.666667\n\n  $ ./scallop -train  -mGUROBI 4 abAAABBB aa bb\n  scl( abAA bAAA AAAB AABB ABBB BBBa BBab BabA 2aaaa 2bbbb ) = 3/4 = 0.75\n  \n  $ ./scallop -train -sup -mGUROBI 4 abAAABBB aa bb\n  sup_{Q_4} phi(C)/2D(phi) = inf_t(w + tE) = (t->35319/1304); 2/3 = 0.666667\n  \n  The -train mode computes with traintracks (see [2]).  If the length \n  specified is n, then it finds a minimal surface bounding the set \n  of length n words contained in the given chain.  It can also find \n  the supremum of phi(C)/2D(phi) over all counting quasimorphisms phi, \n  by giving the -sup option.  This linear programming problem is significantly \n  larger.  Note that this can certify an extremal quasimorphism.\n  \n  The -train mode has several other technical options for finding surfaces \n  that bound w - phi(w) for a collection of words w and counting quasi phi.  \n  These ideas are discussed in [2].\n\n  \n\n******** TODO / Troubleshooting\n\nThere are several pieces of scallop that aren't implemented.  A user \nencountering these issues *should* find that scallop explains itself and \nthen exits, but it is possible that scallop will simply crash.\n\nMake sure the options are correctly specified!  Often, a missing option \nwill cause scallop to misinterpret what the chain is, which usually \ncauses it to crash.\n\nMissing pieces:\n1) -cyclic should have the capability to output a fatgraph file \n2) -ball should be able to output an arbitrary dimensional ball\n3) -ball should be able to write an eps or povray file for a 3d ball\n\n\n\n******** References\n\n[1] D. Calegari. scl. MSJ Memoirs, 20. Mathematical Society of Japan, Tokyo, 2009.\n\n[2] D. Calegari and A. Walker. Surface subgroups from Linear programming. preprint: arXiv:1212.2618\n\n[3] A. Walker, Stable commutator length in free products of cyclic groups, Experimental Math 22 (2013), no. 3, 282-298.\n", 
  "read_at": 1462551351, 
  "description": "Stable commutator length computer", 
  "id": 7415154
}
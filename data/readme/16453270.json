{
  "README": "This is a public-domain implementation of several rANS variants. rANS is an\nentropy coder from the ANS family, as described in Jarek Duda's paper\n\"Asymmetric numeral systems\" (http://arxiv.org/abs/1311.2540).\n\n- \"rans_byte.h\" has a byte-aligned rANS encoder/decoder and some comments on\n  how to use it. This implementation should work on all 32-bit architectures.\n  \"main.cpp\" is an example program that shows how to use it.\n- \"rans64.h\" is a 64-bit version that emits entire 32-bit words at a time. It\n  is (usually) a good deal faster than rans_byte on 64-bit architectures, and\n  also makes for a very precise arithmetic coder (i.e. it gets quite close\n  to entropy). The trade-off is that this version will be slower on 32-bit\n  machines, and the output bitstream is not endian-neutral. \"main64.cpp\" is\n  the corresponding example.\n- \"rans_word_sse41.h\" has a SIMD decoder (SSE 4.1 to be precise) that does IO\n  in units of 16-bit words. It has less precision than either rans_byte or\n  rans64 (meaning that it doesn't get as close to entropy) and requires\n  at least 4 independent streams of data to be useful; however, it is also a\n  good deal faster. \"main_simd.cpp\" shows how to use it.\n\nSee my blog http://fgiesen.wordpress.com/ for some notes on the design.\n\nI've also written a paper on interleaving output streams from multiple entropy\ncoders:\n\n  http://arxiv.org/abs/1402.3392\n\nthis documents the underlying design for \"rans_word_sse41\", and also shows how\nthe same approach generalizes to e.g. GPU implementations, provided there are\nenough independent contexts coded at the same time to fill up a warp/wavefront\nor whatever your favorite GPU's terminology for its native SIMD width is.\n\nFinally, there's also \"main_alias.cpp\", which shows how to combine rANS with\nthe alias method to get O(1) symbol lookup with table size proportional to the\nnumber of symbols. I presented an overview of the underlying idea here:\n\n  http://fgiesen.wordpress.com/2014/02/18/rans-with-static-probability-distributions/\n\nResults on my machine (Sandy Bridge i7-2600K) with rans_byte in 64-bit mode:\n\n----\n\nrANS encode:\n12896496 clocks, 16.8 clocks/symbol (192.8MiB/s)\n12486912 clocks, 16.2 clocks/symbol (199.2MiB/s)\n12511975 clocks, 16.3 clocks/symbol (198.8MiB/s)\n12660765 clocks, 16.5 clocks/symbol (196.4MiB/s)\n12550285 clocks, 16.3 clocks/symbol (198.2MiB/s)\nrANS: 435113 bytes\n17023550 clocks, 22.1 clocks/symbol (146.1MiB/s)\n18081509 clocks, 23.5 clocks/symbol (137.5MiB/s)\n16901632 clocks, 22.0 clocks/symbol (147.1MiB/s)\n17166188 clocks, 22.3 clocks/symbol (144.9MiB/s)\n17235859 clocks, 22.4 clocks/symbol (144.3MiB/s)\ndecode ok!\n\ninterleaved rANS encode:\n9618004 clocks, 12.5 clocks/symbol (258.6MiB/s)\n9488277 clocks, 12.3 clocks/symbol (262.1MiB/s)\n9460194 clocks, 12.3 clocks/symbol (262.9MiB/s)\n9582025 clocks, 12.5 clocks/symbol (259.5MiB/s)\n9332017 clocks, 12.1 clocks/symbol (266.5MiB/s)\ninterleaved rANS: 435117 bytes\n10687601 clocks, 13.9 clocks/symbol (232.7MB/s)\n10637918 clocks, 13.8 clocks/symbol (233.8MB/s)\n10909652 clocks, 14.2 clocks/symbol (227.9MB/s)\n10947637 clocks, 14.2 clocks/symbol (227.2MB/s)\n10529464 clocks, 13.7 clocks/symbol (236.2MB/s)\ndecode ok!\n\n----\n\nAnd here's rans64 in 64-bit mode:\n\n----\n\nrANS encode:\n10256075 clocks, 13.3 clocks/symbol (242.3MiB/s)\n10620132 clocks, 13.8 clocks/symbol (234.1MiB/s)\n10043080 clocks, 13.1 clocks/symbol (247.6MiB/s)\n9878205 clocks, 12.8 clocks/symbol (251.8MiB/s)\n10122645 clocks, 13.2 clocks/symbol (245.7MiB/s)\nrANS: 435116 bytes\n14244155 clocks, 18.5 clocks/symbol (174.6MiB/s)\n15072524 clocks, 19.6 clocks/symbol (165.0MiB/s)\n14787604 clocks, 19.2 clocks/symbol (168.2MiB/s)\n14736556 clocks, 19.2 clocks/symbol (168.8MiB/s)\n14686129 clocks, 19.1 clocks/symbol (169.3MiB/s)\ndecode ok!\n\ninterleaved rANS encode:\n7691159 clocks, 10.0 clocks/symbol (323.3MiB/s)\n7182692 clocks, 9.3 clocks/symbol (346.2MiB/s)\n7060804 clocks, 9.2 clocks/symbol (352.2MiB/s)\n6949201 clocks, 9.0 clocks/symbol (357.9MiB/s)\n6876415 clocks, 8.9 clocks/symbol (361.6MiB/s)\ninterleaved rANS: 435120 bytes\n8133574 clocks, 10.6 clocks/symbol (305.7MB/s)\n8631618 clocks, 11.2 clocks/symbol (288.1MB/s)\n8643790 clocks, 11.2 clocks/symbol (287.7MB/s)\n8449364 clocks, 11.0 clocks/symbol (294.3MB/s)\n8331444 clocks, 10.8 clocks/symbol (298.5MB/s)\ndecode ok!\n\n----\n\nFinally, here's the rans_word_sse41 decoder on an 8-way interleaved stream:\n\n----\n\nSIMD rANS: 435626 bytes\n4597641 clocks, 6.0 clocks/symbol (540.8MB/s)\n4514356 clocks, 5.9 clocks/symbol (550.8MB/s)\n4780918 clocks, 6.2 clocks/symbol (520.1MB/s)\n4532913 clocks, 5.9 clocks/symbol (548.5MB/s)\n4554527 clocks, 5.9 clocks/symbol (545.9MB/s)\ndecode ok!\n\n----\n\nThere's also an experimental 16-way interleaved AVX2 version that hits\nfaster rates still, developed by my colleague Won Chun; I will post it\nsoon.\n\nNote that this is running \"book1\" which is a relatively short test, and\nthe measurement setup is not great, so take the results with a grain\nof salt.\n\n-Fabian \"ryg\" Giesen, Feb 2014.\n", 
  "read_at": 1462543172, 
  "description": "Simple rANS encoder/decoder (arithmetic coding-ish entropy coder).", 
  "id": 16453270
}
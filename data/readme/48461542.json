{
  "read_at": 1462550338, 
  "description": "lightFM package by Lyst", 
  "README.md": "# LightFM\n\n![LightFM logo](lightfm.png)\n\n[![Circle CI](https://circleci.com/gh/lyst/lightfm.svg?style=svg)](https://circleci.com/gh/lyst/lightfm)\n\nA Python implementation of LightFM, a hybrid recommendation algorithm.\n\nThe LightFM model incorporates both item and user metadata into the traditional matrix factorization algorithm. It represents each user and item as the sum of the latent representations of their features, thus allowing recommendations to generalise to new items (via item features) and to new users (via user features).\n\nThe details of the approach are described in the LightFM paper, available on [arXiv](http://arxiv.org/abs/1507.08439).\n\nThe model can be trained using four methods:\n\n- logistic loss: useful when both positive (1) and negative (-1) interactions\n                 are present.\n- BPR: Bayesian Personalised Ranking [1] pairwise loss. Maximises the\n       prediction difference between a positive example and a randomly\n       chosen negative example. Useful when only positive interactions\n       are present and optimising ROC AUC is desired.\n- WARP: Weighted Approximate-Rank Pairwise [2] loss. Maximises\n        the rank of positive examples by repeatedly sampling negative\n        examples until a rank violating one is found. Useful when only\n        positive interactions are present and optimising the top of\n        the recommendation list (precision@k) is desired.\n- k-OS WARP: k-th order statistic loss [3]. A modification of WARP that uses the k-th\n             positive example for any given user as a basis for pairwise updates.\n\nTwo learning rate schedules are implemented:\n- adagrad: [4]\n- adadelta: [5]\n\n## Installation\nInstall from pypi using pip: `pip install lightfm`.\n\nNote for OSX users: due to its use of OpenMP, `lightfm` does not compile under Clang. To install it, you will need a reasonably recent version of `gcc` (from Homebrew for instance). This should be picked up by `setup.py`; if it is not, please open an issue.\n\nBuilding with the default Python distribution included in OSX is also not supported; please try the version from Homebrew or Anaconda.\n\n## Usage\nModel fitting is very straightforward.\n\nCreate a model instance with the desired latent dimensionality\n```python\nfrom lightfm import LightFM\n\nmodel = LightFM(no_components=30)\n```\n\nAssuming `train` is a (no_users, no_items) sparse matrix (with 1s denoting positive, and -1s negative interactions), you can fit a traditional matrix factorization model by calling\n```python\nmodel.fit(train, epochs=20)\n```\nThis will train a traditional MF model, as no user or item features have been supplied.\n\nTo get predictions, call `model.predict`:\n```python\npredictions = model.predict(test_user_ids, test_item_ids)\n```\n\nUser and item features can be incorporated into training by passing them into the `fit` method. Assuming `user_features` is a (no_users, no_user_features) sparse matrix (and similarly for `item_features`), you can call\n```python\nmodel.fit(train,\n          user_features=user_features,\n          item_features=item_features,\n          epochs=20)\npredictions = model.predict(test_user_ids,\n                            test_item_ids,\n                            user_features=user_features,\n                            item_features=item_features)\n```\nto train the model and obtain predictions.\n\nBoth training and prediction can employ multiple cores for speed:\n```python\nmodel.fit(train, epochs=20, num_threads=4)\npredictions = model.predict(test_user_ids, test_item_ids, num_threads=4)\n```\n\nThis implementation uses asynchronous stochastic gradient descent [6] for training. This can lead to lower accuracy when the interaction matrix (or the feature matrices) are very dense and a large number of threads is used. In practice, however, training on a sparse dataset with 20 threads does not lead to a measurable loss of accuracy.\n\nIn an implicit feedback setting, the BPR, WARP, or k-OS WARP loss functions can be used. If `train` is a sparse matrix with positive entries representing positive interactions, the model can be trained as follows:\n```python\nmodel = LightFM(no_components=30, loss='warp')\nmodel.fit(train, epochs=20)\n```\n\n## Examples\n\nCheck the `examples` directory for more examples.\n\nThe [Movielens example](/examples/movielens/example.ipynb) shows how to use `lightfm` on the Movielens dataset, both with and without using movie metadata. [Another example](/examples/movielens/learning_schedules.ipynb) compares the performance of the adagrad and adadelta learning schedules.\n\nThe [Cross Validated example](/examples/crossvalidated/example.ipynb) shows how to use `lightfm` on a dataset from [stats.stackexchange.com](http://stats.stackexchange.com) with both item and user features.\n\nThe [Kaggle coupon purchase prediction](https://github.com/tdeboissiere/Kaggle/blob/master/Ponpare/ponpare_lightfm.ipynb) example applies LightFM to predicting coupon purchases.\n\n## Development\nPull requests are welcome. To install for development:\n\n1. Clone the repository: `git clone git@github.com:lyst/lightfm.git`\n2. Install it for development using pip: `cd lightfm && pip install -e .`\n3. You can run tests by running `python setupy.py test`.\n\nWhen making changes to the `.pyx` extension files, you'll need to run `python setup.py cythonize` in order to produce the extension `.c` files before running `pip install -e .`.\n\n## References\n[1] Rendle, Steffen, et al. \"BPR: Bayesian personalized ranking from implicit feedback.\"\nProceedings of the Twenty-Fifth Conference on Uncertainty in Artificial\nIntelligence. AUAI Press, 2009.\n\n[2] Weston, Jason, Samy Bengio, and Nicolas Usunier. \"Wsabie: Scaling up to large\nvocabulary image annotation.\" IJCAI. Vol. 11. 2011.\n\n[3] Weston, Jason, Hector Yee, and Ron J. Weiss. \"Learning to rank recommendations with\nthe k-order statistic loss.\" Proceedings of the 7th ACM conference on Recommender systems. ACM, 2013.\n\n[4] Duchi, John, Elad Hazan, and Yoram Singer. \"Adaptive subgradient methods\nfor online learning and stochastic optimization.\" The Journal of Machine Learning Research 12 (2011): 2121-2159.\n\n[5] Zeiler, Matthew D. \"ADADELTA: An adaptive learning rate method.\"\narXiv preprint arXiv:1212.5701 (2012).\n\n[6] Recht, Benjamin, et al. \"Hogwild: A lock-free approach to parallelizing stochastic gradient descent.\" Advances in Neural Information Processing Systems. 2011.", 
  "id": 48461542
}
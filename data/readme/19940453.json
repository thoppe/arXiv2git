{
  "read_at": 1462546789, 
  "description": "Discrete Exterior Calculus", 
  "README.md": "Kahler is a discrete exterior calculus framework for Hermitian manifolds.\n\nPlease refer to http://arxiv.org/abs/1405.7879 for a full description.\n\n#Meshes\n\nKahler provides three ways of triangulating an N dimensional cube:\n* Symmetric Grid\n* Asymmetric Grid\n* Random Mesh\n\n##Symmetric and Asymmetric Grids\n\nThe symmetric and asymmetric grid results in a mesh documented at http://arxiv.org/abs/1405.7879.\n\nTo create a(n) (a)symmetric, you will first need to create a dictionary of grid indices.\nThis is a dictionary that maps a set of coordinate indices (grid indices) to the index of the corresponding vertex (vertex indices).\nFor example, the origin's grid index would be (0,0,...,0), and might be mapped to the first vertex, vertex 0.\nOne step in the Nth direction would yeild a grid index of (0,0,...,1).\nThis might be mapped to vertex 1, and so on.\n\nUse kahler.grid_indices([M1, M2,..., MN]) to create a dictionary of grid indices for an M1xM2x...xMN grid.\n\n**Example**\n```python\nimport kahler\nshape = [4,5,3]\ngrid_indices = kahler.grid_indices(shape)\n```\n\nThe space can now be divided into simplices using the symmetric or asymmetric grid functions (kahler.symmetric_grid and kahler.grid respectively).\nIn the above example, a 4x5x3 grid is used.\n\n**Example**\n```python\nsymmetric_grid_simplices = kahler.grid(grid_indices)\nasymmetric_grid_simplices = kahler.asymmetric_grid(grid_indices)\n```\n\nBoth functions return a 2D numpy array of simplices. Each row is a list of vertex indices that forms a simplex.\n\n\n##Random Meshes\n\nRandom meshes are created without grid indices.\nInstead, kahler's random\\_mesh function takes the number of points on the interior of the mesh and the dimension of the mesh as arguements.\n\n**Example**\n```python\nvertices, stitches = kahler.random_mesh(150, 3)\n```\n\nIn the above example, the mesh will be 3 dimensional and have have 150 points on its interior. vertices is a 2D numpy array of coordinates.\nThe ith row gives the coordinates of the ith vertex. In the above usage, stitches will be an empty python dictionary.\nrandom_mesh can take a third argument for imposing periodic boundary conditions.\nThis will result in stitches becomming a nonempty dictionary and will be discussed in the next section.\n\nrandom\\_mesh can also take a keyword (or fourth argument), alpha. This parameter determines how close the points can be to each other. Statistically speaking, the points would be an average distance of N ^ (1 / dim) apart, wtih N being the number of points on the interior and dim being the dimension of the complex. random_mesh will ensure the points are no closer than alpha * N ^ (1 / dim) apart. alpha is set to 0.5 by default. Increasing alpha will increase the time it takes to randomly generate a suitable set of points.\n\n#Customizing Topology\n\nGiven a triangulated N dimensional cube, it possible to create any desired topology by gluing or \"stitching\" vertices together.\nWhen using kahler, these \"stitches\" are stored as a dictionary that maps vertex indices to the corresponding vertex indices they should be stitched to.\nTo create a torus for periodic boundary conditions, points on opposite sides of the grid are stitched together.\nKahler comes with a function called pbc_stitches that creates the stitches necessary to impose periodic boundary conditions in any combination of directions.\n\n**Example**\n```python\nstitches = kahler.pbc_stitches(grid_indices, shape, [0, 2])\n```\n\nThe third argument is a list of (zero indexed) directions that should be periodic.\nIn the above example, the first and third directions are to be periodic. For random meshes, this list of directions is specified as a third argument.\n\n**Example**\n```python\nvertices, stitches = kahler.random_mesh(150, 3, [0, 2])\n```\n\n#Embedding the Vertices\n\nThe next step is choosing a coordinate system to embed the vertices.\n\n##Symmetric and Asymmetric Grids\nThe embed function is used to create a list of coordinates from grid indices.\n\n**Example**\n```python\nfrom numpy import linspace\ncoordinates = [linspace(0,1,s) for s in shape]\nvertices = kahler.embed(grid_indices, coordinates)\n```\n\nHere, coordinates are the coordinates of each N-1 dimensional hyperplane that discretizes your N dimensional cubic space. For example, say\n\n```python\nshape=[2, 3, 2]\n```\n\nA uniform mesh on the unit cube is generated with the following hyperplane coordinates:\n\n```python\n[\n [0, 1],\n [0, 0.5, 1],\n [0, 1]\n]\n```\n\nThis means that the x-axis is discretized with following coordinates:\nx=0, x=1\nThe y-axis is discretized with the following coordinates:\ny=0, y=0.5, y=1\nThe z-axis is discretized with the following coordinates:\nz=0, z=1\n\nSay there is more interesting phenomina near y=1. Then one might choose to use a nonuniform mesh with the following coordinates:\n\n```python\n[\n [0, 1],\n [0, 0.8, 1],\n [0, 1]\n]\n```\n\n##Random Meshes\nRandom meshes automatically embed vertices on the unit N-cube. The coordinates of these vertices are returned as shown below:\n\n```python\nvertices, stitches = kahler.random_mesh(150, 3, [0,2])\n```\n\n#Creating a Simplicial Complex\n\nSimplicial complexes are created with the SimplicialComplex class. It can be initialized as follows:\n\n```python\nsc = kahler.SimplicialComplex(simplices, vertices)\n```\n\nFor a customized topology, use\n\n```python\nsc = kahler.SimplicialComplex(simplices, vertices, stitches=stitches)\n```\n\n#Specifying a Metric\n\nBy default, the Euclidian metric is used.\nThe metric is a function that takes the coordinates of a point and returns the cooresponding Hermitian metric at that point in the form of a complex 2D numpy array.\nThe points and the resulting matrix should both be complex numpy arrays.\n\n**Example** (the metric for polar coordinates)\n\n```python\nfrom numpy import asarray\ndef g(pt):\n    r, theta = pt\n    m = asarray([\n                 [1, 0],\n                 [0, r ** 2]\n                ], dtype=\"complex\")\n    return m\n    \nsc = SimplicialComplex(simplices, vertices, stitches=stitches, metric=g)\n```\n\nA de Rham map is used to map the metric onto each p-simplex of the complex during various metric dependent calculations.\nSee http://arxiv.org/abs/1405.7879 for more on this process.\nIn general, the kahler's de Rham map uses a generalized trapeziodal rule.\nThe number of points sampled along each direction during this process is specified with the keyword, subdivisions.\nThe more subdivisions used, the more accurate the de Rham map will be. By default, subdivisions=1.\nThis means that only the corners of the simplices will be sampled.\nThe number of subdivisions used when mapping the metric onto each simplex can be changed with the subdivisions keyword.\n\n```python\nsc = SimplicialComplex(simplices, vertices, stitches=stitches, metric=g, subdivisions=10)\n```\n\n#Cohomological Operators\n\nSimplicial complexes are really a list of p-skeletons. Each p-skeleton computes and stores information related to the p-skeleton (set of p-simplicies) of the simplicial complex.\nThese properties are computed as needed--an idea borrowed from PyDEC.\nThe following properties are generally of the most interest:\n\n* exterior_derivative\n* star\n* inverse_star\n* codifferential\n* laplace_beltrami = codifferential dot exterior_derivative\n* laplace_derham = laplace_beltrami + exterior_derivative dot codifferential\n\nAll operators are stored as a sparse csr_matrix (see scipy docs).\nDue to convention, the codifferential acting on p-forms is multiplied by a factor of (-1) ** p.\nThis means that physical simulations generally use the following operator:\n\n```python\n(-1) ** (p + 1) * laplace_beltrami\n```\n\nFor example, p=0 represents scalar fields, so the laplacian for scalar fields is given by:\n\n```python\nL_scalar = -sc[0].laplace_beltrami\n```\n\nThe laplacian for vector fields is then given by:\n\n```python\nL_vector = sc[1].laplace_beltrami\n```\n\nAnd so on.\n\n#Sharpening a Differential Form\n\nEach p-skeleton has a method called sharpen that can be used to turn a differential p-form into a antisymmetric p-rank tensor field.\nGiven a p-form (stored as a one dimensional numpy array of coefficients of p-simplices), one can use sharpen as follows:\n\n```python\ntensor_field = sc[p].sharpen(p_form)\n```\n\nEach tensor in the tensor field is located at the barycenter of a corresponding N-simplex.\n\n#Visualizing Fields\n\nKahler comes with two tools to visualize 2D fields. Tools for animating 2D fields to visualize 3D ones may come soon.\nTo visualize scalar fields, use the scalar_field2d function. This returns a matplotlib image of the field interpolated.\n\n**Example**\n```python\nfrom matplotlib.pylab import show \n\nbarycenters = sc[2].points.mean(1)\nscalar_field = sc[0].sharpen(form)\n\nkahler.scalar_field2d(barycenters, scalar_field, 1000)\nshow()\n```\n\nThis will interpolate the scalar field over a 1000x1000 grid.\n\nSimilarly, one can use vector_field2d to visualize a vector field.\n\n**Example**\n```python\nfrom matplotlib.pylab import show \n\nbarycenters = sc[2].points.mean(1)\nvector_field = sc[1].sharpen(form)\n\nkahler.vector_field2d(barycenters, vector_field, 20)\nshow()\n```\n", 
  "id": 19940453
}
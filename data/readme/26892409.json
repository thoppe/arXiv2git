{
  "read_at": 1462554049, 
  "description": "mySD - a high performance generic spin dynamics simulator", 
  "README.md": "# mySD - Spin Dynamics Simulator\n\n\n![alt tag](https://raw.githubusercontent.com/Eunsong/SpinDynamicsSimulator/master/examples/figures/mySD_sample.jpg)\n\n\n\n### Introduction\nClassical spin dynamics simulator code written in Java.\n\nThe project aims to provide a generic platform to run linear and nonlinear\nclassical spin dynamics simulaton of any system by solving Landau-Lifshitz-Gilbert equation:\n\n\n![alt tag](https://raw.githubusercontent.com/Eunsong/SpinDynamicsSimulator/master/examples/figures/LLGequation.png)\n\n\n(please refer to the following reference for more details : Eunsong Choi, Gia-Wei Chern, Natalia Perkins, Chiral magnetism and helimagnons in a pyrochlore antiferromagnet, Phys. Rev. B 87, 054418 (2013),\nor http://arxiv.org/pdf/1301.5958v1.pdf )\n\n\n### Usage (multi-threaded version)\n\nA simulation can be run by typing the following line in a Linux system:\n\n\n    java Run -nt [(optional)number of threads] -t [topology file] -s [run parameter file] -o [output file] -c [(optional)spin config file]\n\n\nNumber of threads need not be specified. Default vaule is the number of available processors in the system where the main program is executed.\nExample of topology file(.top), run parameter file(.sdp), and spin configuration file(.cnf) are in the example folder. Usage example can also be displayed by executing the code with *--help* (or *-h*) flag :\n\n\n    java Run --help \n\n\nRun code generates four different output files: simulation information file (.info), spin trajectory file (.trj), final spin configuration file (.cnf) and system energy file (.eng). Note that .eng file is not generated for linear type simulations. All these files use same common file name defined with -o flag. For instance, \"*-o out*\" will create: *out.info*, *out.trj*, *out.cnf*, and *out.eng*. Once simulation is done, spin-wave spectrum can be computed from output trajectory data(.trj file) using *ComputeSpinWave.java* code along with the .info file generated from the simulation. To do this, one can type in the following commands :\n\n    java ComputeSpinWave -i [input name(need .info and .trj)] -t [topology file] -nk [number of k-space grids] -kx [bx direction component] -ky [by component] -kz [bz component] -nw [number of frequency space grids] -dw [size of each frequency grid] -o [output name]\n\n\nSimilarly, usage example can be displayed with --help (or -h) flag :\n\n    java ComputeSpinWave --help\n\n\n\n\n### Before running the simulation \n\nTo run a simulation, you need a topology file (.top) and a run parameter file (.sdp). Topology file contains information that completely defines a sytem to be simulated. Run-parameter file, on the other hand, defines simulation specific parameters such as simulation length, simualtion type, output size, and etc. Optionally, a configuration file (.cnf) can be provided to overrides initial spin configurations. If .cnf file is not given, spin configurations defined in the .top file will be used. \n\nBelow are examples of .top file and .sdp file. File formats are mostly self-explanatory, but will be thoroughly explained in the tutorials section. Note that texts following # symbol are comments and not processed in the simulator code.\n\n\n#### topol.top\n    \n    [ basis ]\n    #number      x       y      z       (optional)Sx    Sy      Sz\n         0     0.0     0.0    0.0                0.0   0.0     1.0 \n\n\n    [ lattice_vector ]\n    #ax\n    1.0     0.0     0.0\n    #ay\n    0.0     1.0     0.0\n    #az\n    0.0     0.0     1.0\n\n\n    [ unit_cells ]\n    #nx     ny      nz\n    50      5      5\n\n\n    [ Hamiltonian ]\n    #type       a11     a12     a13     a21     a22     a23     a31     a32     a33\n    J1_FM      -1.0     0.0     0.0     0.0    -1.0     0.0     0.0     0.0    -1.0\n    J1_AFM      1.0     0.0     0.0     0.0     1.0     0.0     0.0     0.0     1.0\n\n\n    [ bonds ]\n    #a           b       HamiltonianType\n     0      <i+1>0       J1_FM\n     0      <j+1>0       J1_FM\n     0      <i-1>0       J1_FM\n     0      <j-1>0       J1_FM\n    \n\n\n\n#### sdrun.sdp\n    \n    # Spin Dynamics Simulation run parameters \n\n    title                   = SquareLattice_FerroMagnet\n\n    runtype                 = linear  #linear of nonlinear\n\n    dt                      = 0.02  #time step size\n    ntstep                  = 50000 #number of time steps\n    alpha                   = 0.02  #Gilbert damping constant\n\n    nstout                  = 5    #save outputs every nstout steps(0 to write only the final config)\n    nstbuff                 = 100  #output buffer size(can enable this option using BufferedBasicWriter)\n    nstenergy               = 0    #save total energy every nstenergy steps(only for nonlinear simulations) \n\n    perturb_site            = true #true to perturb a site at start\n    perturbing_site_index   = 0    #index of a site to be perturbed\n    perturbation_size       = 1    #linear case, this determines initial size of sigma_x,\n                                   #nonlinear case, this is a roatation angle(degree)\n\n\n\n\n\n\n### Linear vs Nonlinear \n\nThs code supports both linear and non-linear simulation. Just specify either linear of nonlinear in the sdp file. Typically, nonlinear simulation can be used to find ground state spin configurations with the aid of large damping constant alpha, and linear simulation can be used to obtain clean spin fluctuations in the vicinity of ground state.\n\n\n\n## Tutorials\n\nBelow are quick tutorials on how to use mySD package. All input files used in the tutorials can be found in */examples* folder. \n\n\n###1. Square Lattice Ferromagnet\n\nWe fisrt need to write a topology file for this system. In this case, we only need one sub-lattice. Let's say each sub-lattice is placed at 0.0, 0.0, 0.0 and all spins are initially aligned along z-axis. This can be expressed as :\n    \n    [ basis ]\n    #number      x       y      z       (optional)Sx    Sy      Sz\n         0     0.0     0.0    0.0                0.0   0.0     1.0 \n    \n\nThen, we define Lattice vectors: *ax*, *ay*, and *az*. Here, we will simply put lattice vectors along the lab coordinates :\n    \n    [ lattice_vector ]\n    #ax\n    1.0     0.0     0.0\n    #ay\n    0.0     1.0     0.0\n    #az\n    0.0     0.0     1.0\n\n\nThe actual system consists of repeated basis along the lattice vectors. In the *[ unit_cells ]* section, we specify number of repeated units along each lattice vectors. Let's say later we will compute spin-wave spectrum along *bx*(reciprocal lattice vector of *ax*). In order to achieve good resolution of spin-wave along the desired direction, we need to place more repeated unit cells along this direction. I decided to put 50 along *ax*, and 5 for the other directions. \n\n    [ unit_cells ]\n    #nx     ny      nz\n    50      5      5\n\n\nNow, we need to define a Hamiltonian. We first give a name to the Hamiltonian. In this case, we name it *J1_FM* meaning Ferro Magnetic interaction between nearest neighbors(though name is only used to look up matching interactions in the bonds section). Ferromagnetic Heigenberg interaction consists of negative diagonal components and zero off-diagonal components. So we can write it like this:\n\n\n    [ Hamiltonian ]\n    #type       a11     a12     a13     a21     a22     a23     a31     a32     a33\n    J1_FM      -1.0     0.0     0.0     0.0    -1.0     0.0     0.0     0.0    -1.0\n\n\n\nNote that an interaction matrix is defined as follows:\n\n![alt tag](https://raw.githubusercontent.com/Eunsong/SpinDynamicsSimulator/master/examples/figures/AMatrix.png)\n\nwhich then determines the Hamiltonian of the system:\n\n![alt tag](https://raw.githubusercontent.com/Eunsong/SpinDynamicsSimulator/master/examples/figures/HamiltonianExpression.png)\n\n\nFinally, we need to sepcify all the i-j bond pairs in the system. Note that i-j bond and j-i bond must both be explicitly defined in this section (this will not results in double counting.) This allows us more flexibility in defining pair-wise interactions. For inter-unitcell interactions, *i.e.* bonds that cross unit cell border, you can specify relative position of corresponding unitcell in anglular brackets. For instance, *\"0    < i+1 >1\"* indicates a bond between sub-lattice 0 at i, j, k-th unit cell and sub-lattice 1 at i+1, j, k-th unit cell. For square lattice, entire bonds can be defined as follows :\n\n    [ bonds ]\n    #a           b       HamiltonianType\n     0      <i+1>0       J1_FM\n     0      <j+1>0       J1_FM\n     0      <i-1>0       J1_FM\n     0      <j-1>0       J1_FM\n\nThis completes our topology file for simulating Ferromagnetic Square lattice. Put all the above in a file *topol.top*. \n\n\n\nWe now need to define simulation specific parameters. First, let's name our simulation. The name of the simulation will be printed in .info file when simulation is done. And most importantly, we need to decide what type of simulation will be carried out. Since constructing a ground state configuration for Ferromagnetic state is straight forward(and is properly configured in our topology file constructed above), we will skip the nonlinear simulation and do linear simulation right away. \n\n\n    title                   = SquareLattice_FerroMagnet\n    runtype                 = linear  #linear of nonlinear\n\n\nNext, we need to define size of each time step, number of time steps, and Gilbert damping constant. There is no unique optimum value for these parameters. They depend on your system size and interactions. Generally, I would suggest to start with time step size of 0.02 to 0.1, and ten to hundereds of thousands of time steps. For damping constant, something around 0.01 would work find for linear simulation to obtain spin-wave, and around 0.4-0.5 for nonlinear simulation for obtaining ground state configuration. \n\n\n    dt                      = 0.02  #time step size\n    ntstep                  = 50000 #number of time steps\n    alpha                   = 0.02  #Gilbert damping constant\n\n\nWe now define how often we will output trajectories and energies. Trajectory will be saved in .trj file evey *nstout* steps. If *nstout* is set to 0, then trajectory won't be saved, but you will still get a final configuration in .cnf file. Since writing trajectory to a file is one most slow part in the entire simulation keeping this value as large as possible is a good way to optimize performace. In particular, if *dt* is small enough, saving trajectory each time step is probably unnecessary unless there is a very high-frequency mode. Here, I decided to save trajectory every 5 time steps meaning trajectory will be saved every 0.1 time. *nstenergy* define how often system energy will be saved in .eng file. This has nothing to do with linear simulations so you can just leave whatever value you like(I put 0 to explicitly show that we won't compute energies). *nstbuff* can be ignored for current version. \n\n    nstout                  = 5    #save outputs every nstout steps(0 to write only the final config)\n    nstbuff                 = 100  #output buffer size(can enable this option using BufferedBasicWriter)\n    nstenergy               = 0    #save total energy every nstenergy steps(only for nonlinear simulations) \n\n\nFinally, since we start from a ground state configuration, in order to generate fluctuations, we must perturb a site. Set *perturb_site = true* will enable initlal perturbation. Location of the perturbation can be specified in *perturbing_site_index*, but generally you will never have to change this index. Amount of perturbation can be specified in *perturbation_size*. For linear simulations, this value simply determines initial spin deviation size. For nonlinear simulations, this value is a rotation degree(in angles) of a specified site from the initial configuration. \n\n    perturb_site            = true #true to perturb a site at start\n    perturbing_site_index   = 0    #index of a site to be perturbed\n    perturbation_size       = 1    #linear case, this determines initial size of sigma_x,\n                                   #nonlinear case, this is a roatation angle(degree)\n\n\nWe are done with the run parameters as well. Let's put them together in *sdrun.sdp* file. Or you can simply use example files in the */examples/squareFM* folder.  \n\n\nLet's first check what inputs must be given to run a simulation. Type the following in the command line to display instruction of *Run* code :\n\n    java Run --help\n\nThis will display required and optional inputs and appropriate flags to properly feed them to the code as follows.\n\n\n    #####################################################################\n    #                                                                   #\n    #  Run.java is an executable back-bone code of mysd package         #\n    # simulating classical spin dynamics on a periodic latice system.   #\n    # checkout the following github repository for most recent updates: #\n    # https://github.com/Eunsong/SpinDynamicsSimulator.git              #\n    #                                                                   #\n    # The code requires following inputs to run :                       #\n    #          1. -t   .top file defining system topology               #\n    #          2. -s   .sdp file listing simulation specific parameters #\n    #          3. -c   (optional) .cnf file for overloading initial     #\n    #                  spin configurations.                             #\n    #          4. -o   desired common file name for outputs             #\n    #                  (e.g. -o out will create out.info, out.trj,      #\n    #                   and out.eng)                                    #\n    #          5. -nt  (optional) number of threads to be used for      #\n    #                  the simulation. If not specified, number of      #\n    #                  currently available processors will be used.     #\n    #                                                                   #\n    # Usage example : java Run -t topology.top -s sdrun.sdp -c conf.cnf #\n    #                -nt 8 -o out                                       #\n    #                                                                   #\n    #####################################################################\n\n\nFor our system, we can type something like this (assuming you have already compiled the entire package),\n\n    java Run -t topol.top -s sdrun.sdp -o out\n\nThis will take roughly a minute or so depending on your computer and number of threads you use. In my computer, it took about 1m 10sec. Now, you will see three files are created in the same folder:\n\n    out.info\n    out.trj\n    out.cnf\n\n\nThe system information file, *out.info*, contains the simulation parameters and lattice sites that are used in the simulation. The trajectory file, *out.trj*, contains simply spin configurations recorded at specified intervals. The configuration file, *out.cnf*, is a final configuration(spin deviations for linear simulation), but is not much of use for a linear simulation. So we can simply delete it. \n\n\nBefore computing spin-wave spectrum, let's check out what inputs are needed and how to feed them to the code by displaying usage instruction :\n\n    java ComputeSpinWave --help\n\nThis will display the following :\n\n\n    #####################################################################\n    # ComputeSpinWave code computes spin-wave spectrum from trajectories#\n    # of spins generated from mysd simulator. Check out the following   #\n    # github repository for most recent version :                       #\n    # https://github.com/Eunsong/SpinDynamicsSimulator.git              #\n    #                                                                   #\n    # The code requires following inputs to run :                       #\n    #          1. -i   commond name of .info and .trj files             #\n    #          2. -t   *.top  file                                      #\n    #          3. -nk  number of desired k-space points(this must be    #\n    #                  divisible of number of unit cells along desired  #\n    #                  direction.)                                      #\n    #          4. -kx, -ky, -kz  desired k-space direction              #\n    #          5. -nw  number of desired w-space points                 #\n    #          6. -dw  size of w-space grid                             #\n    #          7. -o   output file name                                 #\n    #                                                                   #\n    # Usage example : java ComputeSpinWave -i inputs -t topology.top    #\n    #                -nk 50 -kx 1 -ky 0 -kz 0 -nw 100 -dw 0.05          #\n    #                -o spinwaves_cubicFM.dat                           #\n    #                                                                   #\n    ##################################################################### \n\n\nFor our system, we can type in the following line to execute *ComputeSpinWave* code using output trajectory we have generated :\n\n    java ComputeSpinWave -i out -t topol.top -nk 50 -kx 1 -ky 0 -kz 0 -nw 100 -dw 0.05 -o spinwave_squareFM.dat\n\n\nNote that the flag *-i* followed by the file name *out* tells the code to look for *out.info* and *out.trj* files to re-build the lattice system and import the trajectory. *-nk* flag defines the number of k-space points to be computed along the direction specified by *-kx*, *-ky*, and *-kz* flags. The equation below shows how computed k-vectors are determined:\n\n\n![alt tag](https://raw.githubusercontent.com/Eunsong/SpinDynamicsSimulator/master/examples/figures/kvector.png)\n\n\nwhere m runs from 0 to nk. *-nk* and *-dw* determine the number of frequency space grids and the size of each grid respectively. Once computation is done, you can open the file *spinwave_squareFM.dat*. The file has three-column data which looks like this :\n\n    # spin-wave spectrum computed from ComputeSpinWave.java code\n    # computed at : 2015/01/22 16:07:56\n    # check out https://github.com/Eunsong/SpinDynamicsSimulator for most recent updates\n    #      k     omega  S[k][w]\n      0.0000    0.0000  9.997e+03\n      0.0000    0.0500  5.231e+01\n      0.0000    0.1000  5.057e+01\n         .         .        .\n         .         .        .\n\n\nwhere each column indicates k-value(*m/nk* precisely), frequency, and spin-deviation in k-w space. You can plot this file using your favorite plotting tool that supports either 3d plot or contour plot. Here I will plot it using *gnuplot*. If you go to */examples/squareFM/* folder, you can find a gnuplot script named *plotting_script*. You can simply execute this script to create a figure,\n\n    gnuplot plotting_script\n\nwhich will create a file named *spinwave_squareFM_k100.png* that looks like this,\n\n<p align=\"center\"><img src=\"https://github.com/Eunsong/SpinDynamicsSimulator/blob/master/examples/squareFM/spinwave_squareFM_k100.jpg\" alt=\"Drawing\" WIDTH=\"80%\"></p>\n\n\nThis completes the first tutorial. In the next tutorial, we will try slightly more complicated system and also see how non-linear simulation can be used.\n\n\n\n\n###2. Honeycomb Lattice, J1-J2 model\n\nIn this tutorial, we will simulate the honeycomb lattice with antiferromagnetic nearest-neighbor interactions (*J1>0*) and ferromagnetic next-nearest-neighbor interactions(*J2<0*). The ground state structure of the system is antifoerromagnetic ordering, but let's suppose that we do not have this priori information. Instead, we will start from ferromagnetic ordering to see how we can construct a correct ground state configuration from a non-linear simulation. \n\nFirst off, we should write a .top file for the honeycomb lattice.\n\n    [ basis ]\n    #number      x           y      z       (optional)Sx    Sy      Sz\n         0     0.0         0.0    0.0                0.0   0.0     1.0\n         1     0.0         1.0    0.0                0.0   0.0     1.0\n         2    -0.8660254   1.5    0.0                0.0   0.0     1.0\n         3     0.8660254  -0.5    0.0                0.0   0.0     1.0\n    \n    \n    [ lattice_vector ]\n    #ax\n    0.8660254   1.5   0.0\n    #ay\n    3.4641016   0.0   0.0\n    #az\n    0.0         0.0   99.0 # az lattice vector is never used here. Put something large if you are using genbonds.py to find nearest neighbors.\n\n    [ unit_cells ]\n    #nx     ny      nz\n    30      30      1\n    \n\n\nYou should be comfortable with most of the fields above if you have gone through the first tutorial. The only thing that is worth mentioning here is, since we are again using 2-dimensional lattice, lattice vector *az* is of no use just like previous tuorial. However, put something large for *az* components as we are going to use a helper python script in the next step to find a list of nearest and next-nearest neighbors which will duplicate unit cells along all three directions and find relative position of each site. For an actual simulation, as long as *nz* is set to 1, the actual numbers you put for *az* does not matter at all. Now, we need two Hamiltonian matrices for nearest-neighbors, *J1*,  and for next-nearest-neighbors, *J2*. You can list as many matrices as you want in this section. \n\n    \n    [ Hamiltonian ]\n    #type       a11     a12     a13     a21     a22     a23     a31     a32     a33\n    J1          1.0     0.0     0.0     0.0     1.0     0.0     0.0     0.0     1.0\n    J2         -0.2     0.0     0.0     0.0    -0.2     0.0     0.0     0.0    -0.2\n\n\nNow, the only remaining part is to list all interaction pairs, and depending on whether they are nearest-neighbors or next-nearest-neighbors, put appropriate Hamiltonian type for each of them. Finding neighbors is an error-prone part especially for complicates systems. So we are going to use a python script *genbonds.py* in */src/misc/* directory to construct a list of neighbors. First, save above fields to *topol.top* file. Copy *genbonds.py* file to the current directory and type in the following command:\n\n    python genbonds.py topol.top --rank 1 --search 2\n\nThis will print out a list of nearest-neighbor(*i.e.* rank 1) pairs to your screen. Note that *--search* flag is used to determine the range of neighboring unit cells for searching nearest-neighbors. For instance, if the search range is set to *1*, this means that the code will look for all the sites only in the neighboring unit cells along each direction. Default search range is *1*. For this system, default search range will miss some of the nearest-neighbor pairs. So we should explicitly set it to *2*. Then you should see the following in your screen:\n\n       0            <i-1>1\n       0                 3\n       0                 1\n       1                 2\n       1            <i+1>0\n       1                 0\n       2                 1\n       2       <i+1><j-1>3\n       2       <i+2><j-1>3\n       3                 0\n       3       <i-1><j+1>2\n       3       <i-2><j+1>2\n\nThese are the nearest-neighbor pairs. Just add *J1* in each line above. Next, we then find next-nearest-neighbors as follows:\n\n    python genbonds.py topol.top --rank 2 --search 2\n\nwhich will print out this:\n\n\n       0            <i-1>2\n       0       <i-1><j+1>2\n       0       <i-2><j+1>2\n       0            <i-1>0\n       0                 2\n       0            <i+1>0\n       1            <i+1>3\n       1       <i+1><j-1>3\n       1            <i-1>1\n       1                 3\n       1            <i+1>1\n       1       <i+2><j-1>3\n       2            <i+1>0\n       2       <i+1><j-1>0\n       2            <i-1>2\n       2                 0\n       2            <i+1>2\n       2       <i+2><j-1>0\n       3            <i-1>1\n       3       <i-1><j+1>1\n       3       <i-2><j+1>1\n       3            <i-1>3\n       3                 1\n       3            <i+1>3\n\n\nThese are next-nearest-neighbors, so add *J2* in each line above. Now add all these togther under *[ bonds ]* section to your *topol.top* file. It should look somethign like this:\n\n    [ bonds ]\n      #a                b   HamiltonianType\n       0            <i-1>1  J1\n       0                 1  J1\n       0                 3  J1\n       1                 2  J1\n       1            <i+1>0  J1\n       1                 0  J1\n       2                 1  J1\n       2        <i+1><j-1>3 J1\n       2        <i+2><j-1>3 J1\n       3                 0  J1\n       3        <i-1><j+1>2 J1\n       3        <i-2><j+1>2 J1\n       0            <i-1>2  J2\n       0       <i-2><j+1>2  J2\n       0            <i-1>0  J2\n       0                 2  J2\n       0            <i+1>0  J2\n       0       <i-1><j+1>2  J2\n       1            <i+1>3  J2\n       1            <i-1>1  J2\n       1                 3  J2\n       1            <i+1>1  J2\n       1       <i+2><j-1>3  J2\n       1       <i+1><j-1>3  J2\n       2            <i+1>0  J2\n       2            <i-1>2  J2\n       2                 0  J2\n       2            <i+1>2  J2\n       2       <i+2><j-1>0  J2\n       2       <i+1><j-1>0  J2\n       3            <i-1>1  J2\n       3       <i-2><j+1>1  J2\n       3            <i-1>3  J2\n       3                 1  J2\n       3            <i+1>3  J2\n       3       <i-1><j+1>1  J2\n\n\n\nNow, we have a complete .top file. Note that as I have mentioned earlier, we are starting with ferromagnetic ordering. You can see this in your *topol.top* file in the *[ basis ]* section; all spins are aligned along *+z* direction. If you run a linear simulation using this topology file, the output trajectory will blow-up; **Linear simulation works only on a ground state structure**. So if you happen to see extremely large numbers in your output trajectory file, it most likely means that you are not using proper ground state configuration. \n\nSo we will carry out a nonlinear simulation with a large damping constant to relaxate the ferromagnetic structure to (hopefully) an antiferromagnetic structure. Write a .sdp file that looks something like below:\n\n\n    title                   = Honeycomb_J1-J2\n    \n    runtype                 = nonlinear  #linear of nonlinear.\n    \n    dt                      = 0.1  #time step size\n    ntstep                  = 50000 #number of time steps\n    alpha                   = 0.5  #Gilbert damping constant\n    \n    nstout                  = 0    #save outputs every nstout steps(0 to write only the final config)\n    nstbuff                 = 100  #output buffer size(can enable this option using BufferedBasicWriter)\n    nstenergy               = 5    #save total energy every nstenergy steps(only for nonlinear simulations)\n    \n    perturb_site            = true #true to perturb a site at start\n    perturbing_site_index   = 0    #index of a site to be perturbed\n    perturbation_size       = 1    #linear case, this determines initial size of sigma_x,\n                                   #nonlinear case, this is a roatation angle(degree)\n\n\nnote that we have specified nonlinear simulation in the line  *runtype = nonlinear* and set a large damping constant *alpha = 0.5*. Also, since the purpose of this simulation is to obtain a ground state structure, we do not need to save trajectories. So set *nstout = 0*. (although linear simulations can produce much cleaner spin-wave spctra, nonlinaer simulation results can also be used to compute spin-waves. If that is what you need, set *nstout* accordingly.) Save above to a file named *sdrun_nl.sdp*. We will use *_nl* suffix to denote *nonlinear* simulation. Then type in the following line in the command line :\n\n    java Run -t topol.top -s sdrun_nl.sdp -o out_nl\n\nOnce this is done, you will see four new files are created:\n\n    out_nl.cnf\n    out_nl.eng\n    out_nl.info\n    out_nl.trj\n\nSince we set *nstout* to *0*, *out_nl.trj* constains no information at all. So you can just delete this file. Now, let's look at the output configurational file, *out_nl.cnf*. If you open the file, it should look something like this (note that the numbers you see may be different. Due to *U(1)* symmetry of the system, globally rotated spin structure are identical.):\n\n\n    # time =      5000.0000\n           0   -0.55269    0.83128    0.05930\n           1    0.55269   -0.83128   -0.05930\n           2   -0.55269    0.83128    0.05930\n           3    0.55269   -0.83128   -0.05930\n           .        .          .         .\n           .        .          .         .\n\nThe first column of .cnf file is spin index *n* which is uniquely defined for each spin with given unit cell indices, *i*, *j*, *k*, and sublattice index *l* :\n\n    n = i*ny*nz*m + j*nz*m + k*m + l\n\nwhere *nx*, *ny*, and *nz* are number of unit cells along each lattice vectors and *m* is number of sub-lattices in each unit cell. Second, third, and fourth columns are spin components Sx, Sy, and Sz respectively. Note that for linear simulations, these are spin deviations(sigmax, sigmay, and sigmaz) instead. Now, if you look at *out_nl.cnf* file, neighboring spins are aligned *anti-parallely*. This is the correct ground state for our system. We are going to use this configuration file to run a linear simulation. But before jumping into that, let's check out *out_nl.eng* file. This file contains total energy of the system as a function of time; We have specified in the *sdrun_nl.sdp* file to write energy every *5* time steps. If you plot *out_nl.eng*, you can see that the energy is converged very quickly.\n\n\n<p align=\"center\"><img src=\"https://github.com/Eunsong/SpinDynamicsSimulator/blob/master/examples/honeycomb_J1J2/energy_nl.png\" alt=\"Drawing\" WIDTH=\"60%\"></p>\n\n\nYou should always check output energies to ensure convergence. This step is particularly important if you do not know the correct ground state of the system. In that case, you might want to start from different initial configurations and different perturbation amount, and see if they all converge to the same energy and structure.   \n\n\n\nIn order to run a linear simulation, we need to change our .sdp file. Create a new file named *sdrun_l.sdp*, where *_l* suffix denotes linear simulation. You should now be able to fill out the sdp file on your own. In my case, I put something like this(but you don't need to use the same settings. I would suggest to play with different settings a bit to get a better sense of how these numbers affect the simulation),\n\n\n    title                   = Honeycomb_J1-J2\n    \n    runtype                 = linear  #linear of nonlinear.\n    \n    dt                      = 0.02  #time step size\n    ntstep                  = 50000 #number of time steps\n    alpha                   = 0.01  #Gilbert damping constant\n    \n    nstout                  = 5    #save outputs every nstout steps(0 to write only the final config)\n    nstbuff                 = 100  #output buffer size(can enable this option using BufferedBasicWriter)\n    nstenergy               = 0    #save total energy every nstenergy steps(only for nonlinear simulations)\n    \n    perturb_site            = true #true to perturb a site at start\n    perturbing_site_index   = 0    #index of a site to be perturbed\n    perturbation_size       = 1    #linear case, this determines initial size of sigma_x,\n                                   #nonlinear case, this is a roatation angle(degree)\n\n\nThen, type in the following line to run the simulation :\n\n    java Run -t topol.top -s sdrun_l.sdp -c out_nl.cnf -o out_l\n\n\nNote that we added another optional flag *-c* which allows you to overload initial spin configurations with a specified .cnf file. Once the simulation is done, we can pretty much repeat what we have learned in the first tutorial to compute spin-wave spectra. Try to do it on your own with a help of usage instruction which you can display with *--help* flag. I decided to compute the spin-wave along 110 direction as follows :\n\n    java ComputeSpinWave -i out_l -t topol.top -nk 30 -kx 1 -ky 1 -kz 0 -nw 120 -dw 0.05 -o spinwave_honeycombJ1J2_k110.dat\n\nand the figure should look like this :\n\n\n<p align=\"center\"><img src=\"https://github.com/Eunsong/SpinDynamicsSimulator/blob/master/examples/honeycomb_J1J2/spinwave_honeycombJ1J2_k110.jpg\" alt=\"Drawing\" WIDTH=\"80%\"></p>\n\n\n\nThis is the end of the tutorials. You can now simulate any system of your interest. \n\n\n\n", 
  "id": 26892409
}
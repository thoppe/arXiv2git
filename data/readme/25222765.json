{
  "read_at": 1462510056, 
  "description": "Extensible stream pipelines with object algebras.", 
  "README.md": "## StreamAlg\n\n[![Build Status](https://travis-ci.org/biboudis/streamalg.svg?branch=master)](https://travis-ci.org/biboudis/streamalg)\n\nThe StreamAlg repository contains the source code artifact that accompanies the\n[_Streams \u00e0 la carte: Extensible Pipelines with Object Algebras_](http://goo.gl/P2XO68) paper, to appear at the\n[29th European Conference on Object-Oriented Programming (ECOOP'15)](http://2015.ecoop.org/).\n\n### Overview\n\nWe address extensibility shortcomings in libraries for lazy-streaming queries\nwith a new design. The architecture underlying this design borrows heavily from\nOliveira and Cook's object algebra solution to the expression problem, extended\nwith a design that exposes the push/pull character of the iteration, and an\nencoding of higher-kinded polymorphism.\n\nIn this library we apply our design to Java and show that the addition of full\nextensibility is accompanied by high performance, matching or exceeding that of\nthe original, highly-optimized Java streams library.\n\nIn this repository we present a fundamental set of sequential operators ```map```,\n```filter```, ```reduce```, ```count```, ```take/limit``` and ```iterate```.\n\nAdditionally we present the behaviors that are discussed in the paper: push, pull, fused pull, logging, id (for\nblocking terminal operators), future (for non-blocking terminal operators).\n\n### Getting Started\n\n#### Prerequisites\nThe project runs with Java 8.\n\n#### Testing\nClone the project:\n```shell\ngit clone git@github.com:biboudis/streamalg.git\n```\nThe project is built with maven and its dependencies are automatically resolved: Guava, JMH and JUnit. To run the test suite simply run:\n```shell\nmvn test\n```\nThe tests cover all examples included in the paper (operators, behaviors) and cases used as motivation as well. The ```streams``` package is covered at:\t87% classes,\t90% methods,\t91% lines.\n\n#### Running Benchmarks\nBenchmarks are reproduced by executing:\n```shell\nsh run_benchmarks.sh\n```\n\n### Project Structure\nThe basic packages of this artifact are the following:\n\n#### Object Algebras\n- StreamAlg: describes the object algebra of the intermediate operators of streams.\n- TakeStreamAlg: adds to streams the ```take``` combinator.\n- ExecStreamAlg: adds to streams the terminal operators.\n- ExecIterateStreamAlg: adds to streams the ```iterate``` terminal operator.\n- ExecTakeStreamAlg: unifies terminal operators with the algebra with the ```take``` combinator.\n\n#### Factories\nThe following factories implement different combinations of behaviors:\n\n- ExecFusedPullFactory\n- ExecFutureFactory\n- ExecPullFactory\n- ExecPullWithIterateFactory\n- ExecPullWithTakeFactory\n- ExecPushFactory\n- ExecPushWithTakeFactory\n- LogFactory\n- PullFactory\n- PushFactory\n\n#### Higher Kinded types\nThe types that participate in higher-kinded polymorphism scenarios are: ```Future```, ```Id```, ```Pull``` and ```Push```.\n\n#### GADT encoding\nThe encoding appears in the ```gadt.evaluator``` package.\n\n#### Fluent APIs\nIn ```streamalg/fluent/Stream.cs``` and ```streamalg/fluent/Stream.scala``` we describe a\npossible solution of obtaining fluent APIs of Streams a la carte in C# and Scala.\n\n### Benchmarks\nThe ```run_benchmarks.sh``` script simply builds the JMH benchmarks \u00fcber-jar and then uses the command line interface\nof JMH to pass the arguments of the experiments. The script will run all benchmarks in\n```streamalg/src/main/java/benchmarks/*``` and their description is included in the paper.\nThe user can run the benchmark script as is or by passing a regular-expression for filter to select only some of them. The\nmicro-benchmark suite can be passed the number of elements ```N``` for map, count, operations with large number of elements, ```N_small```\nthat is used for cart and limit/take examples. ```N_limit``` is used as the parameter for ```limit``` and ```F``` is used for\nbenchmarks with fused pipelines.\n\nFor more information on JMH the user can run it directly,\ne.g., to get the help dialog ```java -jar target/microbenchmarks.jar -h```.\n\nWe omitted baseline tests from the paper (although we included them in the repo) as the focus of the paper\nis not on comparing hand-optimized tight loops with streaming pipelines.\nWe have investigated this in previous work (http://arxiv.org/abs/1406.6631) and it is something that\nwe would like to investigate about the OpenJDK specifically in the immediate future.\n\nWe include three basic categories of benchmarks: _basic pipelines_ with various combinations about both Pull and Push algebras,\n_fused pipelines_ to exercise map and filter fusion and help with the comparison between the non-fused pipelines,\n_iterator pipelines_ to demonstrate differences of the Pull algebra and the obtaining of an iterator from Java 8 Streams\nand _take pipelines_ (the ```take``` operator is the same as the ```limit``` operator in Java 8 Streams).\n\n### Team\n\n[Aggelos Biboudis](http://www.di.uoa.gr/~biboudis/) ([@biboudis](https://twitter.com/biboudis)), Nick Palladinos\n([@NickPalladinos](https://twitter.com/NickPalladinos)), George Fourtounis\n([@gf0ur](https://twitter.com/gf0ur)) and\n[Yannis Smaragdakis](http://www.di.uoa.gr/~smaragd/) ([@YSmaragdakis](https://twitter.com/YSmaragdakis)).\n", 
  "id": 25222765
}
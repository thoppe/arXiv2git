{
  "read_at": 1462550218, 
  "description": "Fast Fast Hadamard Transform", 
  "README.md": "# Fast Fast Hadamard Transform\n\nFFHT (Fast Fast Hadamard Transform) is a library that provides a heavily\noptimized C99 implementation of the Fast Hadamard Transform. FFHT also provides\na thin Python wrapper that allows to perform the Fast Hadamard Transform on\none-dimensional [NumPy](http://www.numpy.org/) arrays.\n\nThe Hadamard Transform is a linear orthogonal map defined on real vectors whose\nlength is a _power of two_. For the precise definition, see the\n[Wikipedia entry](https://en.wikipedia.org/wiki/Hadamard_transform). The\nHadamard Transform has been recently used a lot in various machine learning\nand numerical algorithms.\n\nFFHT uses [AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions)\nto speed up the computation. If AVX is not supported on your machine, a simpler\nimplementation without (explicit) vectorization is used.\n\nThe header file `fht.h` exports two functions: `int FHTFloat(float *buffer, int\nlen, int chunk)` and `int FHTDouble(double *buffer, int len, int chunk)`. The\nonly difference between them is the type of vector entries. So, in what follows,\nwe describe how the version for floats `FHTFloat` works.\n\nThe function `FHTFloat` takes three parameters:\n\n* `buffer` is a pointer to the data on which one needs to perform the Fast\nHadamard Transform. If AVX is used, `buffer` must be aligned to 32 bytes (one\nmay use `posix_memalign` to allocate aligned memory).\n* `len` is the length of `buffer`. It must be equal to a power of two.\n* `chunk` is a positive integer that controls when FFHT switches from recursive\nto iterative algorithm. The overall algorithm is recursive, but as soon as the\nvector becomes no longer than `chunk`, the iterative algorithm is invoked. For\ntechnical reasons, `chunk` must be at least 8. To choose `chunk` one should use\na program `best_chunk`, see below.\n\nThe return value is -1 if the input is invalid and is zero otherwise.\n\nA header-only version of the library is provided in `fht_header_only.h`.\n\nIn addition to the Fast Hadamard Transform, we provide two auxiliary programs:\n`test` and `best_chunk`, which are implemented in C++11. The former exhaustively\ntests the library. The latter chooses the best value of `chunk` given the length\nof a buffer, on which the Fast Hadamard Transform would be performed.\n\nFFHT has been tested on 64-bit versions of Linux, OS X and Windows (the latter\nis via Cygwin).\n\nTo install the Python package, run `python setup.py install`. The script\n`example.py` shows how to use FFHT from Python.\n\n## Benchmarks\n\nBelow are the times for the Fast Hadamard Transform for vectors of\nvarious lengths. The benchmarks were run on a machine with Intel\nCore&nbsp;i5-2500 and 1333 MHz DDR3 RAM. We compare FFHT,\n[FFTW 3.3.4](http://fftw.org/), and\n[fht](https://github.com/nbarbey/fht) by\n[Nicolas Barbey](https://github.com/nbarbey).\n\nLet us stress that FFTW is a great versatile tool, and the authors of FFTW did\nnot try to optimize the performace of the Fast Hadamard Transform. On the other\nhand, FFHT does one thing (the Fast Hadamard Transform), but does it extremely\nwell.\n\nVector size | FFHT (float) | FFHT (double) | FFTW 3.3.4 (float) | FFTW 3.3.4 (double) | fht (float) | fht (double)\n:---: | :---: | :---: | :---: | :---: | :---: | :---:\n2<sup>10</sup> | 0.76 us | 1.47 us | 12.1 us | 16.87 us | 31.4 us | 33.3 us\n2<sup>20</sup> | 2.26 ms | 5.50 ms | 18.4 ms | 27.68 ms | 46.8 ms | 61.3 ms\n2<sup>27</sup> | 0.74 s | 1.59 s | 2.93 s | 4.64 s | 10.1 s | 11.5 s\n\n## Troubleshooting\n\nFor some versions of OS X the native `clang` compiler (that mimicks `gcc`) may\nnot recognize the availability of AVX. A solution for this problem is to use a\ngenuine `gcc` (say from [Homebrew](http://brew.sh/)) or to use `-march=corei7-avx`\ninstead of `-march=native` for compiler flags.\n\nA symptom of the above happening is the undefined macros `__AVX__`.\n\n## Related Work\n\nFFHT has been created as a part of\n[FALCONN](https://github.com/falconn-lib/falconn): a library for similarity\nsearch over high-dimensional data. FALCONN's underlying algorithms are described\nand analyzed in the following research paper:\n\n> Alexandr Andoni, Piotr Indyk, Thijs Laarhoven, Ilya Razenshteyn and Ludwig\n> Schmidt, \"Practical and Optimal LSH for Angular Distance\", NIPS 2015, full\n> version available at [arXiv:1509.02897](http://arxiv.org/abs/1509.02897)\n\n## Acknowledgments\n\nWe thank Ruslan Savchenko for useful discussions.\n\nThanks to:\n\n* Clement Canonne\n* Michal Forisek\n* Rati Gelashvili\n* Daniel Grier\n* Dhiraj Holden\n* Justin Holmgren\n* Aleksandar Ivanovic\n* Vladislav Isenbaev\n* Jacob Kogler\n* Ilya Kornakov\n* Anton Lapshin\n* Rio LaVigne\n* Oleg Martynov\n* Linar Mikeev\n* Cameron Musco\n* Sam Park\n* Sunoo Park\n* William Perry\n* Andrew Sabisch\n* Abhishek Sarkar\n* Ruslan Savchenko\n* Vadim Semenov\n* Arman Yessenamanov\n\nfor helping us with testing FFHT.\n", 
  "id": 47213739
}
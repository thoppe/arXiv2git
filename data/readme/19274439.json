{
  "read_at": 1462550803, 
  "description": "Fast parallel random number generator for GPUs", 
  "readme.txt": "    BCNRAND, last change 27/4/2014\n\n\tThis is the C language parallel version of the library bcnrand, which  generates\n\tuniform random variates of type double on (0,1), using the linear\n\tCongruential Generator (LCG) by J. Borwein and D. Bailey. \n\n\tThere are two generators, the basic and the combined. The basic generator is of\n\ta good quality and has the period of approx 10^15. Its advantage is that it is\n\tvery fast, twice as fast if compared to the very basic (and poor quality) standard \n\tC function rand(). The combined generator is a bit slower (still faster than \n\trand()), but it has the period of 10^23, and it passes all the tests in BigCrush \n\tsuite of tests. The random numbers are not of cryptographic strength, but are well\n\tsuited for numerical simulations, especially in parallel processes, where\n\tthe sam sequence of random variate is obtained when using any number of threads.\n\tThis is because of the valuable skip ahead feature. The seed is the starting \n\tposition in the sequence of random variates.\n\n\tThe implementation is in the .h file, which means that only include statement \n\tis needed to start using this generator.\n\n\tRandom variates are generated in parallel on GPU (with Nvidia's CUDA).\n\tThis is version 2 of this library. Version 2 no longer has the original \n\tBCN method, as the method based on Barrett reduction is superior. This \n\tversion no longer uses double-double implementation of the seeding step, \n\tas a more efficient implementation was found. \n\n \tThe random variates are generated by iterating\n\t                       z_{k+1} = 2^53 z_k mod 3^33. \n\tThe actual random variate is computed by \n\t                            x = z_{k+1} * 3^-33. \n\tThe period is approx 10^15. Random variates can be generated in parallel \n\tand in multiple threads, although this version of the code is not always\n\tguaranteed to be thread safe, see notes below.\n\n\tA combined LCG is also used to ensure even better statistical quality\n\tof the generated sequence. The combined generator is marginally slower than\n\tJ. Borwein and D. Bailey's LCG, but gives a longer period and passes\n\tBirthday spacings and Closed pairs tests as well.\n\n\tThe pseudorandom sequence passes the statistical tests of BigCrunch \n\ttest of TestU01 suite. The description of the method is published in:\n\n\tBeliakov, G., Creighton, D., Johnstone, M. and Wilkin, T. 2013, Efficient \n\timplementation  of Bailey and Borwein pseudo-random number generator based \n\ton normal numbers, Computer physics communications, vol. 184, no. 8, pp. 1999-2004.\n\n\tG. Beliakov, M. Johnstone, D. Creighton, T. Wilkin, 2012, An efficient \n\timplementation of  Bailey and Borwein's algorithm for parallel random number \n\tgeneration on graphics processing units, Computing 94(5): 433-447.\n\n\tG. Beliakov, M. Johnstone, D. Creighton, T. Wilkin, Parallel random\n\tvariates generator for GPUs based on normal numbers, ArXiv 1206.1187\n\thttp://arxiv.org/abs/1206.1187,\n\tsee also\thttp://www.deakin.edu.au/~gleb/bcn_random.html\n\n\t\n\tUsage: Follow the examples presented here.\n\t\n\tbcnrand offers two alternative methods for generating random variates \n\tBCN and Combined. \n\n\t\tBCN is the method based on our modified Barrett reduction.\n\t\tCombined is the method that used BCN and an auxiliary LCG \n\n\t\tThe user desires to generate a sequence of pseudorandom variates starting \n\t\tfrom a chosen position (seed), using a number of parallel threads. Each \n\t\tthread generates part of the sequence. The random variates are either \n\t\twritten to global memory, or used for any task, such as simulation.\n\n     Step 1 is to generate an array of starting positions for each thread \n\t (seeds). It is accomplished by calling \n\t\t\tdim3 dimBlock(numThreadsPerBlock, 1, 1);\n\t\t\tdim3 dimGrid(numBlocks, 1, 1);\n\t\t\tKernel_initGenerator<<< dimGrid, dimBlock >>>(d_SeedData, workPerThread, seed);\n\n\t\tworkPerThread is a parameter that specifies the length of the subsequence \n\t\tof random variates for each thread.\n\t\tIt is calculated as workPerThread = TotalNumOfElements/numBlocks/numThreadsPerBlock;\n\t\tNOTE that the parameter \"seed\" is the starting position of the first element of the sequence \n\n     Step 2 is to generate random variates. It is accomplished by calling kernels with this code:\n\t\t\t//get starting seed\n\t\t\tuint64_t seed = (uint64_t)d_SeedData[blockIdx.x * blockDim.x * blockDim.y + tid];\n    \t\t\tfor (int i = 0 ; i < WorkPerThread ; i++)\n   \t\t\t{\t\t\n\t\t\t\tgenerated_value=bcnrandom_inline(&seed);\n        \t}\n\t\tbcnrandom_inline can be replaced by randCombined(&seed, &seed1);\t\n\n\t\tSee example kernels Kernel_CountValues, (Kernel_CountValues_Combined), which \n\t\tare used to calculate the number of random variates smaller than 0.9. These \n\t\tkernels are invoked by calling\n\t\t\n\t\t\tKernel_CountValues<<<dimGrid, dimBlock, dimBlock.x * sizeof(unsigned int)>>>(d_OutputData, d_SeedData, workPerThread);\n\t\twhere d_SeedData are precomputed at Step 1 seeds, and d_OutputData is the array of \n\t\tunsigned int of length numblocks. The complete code is in function InlineGeneration\n\n\t\tThis kernel will use the combined generator, which has better statistical properties\n\t\t    Kernel_CountValues_Combined<<<dimGrid, dimBlock, dimBlock.x * sizeof(unsigned int)>>>(d_OutputData, d_SeedData, d_SeedData1, workPerThread);\n\n\t      To write generated values to global memory, see function TimeBarrettMethod. \n\n\n\tList of functions:\n\t\tbcnrandom_inline, randCombined  - two methods called by kernels that actually \n\t\tperform generation steps\n\n\t\tKernel_CountValues, Kernel_CountValues_Combined - example kernels that count \n\t\tthe number of generated values smaler than 0.9. They call their respective methods from \n\t\tthe list above, and multiply the returned values by 3^-33, then use the result\n\n\t\tKernel_initGenerator - initialises the array of seeds (for each thread)\n\n\t\tKernel_initGeneratorCombined - initialises the two arrays of seeds \n\t\t(for the bcn and the auxiliary generator) (for each thread)\n\n\t\tInlineGeneration - shows how to use the functions above\n\n\t\tKernel_Opt   - example kernel that writes generated values to an array in global memory \n\n\t\tTimeBarrettMethod - shows how to use the example kernels and times its execution, \n\t\t\t\tthen prints the results\n\t\t\t\n\n\tExample and main file:\n\t\tSee file bcnrand.cu\n\n\tThis program is freeware.\n\n\n\tPlease cite our work\n\tBeliakov, G., Creighton, D., Johnstone, M. and Wilkin, T. 2013, Efficient implementation of Bailey and Borwein \n\tpseudo-random number generator based on normal numbers, \n\tComputer physics communications, vol. 184, no. 8, pp. 1999-2004.\n\n\tG. Beliakov, M. Johnstone, D. Creighton, T. Wilkin, 2012, An efficient implementation of \n\tBailey and Borwein's algorithm for parallel random number generation on graphics processing\n\tunits, Computing 94(5): 433-447.\n\n\thttp://arxiv.org/abs/1206.1187, http://www.deakin.edu.au/~gleb/bcn_random.html\n\n\tJ. Borwein and D. Bailey's work is available from:\n\thttp://crd.lbl.gov/~dhbailey/dhbpapers/normal-pseudo.pdf\n\n\tCopyright Gleb Beliakov, Tim Wilkin and Michael Johnstone, 2013\n\n\n\n\n\n\n", 
  "id": 19274439
}
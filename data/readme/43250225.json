{
  "read_at": 1462549047, 
  "description": "", 
  "README.md": "README\n======\n\nThis repository provides a software implementation in Python of the computation\nof the Non-Parametric estimation of Fisher Information (NPFI), as presented in\n[1]. The repository contains a simple example of how npfi can be used to\ncompute the Fisher information of the Gaussian distribution, in addition to the\nscripts recreating Figs. 2-4 in [1].\n\nWritten by Omri Har-Shemesh, Computational Science Lab, University of Amsterdam\n\nUsage\n-----\n\nTo compute the Fisher information from samples there are two steps necessary -\ncomputing probability density functions (pdfs) from the samples that are taken\nat known parameter values and combining these to compute the Fisher\ninformation. The file `npfi.py` provides three two functions, one for each of\nthese steps and one to integrate the FI along a line. To use these functions\nsimply place `npfi.py` in the same directory as your script and import the\nnecessary functions. For example:\n\n```python\n    from npfi import npfi, get_pdfs_from_data\n```\nThe process of extracting the PDFs and computing the Fisher information is\ndescribed in the following subsections:\n\n### Estimating the PDFs using `get_pdfs_from_data`\n\nThe function `get_pdfs_from_data` currently uses either `gaussian_kde` from the\n`scipy` Python package or `deft` (if present) to estimate the PDFs for each of\nthe data provided. It takes as first argument a `list` of `numpy` arrays, each\narray assumed to be a list of samples from the same parameter range and returns\na list of pdfs with the corresponding non-parametric estimate for each of\nthese. The default estimation method is `deft` and the rest of the parameters\nit accepts control the estimation process. See the code for a detailed\nexplanation of each of the parameters. In order for the deft method to work, \nthe file `deft.py` which is available at https://github.com/jbkinney/13_deft\nhas to be placed in the same directory as `npfi.py` and your script.\n\n### Computing the FI from the PDFs\n\nThe function `npfi` accepts either three or five pdfs and computes either the\ndiagonal FI element or the off-diagonal element respectively of the Fisher\ninformation matrix. See the source code for exact implementation details and\ndocumentation of each of the input parameters.\n\n### Example: computing the `g_ss` component of the FIM\n```python\n    from npfi import npfi, get_pdfs_from_data\n\n    # Compute g_ss for the Gaussian distribution\n    s = 1.0\n    ds = 0.1\n    N = 5000\n    rep = 30\n    analytic_value = 2.0 / s\n\n    FIMs_kde = []\n    FIMs_deft = []\n    epsilons_kde = []\n    epsilons_deft = []\n    for i in range(rep):\n        Xa = normal(size=N, scale=s)\n        Xb = normal(size=N, scale=s-ds)\n        Xc = normal(size=N, scale=s+ds)\n\n        pdfs_deft, bbox_deft = get_pdfs_from_data([Xa, Xb, Xc], method=\"deft\")  # DEFT\n        pdfs_kde, bbox_kde = get_pdfs_from_data([Xa, Xb, Xc], method=\"gaussian_kde\")\n        FIM_deft, int_err_deft, epsilon_deft = npfi(pdfs_deft, ds, N=N, bounds=bbox_deft, logarithmic=False)\n        FIM_kde, int_err_kde, epsilon_kde = npfi(pdfs_kde, ds, N=N, bounds=bbox_kde, logarithmic=True)\n\n        FIMs_deft.append(FIM_deft)\n        FIMs_kde.append(FIM_kde)\n        epsilons_deft.append(FIM_deft)\n        epsilons_kde.append(FIM_kde)\n\n    print(\"#\" * 50)\n    print(\"Estimation of the FI after %d repetitions:\" % rep)\n    print(\"Analytic value: %.2f\" % analytic_value)\n    print(\"FIM from DEFT: %.3f, epsilon=%.3f\" % (np.mean(FIMs_deft), np.mean(epsilon_deft)))\n    print(\"FIM from KDE: %.3f, epsilon=%.3f\" % (np.mean(FIMs_kde), np.mean(epsilon_kde)))\n    rel_deft = (np.mean(FIMs_deft) - analytic_value) / analytic_value\n    rel_deft_95 = (np.percentile(FIMs_deft, 95) - analytic_value) / analytic_value - rel_deft\n    rel_deft_5 = rel_deft - (np.percentile(FIMs_deft, 5) - analytic_value) / analytic_value\n    print(\"Relative error DEFT: %.5f + %.5f - %.5f\" % (rel_deft, rel_deft_95, rel_deft_5))\n    rel_kde = (np.mean(FIMs_kde) - analytic_value) / analytic_value\n    rel_kde_95 = (np.percentile(FIMs_kde, 95) - analytic_value) / analytic_value - rel_kde\n    rel_kde_5 = rel_kde - (np.percentile(FIMs_kde, 5) - analytic_value) / analytic_value\n    print(\"Relative error KDE: %.5f + %.5f - %.5f\" % (rel_kde, rel_kde_95, rel_kde_5))\n    print(\"#\" * 50)\n\n```\n\n### Reproducing the figures\n\nTo reproduce the figures, simply run `fig2.py`, `fig3.py`, or `fig4.py` using\n`python2`.\n\nFiles\n-----\n\nnpfi.py:\n    The main file. It provides two functions `npfi` and `get_pdfs_from_data`\n    It is independent from the rest of the files in the repository and should\n    be placed in the same directory as your code. If `deft.py` is available [2],\n    it will be able to use DEFT for the density estimation.\n\nfig2.py:\n    Reproduces Fig. 2 in [1] by simulating the data and computing the FI. Note: this does not use the same seed as the original plot in the publication.\n\nfig3.py:\n    Reproduces Fig. 3 in [1] by simulating the data and computing the FI. Note: this does not use the same seed as the original plot in the publication. (On my laptop the runtime with the parameters of the paper took around 3.9 hours).\n\nfig4.py:\n    Reproduces Fig. 4 in [1] by simulating the data and computing the FI. Note: this does not use the same seed as the original plot in the publication.\n\n\nCode\n----\nhttps://github.com/omrihar/1_npfi\n\nReferences\n----------\n[1] O. Har-Shemesh, R. Quax, B. Minano, A.G. Hoekstra, P.M.A. Sloot, Non-parametric\n        estimation of Fisher information from real data, (2015) arxiv:1507.00964[stat.CO]\n\n", 
  "id": 43250225
}
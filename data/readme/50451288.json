{
  "id": 50451288, 
  "read_at": 1462553043, 
  "README.rst": "Overview\n--------\n\nThe purpose of this package is to characterize network of optical\ncomponents when time delays with feedback are present. The core of the\npackage identifies 'trapped' optical modes that result from feedback in\nthe system. These modes are found by identifying the roots/poles of the\ntransfer function containing only time delays and passive linear\ncomponents. Further analysis of the network yields a linear Hamiltonian\nwritten in terms of the identified modes, linear operators coupling the\nsystem modes to the environment, and an overall scattering matrix.\nNonlinear elements are added as additional Hamiltonian terms.\n\nOur manuscript describing this method can be found on\nhttp://arxiv.org/abs/1510.08942 or\nhttp://www.epjquantumtechnology.com/content/3/1/3.\n\nInstallation\n------------\n\nSimply clone the repository, open a terminal window, type:\n\n::\n\n    cd /path/to/my/repo\n    python setup.py install\n\nFiles\n-----\n\nTime\\_Delay\\_Network.py\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module includes a class to contain the information of a passive\nlinear network with time delays. Several examples are included in this\nmodule. Each example includes matrices that yield a transfer function.\nThis module contains methods to re-construct finite-dimensional\napproximations of a transfer function of passive systems.\n--``run_Potapov()``: This function will run the Potapov procedure. The\ninstance of ``Time_Delay_Network`` will update its ``roots``, ``vecs``,\nand ``T_testing``. These are respectively the poles of the transfer\nfunction, a list of vectors (complex-valued column matrices) that\ncontain the information to reconstruct the matrix-valued projectors in\nthe Potapov representation, and an approximating transfer function that\nhas been generated using the Potapov interpolation procedure.\n\nPotapov.py\n~~~~~~~~~~\n\nWe implement the procedure for finding Blaschke-Potapov products to\napproximate given functions near poles. Please see section 6.2 in our\nmanuscript for details. This procedure is used to generate the modes of\nthe passive linear network.\n\nGiven a rational matrix-valued function, we also construct the matrices\nABCD that give the state-space representation of the system (see\n``get_Potapov_ABCD()``).\n\nRoots.py\n~~~~~~~~\n\nA module for identifying the zeros of a complex-valued function.\n\nfunctions.py\n~~~~~~~~~~~~\n\nMiscellaneous functions. Includes:\n\n--``Pade()`` Generate a Pade approximation for delays that do NOT feed\nback.\n\n--``spatial_modes()`` Finding the spatial location of modes. This is\nnecessary to generate nonlinear terms. The required inputs to\n``spatial_modes()`` are ``roots``,\\ ``M1``,and ``E``. These are\nrespectively the poles of the transfer function, the directed\nconnectivity matrix of the internal nodes of a network, and a diagonal\nmatrix-valued function whose diagonal values correspond to the delays in\nthe Fourier domain.\n\n--``make_nonlinear_interaction()`` Generate the weight of an interaction\nterm due to phase-matching.\n\nHamiltonian.py\n~~~~~~~~~~~~~~\n\nIncludes a class ``Hamiltonian()`` to contain the information needed to\nconstruct the Hamiltonian of the system, including nonlinear terms. This\nclass also includes a function ``make_eq_motion()`` to generate the\nclassical equations of motion from the nonlinear Hamiltonian.\n\nAlso includes a class ``Chi_nonlin()`` which contains the information\nfor a particular chi nonlinearity.\n\nTime\\_Sims.py\n~~~~~~~~~~~~~\n\nIntegrate the dynamics of a passive in time using the ABCD matrices.\n\nTime\\_Sims\\_nonlin.py\n~~~~~~~~~~~~~~~~~~~~~\n\n--``make_f_lin()`` generates outputs from ABCD model.\n\n--``make_f()`` generates outputs from nonlinear Hamiltonian model.\n\n--``run_ODE()`` integrates the equations of motion in time.\n\n--``double_up()`` prepares a doubled-up system which can be used for\nnon-classical simulations.\n\nSample Usage\n------------\n\n::\n\n    import Roots\n    import Potapov\n    import Time_Delay_Network\n    import Time_Sims_nonlin\n    import functions\n    import Hamiltonian\n\n    ## Make a sample Time_Delay_Network, changing some parameters.\n    X = Time_Delay_Network.Example3(r1 = 0.7, r3 = 0.7, max_linewidth=35.)\n\n    ## run the Potapov procedure.\n    X.run_Potapov()\n\n    ## Get the roots, modes, and delays from the Time_Delay_Network.\n    roots = X.spatial_modes\n    modes = X.roots\n    delays = X.delays\n\n    ## make an instance of Hamiltonian.\n    ham = Hamiltonian(roots,modes,delays,Omega = -1j*A_d))\n\n    ## Generated doubled-up ABCD matrices for the passive system.\n    A_d,B_d,C_d,D_d = X.get_Potapov_ABCD(doubled=True)\n\n    ## Add a chi nonlinearity to ham.\n    ham.make_chi_nonlinearity(delay_indices=0,start_nonlin=0,\n                                 length_nonlin=0.1,indices_of_refraction=1.,\n                                 chi_order=3,chi_function=None)\n\n    ## Make the Hamiltonian expression\n    ham.make_H()\n\n    ## Make the classical equation of motion\n    eq_mot = ham.make_eq_motion()\n    a_in = lambda t: np.asmatrix([1.]*np.shape(D_d)[-1]).T  ## make a sample input function\n\n    ## find f for the linear and nonlinear systems\n    f = Time_Sims_nonlin.make_f(eq_mot,B_d,a_in)\n    f_lin = Time_Sims_nonlin.make_f_lin(A_d,B_d,a_in)\n\n    ## Simulate the system.\n    Y_lin = Time_Sims_nonlin.run_ODE(f_lin, a_in, C_d, D_d, 2*M, T = 15, dt = 0.01)\n    Y_nonlin = Time_Sims_nonlin.run_ODE(f, a_in, C_d, D_d, 2*M, T = 15, dt = 0.01\n", 
  "description": ""
}
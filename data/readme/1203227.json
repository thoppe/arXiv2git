{
  "README": "= Lingo - A full-featured automatic indexing system\r\n\r\n* {Version}[rdoc-label:label-VERSION]\r\n* {Description}[rdoc-label:label-DESCRIPTION]\r\n  * {Introduction}[rdoc-label:label-Introduction]\r\n  * {Attendees}[rdoc-label:label-Attendees]\r\n  * {Filters}[rdoc-label:label-Filters]\r\n  * {Markup}[rdoc-label:label-Markup]\r\n  * {Inline annotation}[rdoc-label:label-Inline+annotation]\r\n  * {Plugins}[rdoc-label:label-Plugins]\r\n  * {Server}[rdoc-label:label-Server]\r\n    * {JSON endpoint}[rdoc-label:label-JSON+endpoint]\r\n    * {Raw endpoint}[rdoc-label:label-Raw+endpoint]\r\n    * {Deployment}[rdoc-label:label-Deployment]\r\n* {Example}[rdoc-label:label-EXAMPLE]\r\n* {Installation and Usage}[rdoc-label:label-INSTALLATION+AND+USAGE]\r\n  * {Dictionary and configuration file lookup}[rdoc-label:label-Dictionary+and+configuration+file+lookup]\r\n* {File formats}[rdoc-label:label-FILE+FORMATS]\r\n  * {Configuration}[rdoc-label:label-Configuration]\r\n  * {Language definition}[rdoc-label:label-Language+definition]\r\n  * {Dictionaries}[rdoc-label:label-Dictionaries]\r\n    * {Encoding word classes and gender information}[rdoc-label:label-Encoding+word+classes+and+gender+information]\r\n    * {Lexicalizing multiword expressions}[rdoc-label:label-Lexicalizing+multiword+expressions]\r\n    * {Lexicalizing compounds}[rdoc-label:label-Lexicalizing+compounds]\r\n* {Issues and Contributions}[rdoc-label:label-ISSUES+AND+CONTRIBUTIONS]\r\n* {Links}[rdoc-label:label-LINKS]\r\n* {Literature}[rdoc-label:label-LITERATURE]\r\n  * {Background and Theory}[rdoc-label:label-Background+and+Theory]\r\n  * {Research publications}[rdoc-label:label-Research+publications]\r\n* {Credits}[rdoc-label:label-CREDITS]\r\n  * {Authors}[rdoc-label:label-Authors]\r\n  * {Contributors}[rdoc-label:label-Contributors]\r\n* {License and Copyright}[rdoc-label:label-LICENSE+AND+COPYRIGHT]\r\n\r\n== VERSION\r\n\r\nThis documentation refers to Lingo version 1.8.7\r\n\r\n\r\n== DESCRIPTION\r\n\r\nLingo is an open source indexing system for research and teachings. The main\r\nfunctions of Lingo are:\r\n\r\n* identification of (i.e. reduction to) basic word form by means of dictionaries\r\n  and suffix lists\r\n* algorithmic decomposition\r\n* dictionary-based synonymization and identification of phrases\r\n* generic identification of phrases/word sequences based on patterns of word\r\n  classes\r\n\r\n=== Introduction\r\n\r\nLingo allows flexible and extendable linguistic analysis of text files. Here\r\nis a minimal configuration example to analyse this README file:\r\n\r\n  meeting:\r\n    attendees:\r\n      - text_reader: { files: 'README' }\r\n      - debugger:    { eval: 'true', ceval: 'cmd!=:EOL', prompt: '<debug>:  ' }\r\n\r\nLingo is told to invite two attendees and wants them to talk to each other,\r\nhence the name Lingo (= the technical language).\r\n\r\nThe first attendee is the text_reader[rdoc-ref:Lingo::Attendee::TextReader].\r\nIt can read files and communicates their content to other attendees. For this\r\npurpose, the +text_reader+ is given an output channel. Everything that the\r\n+text_reader+ has to say is steered through this channel. It will do nothing\r\nfurther until Lingo tells the first attendee to speak. Then the +text_reader+\r\nwill open the file +README+ (as per the +files+ parameter) and pass the content\r\nto the other attendees via its output channel.\r\n\r\nThe second attendee, debugger[rdoc-refLingo::Attendee::Debugger], does nothing\r\nelse than to put everything on the console (standard error) that comes into its\r\ninput channel. If you write the Lingo configuration which is shown above as an\r\nexample into the file <tt>readme.cfg</tt> and then run <tt>lingo -c readme -l en</tt>,\r\nthe result will look something like this:\r\n\r\n  <debug>:  *FILE('README')\r\n  <debug>:  \"= Lingo - [...]\"\r\n  ...\r\n  <debug>:  \"Lingo allows flexible and extendable linguistic analysis [...]\"\r\n  <debug>:  \"is a minimal configuration example to analyse this README [...]\"\r\n  ...\r\n  <debug>:  *EOF('README')\r\n\r\nWhat we see are lines beginning with an asterisk (<tt>*</tt>) and lines without.\r\nThat's because Lingo distinguishes between commands and data. The +text_reader+\r\ndid not only read the content of the file, but also communicated through the\r\ncommands when a file began and when it ended. This can (and will) be an\r\nimportant piece of information for other attendees that will be added later.\r\n\r\nTo try out Lingo's functionality without installing it first, have a look at\r\n{Lingo Web}[http://ixtrieve.fh-koeln.de/lingoweb]. There you can enter some\r\ntext and see the debug output Lingo generated -- including tokenization, word\r\nidentification, decomposition, etc.\r\n\r\n=== Attendees\r\n\r\nAvailable attendees that can be used for solving a specific problem (for more\r\ninformation see each attendee's documentation):\r\n\r\n+text_reader+::     Reads files (or standard input) and puts their content into\r\n                    the channels line by line. (see Lingo::Attendee::TextReader)\r\n+tokenizer+::       Dissects lines into defined character strings, i.e. tokens.\r\n                    (see Lingo::Attendee::Tokenizer)\r\n+abbreviator+::     Identifies abbreviations and produces the long form if\r\n                    listed in a dictionary. (see Lingo::Attendee::Abbreviator)\r\n+word_searcher+::   Identifies tokens and turns them into words for further\r\n                    processing. To this end, it consults the dictionaries.\r\n                    (see Lingo::Attendee::WordSearcher)\r\n+stemmer+::         Identifies tokens not identified by the +word_searcher+ by\r\n                    means of stemming. (see Lingo::Attendee::Stemmer)\r\n+decomposer+::      Tests any tokens not identified by the +word_searcher+ for\r\n                    being compounds. (see Lingo::Attendee::Decomposer)\r\n+synonymer+::       Extends words with their synonyms. (see\r\n                    Lingo::Attendee::Synonymer)\r\n+noneword_filter+:: Filters out everything and lets through only those tokens\r\n                    that are unknown. (see Lingo::Attendee::NonewordFilter)\r\n+vector_filter+::   Filters out everything and lets through only those tokens\r\n                    that are considered useful for indexing. (see\r\n                    Lingo::Attendee::VectorFilter)\r\n+object_filter+::   Similar to the +vector_filter+. (see\r\n                    Lingo::Attendee::ObjectFilter)\r\n+text_writer+::     Writes anything that it receives into a file (or to\r\n                    standard output). (see Lingo::Attendee::TextWriter)\r\n+formatter+::       Similar to the +text_writer+, but allows for custom output\r\n                    formats. (see Lingo::Attendee::Formatter)\r\n+debugger+::        Shows everything for debugging. (see\r\n                    Lingo::Attendee::Debugger)\r\n+variator+::        Tries to correct spelling errors and the like. (see\r\n                    Lingo::Attendee::Variator)\r\n+multi_worder+::    Identifies phrases (word sequences) based on a multiword\r\n                    dictionary. (see Lingo::Attendee::MultiWorder)\r\n+sequencer+::       Identifies phrases (word sequences) based on patterns of\r\n                    word classes. (see Lingo::Attendee::Sequencer)\r\n\r\nFurthermore, it may be useful to have a look at the configuration files\r\n<tt>lingo.cfg</tt> and <tt>en.lang</tt>.\r\n\r\n=== Filters\r\n\r\nLingo is able to read HTML, XML, and PDF in addition to plain text.\r\n\r\n_Examples_:\r\n\r\nRead any file, guessing the correct type automatically:\r\n\r\n  - text_reader:     { files: $(files), filter: true }\r\n\r\nRead HTML files specifically (accordingly for XML):\r\n\r\n  - text_reader:     { files: $(files), filter: 'html' }\r\n\r\nRead PDF files, either with the pdf-reader[http://rubygems.org/gems/pdf-reader]\r\ngem (default):\r\n\r\n  - text_reader:     { files: $(files), filter: 'pdf' }\r\n\r\nor with the pdftotext[http://en.wikipedia.org/wiki/Pdftotext] command line tool:\r\n\r\n  - text_reader:     { files: $(files), filter: 'pdftotext' }\r\n\r\n=== Markup\r\n\r\nLingo is able to, in a limited form, parse HTML/XML and\r\nMediaWiki[http://mediawiki.org/wiki/Help:Formatting] markup.\r\n\r\n_Examples_:\r\n\r\nIdentify HTML/XML tags in the input stream:\r\n\r\n  - tokenizer:       { tags: true }\r\n\r\nIdentify MediaWiki markup in the input stream:\r\n\r\n  - tokenizer:       { wiki: true }\r\n\r\n=== Inline annotation\r\n\r\nLingo is able to annotate input text inline, instead of printing results out\r\nof context to external files.\r\n\r\n_Example_:\r\n\r\n  # read files\r\n  - text_reader:   { files: $(files) }\r\n  # keep whitespace\r\n  - tokenizer:     { space: true }\r\n  # do processing...\r\n  - word_searcher: { source: sys-dic, mode: first }\r\n  # insert formatted results (e.g. \"[[Name::lingo|Lingo]] finds [[Noun::word|words]].\")\r\n  - formatter:     { ext: out, format: '[[%3$s::%2$s|%1$s]]', map: { e: Name, s: Noun } }\r\n\r\n=== Plugins\r\n\r\nLingo has a plugin system that allows you to implement additional features\r\n(e.g. add new attendees) or modify existing ones. Just create a file named\r\n+lingo_plugin.rb+ in your Gem's +lib+ directory or any directory that's in\r\n<tt>$LOAD_PATH</tt>. You can also define an environment variable\r\n+LINGO_PLUGIN_PATH+ (by default <tt>~/.lingo/plugins</tt>) with additional\r\ndirectories to load plugins from (<tt>*.rb</tt>).\r\n\r\nA dedicated API to support writing and integrating plugins will be added in\r\nthe future.\r\n\r\n=== Server\r\n\r\nLingo comes with a server daemon Lingo::Srv that exposes an HTTP interface to\r\nLingo's functionality. The configuration needs to ensure that input is read\r\nfrom standard input (<tt>files: STDIN</tt> on +text_reader+) and output is\r\nwritten to standard output (<tt>ext: STDOUT</tt> on +text_writer+).\r\n\r\n_Example_: Start Lingo server on port 6789 with language configuration +en+\r\nand default configuration file; server options come before <tt>--</tt>, Lingo\r\noptions come after.\r\n\r\n  > lingosrv -p 6789 -- -l en\r\n\r\nYou can also pass Lingo options through the +LINGO_SRV_OPTS+ environment\r\nvariable (e.g., <tt>LINGO_SRV_OPTS='-l en -c /path/to/your/srv.cfg'</tt>).\r\n\r\n==== JSON endpoint\r\n\r\n_Example_: Ask the server about \"Lingo server\"; returns JSON data (output\r\nformatted for clarity).\r\n\r\n  > curl 'http://localhost:6789/?q=Lingo+server'\r\n  {\r\n    \"Lingo server\" : [\r\n      \" <Lingo = [(lingo/s), (lingo/e)]>\",\r\n      \" <server = [(server/s)]>\"\r\n    ]\r\n  }\r\n\r\n_Example_: Ask the server about \"Lingo\" and \"server\"; returns JSON data (output\r\nformatted for clarity).\r\n\r\n  > curl -g 'http://localhost:6789/?q[]=Lingo&q[]=server'\r\n  {\r\n    \"[\\\"Lingo\\\", \\\"server\\\"]\" : {\r\n      \"Lingo\" : [\r\n        \" <Lingo = [(lingo/s), (lingo/e)]>\"\r\n      ],\r\n      \"server\" : [\r\n        \" <server = [(server/s)]>\"\r\n      ]\r\n    }\r\n  }\r\n\r\n==== Raw endpoint\r\n\r\n_Example_: Ask the server about \"Lingo server\"; returns raw Lingo response.\r\n\r\n  > curl --data 'Lingo server' http://localhost:6789/raw\r\n  <Lingo = [(lingo/s), (lingo/e)]>\r\n  <server = [(server/s)]>\r\n\r\n_Example_: Ask the server about this file; returns raw Lingo response (output\r\ntruncated for clarity).\r\n\r\n  > curl --data @README -H 'Content-Type: text/plain' http://localhost:6789/raw\r\n  :=/OTHR:\r\n  <Lingo = [(lingo/s), (lingo/e)]>\r\n  <-|?>\r\n  <A|?>\r\n  <full-featured|COM = [(full-featured/k), (full/s+), (full/a+), (full/v+), (featured/a+)]>\r\n  <automatic = [(automatic/s), (automatic/a)]>\r\n  <indexing = [(index/v)]>\r\n  <system = [(system/s)]>\r\n  [...]\r\n\r\n==== Deployment\r\n\r\nLingo::Srv can be started directly through the provided command-line executable\r\n+lingosrv+ (see above) or through any other Rack[http://rack.github.com/]\r\n-compatible deployment option; a +rackup+ file is included (see <tt>lingoctl\r\nrackup srv</tt>).\r\n\r\n_Example_: To deploy Lingo::Srv with Passenger[http://phusionpassenger.com/]\r\non Apache, create a symlink in the DocumentRoot pointing to the app's\r\n<tt>public/</tt> directory; adjust the paths according to your environment\r\n(you can use current_gem[http://blackwinter.github.com/current_gem] to\r\ncreate a stable gem path):\r\n\r\n  /var/www\r\n    |\r\n    +-- lingo-srv -> /usr/lib/ruby/gems/2.1.0/gems/lingo-x.y.z/lib/lingo/srv/public\r\n\r\nThen put the following snippet in Apache's VirtualHost configuration:\r\n\r\n  <VirtualHost *:80>\r\n    ...\r\n\r\n    RackBaseURI /lingo-srv\r\n    <Directory /var/www/lingo-srv>\r\n      Options -MultiViews\r\n      SetEnv LINGO_SRV_OPTS \"-l en\"  # <-- Optionally set Lingo options\r\n    </Directory>\r\n  </VirtualHost>\r\n\r\nIn order to provide your own +rackup+ file and Lingo configuration, create a\r\ndirectory with those files:\r\n\r\n  /srv/lingo-srv\r\n    |\r\n    +-- config.ru\r\n    |\r\n    +-- lingosrv.cfg\r\n\r\nAnd then point Passenger at it:\r\n\r\n  <VirtualHost *:80>\r\n    ...\r\n\r\n    RackBaseURI /lingo-srv\r\n    <Directory /var/www/lingo-srv>\r\n      Options -MultiViews\r\n      PassengerAppRoot /srv/lingo-srv  # <-- Add this line\r\n    </Directory>\r\n  </VirtualHost>\r\n\r\nRestart Apache and test the result (output formatted for clarity):\r\n\r\n  > curl http://localhost/lingo-srv/about\r\n  {\r\n    \"Lingo::Srv\" : {\r\n      \"version\" : \"x.y.z\"\r\n    }\r\n  }\r\n\r\n\r\n== EXAMPLE\r\n\r\nTODO: Full-fledged example to show off Lingo's features and provide a basis\r\nfor further discussion.\r\n\r\n\r\n== INSTALLATION AND USAGE\r\n\r\nSince version 1.8.0, Lingo is available as a\r\nRubyGem[http://rubygems.org/gems/lingo]. So a simple <tt>gem install lingo</tt>\r\nwill install Lingo and its dependencies. You might want to run that command\r\nwith administrator privileges, depending on your environment. Then you can call\r\nthe +lingo+ executable to process your text files. See <tt>lingo --help</tt>\r\nfor available options.\r\n\r\nPlease note that Lingo requires Ruby version 1.9.3 or higher to run\r\n(2.2.2[http://ruby-lang.org/en/downloads/] is the currently recommended\r\nversion).\r\n\r\nSince Lingo depends on native extensions, you need to make sure that\r\ndevelopment files for your Ruby version are installed. On Debian-based\r\nLinux platforms they are included in the package <tt>ruby-dev</tt>;\r\nother distributions may have a similarly named package. On Windows those\r\ndevelopment files are currently not required.\r\n\r\nOn JRuby, install gdbm[https://rubygems.org/gems/gdbm] for efficient database\r\noperations: <tt>gem install gdbm</tt>.\r\n\r\n=== Dictionary and configuration file lookup\r\n\r\nLingo will search different locations to find dictionaries and configuration\r\nfiles. By default, these are the current working directory, your personal Lingo\r\ndirectory (<tt>~/.lingo</tt>) and the installation directory (in that order).\r\nYou can control this lookup path by either moving files up the chain (using\r\nthe +lingoctl+ executable) or by setting various environment variables.\r\n\r\nWith +lingoctl+ you can copy dictionaries and configuration files from your\r\npersonal Lingo directory or the installation directory to the current working\r\ndirectory so you can modify them and they will take precedence over the\r\noriginal ones. See <tt>lingoctl --help</tt> for usage information.\r\n\r\nIn order to change the search path itself, you can define the\r\n+LINGO_PATH+ environment variable as a whole or its individual parts\r\n+LINGO_CURR+ (the local Lingo directory), +LINGO_HOME+ (your personal\r\nLingo directory), and +LINGO_BASE+ (the system-wide Lingo directory).\r\n\r\nInside of any of these directories, dictionaries and configuration files are\r\ntypically organized in the following directory structure:\r\n\r\n<tt>config/</tt>:: Configuration files (<tt>*.cfg</tt>).\r\n<tt>dict/</tt>::   Dictionary source files (<tt>*.txt</tt>) in\r\n                   language-specific subdirectories (+de/+, +en/+, ...).\r\n<tt>lang/</tt>::   Language definition files (<tt>*.lang</tt>).\r\n<tt>store/</tt>::  Compiled dictionaries, generated from source files.\r\n\r\nBut for compatibility reasons these naming conventions are not enforced.\r\n\r\n\r\n== FILE FORMATS\r\n\r\nLingo uses three different types of files to determine its behaviour:\r\n{configuration files}[rdoc-label:label-Configuration] control the details of the\r\nindexing process; {language definitions}[rdoc-label:label-Language+definition]\r\nspecify grammar rules and dictionaries available for indexing;\r\ndictionaries[rdoc-label:label-Dictionaries], finally, hold the\r\nvocabulary used in indexing the input text and producing the results.\r\n\r\n=== Configuration\r\n\r\nConfiguration files are defined in the YAML[http://yaml.org/] syntax. They\r\nspecify the attendees[rdoc-label:label-Attendees] to call in order and the\r\noptions to provide them with. The first attendee in any indexing process is\r\nthe text_reader[rdoc-ref:Lingo::Attendee::TextReader], who reads the input\r\ntext and passes it on to the other attendees. Every attendee transforms or\r\nextends the input stream and automatically sends everything down to the next\r\nattendee. This process may be customized by explicitly specifying the input\r\nand/or output channels of individual attendees with the +in+ and +out+ options.\r\n\r\n_Example_:\r\n\r\n  # input is taken from the previous attendee,\r\n  # output is sent to the named channel \"syn\"\r\n  - synonymer:     { skip: '?,t', source: sys-syn, out: syn }\r\n  \u0016\r\n  # input is taken from the named channel \"syn\",\r\n  # output is sent to the next attendee\r\n  - vector_filter: { in: syn, lexicals: y, sort: term_abs }\r\n  \u0016\r\n  # input is taken from the previous attendee,\r\n  # output is sent to the next attendee\r\n  - text_writer:   { ext: syn, sep: \"\\n\" }\r\n  \u0016\r\n  # input is taken from the named channel \"syn\"\r\n  # (ignoring the output of the previous attendee),\r\n  # output is sent to the next attendee\r\n  - vector_filter: { in: syn, lexicals: m }\r\n  \u0016\r\n  # input is taken from the previous attendee,\r\n  # output is sent to the next attendee\r\n  - text_writer:   { ext: mul, sep: \"\\n\" }\r\n\r\n=== Language definition\r\n\r\nLanguage definitions, like {configuration files}[rdoc-label:label-Configuration],\r\nare defined in the YAML[http://yaml.org/] syntax. They specify the\r\ndictionaries[rdoc-label:label-Dictionaries] to be used as well as the grammar\r\nrules according to which the input shall be processed. These settings do not\r\nnecessarily have to coincide with an existing language, they are\r\napplication-specific.\r\n\r\n=== Dictionaries\r\n\r\nDictionaries come in different varieties and encode the knowledge about the\r\nvocabulary used for indexing and analysis.\r\n\r\nSupported dictionary formats:\r\n\r\n+SingleWord+:: One word (projection) per line. E.g. <tt>open source</tt>. (see\r\n               Lingo::Database::Source::SingleWord)\r\n+MultiValue+:: Multiple words per line (separated with a unique symbol), all of\r\n               which are interpreted as belonging to a single equivalence class.\r\n               E.g. <tt>fax;telefax;facsimile</tt>. (see\r\n               Lingo::Database::Source::MultiValue)\r\n+MultiKey+::   Similar to +MultiValue+, except that the first word will be\r\n               treated as the preferred term (descriptor). E.g.\r\n               <tt>fax;telefax;facsimile</tt>. (see\r\n               Lingo::Database::Source::MultiKey)\r\n+KeyValue+::   One word and its associated projection per line, separated with\r\n               a unique symbol. E.g. <tt>abfrage*query</tt>. (see\r\n               Lingo::Database::Source::KeyValue)\r\n+WordClass+::  Similar to +KeyValue+, except that the projection may consist of\r\n               multiple lexicalizations, each with its own word class and\r\n               (optional) gender information. E.g. <tt>abort,abort #s|v</tt>,\r\n               which is equivalent to <tt>abort,abort #s abort #v</tt>. (see\r\n               Lingo::Database::Source::WordClass)\r\n\r\n==== Encoding word classes and gender information\r\n\r\nTODO...\r\n\r\n==== Lexicalizing multiword expressions\r\n\r\nTODO...\r\n\r\n==== Lexicalizing compounds\r\n\r\nTODO...\r\n\r\n\r\n== ISSUES AND CONTRIBUTIONS\r\n\r\nIf you find bugs or want to suggest new features, please report them\r\non GitHub[http://github.com/lex-lingo/lingo/issues]. Include your Ruby\r\nversion (<tt>ruby --version</tt>) and the version of Lingo you are using\r\n(<tt>lingo --version</tt>).\r\n\r\nIf you want to contribute to Lingo, please fork the project\r\non GitHub[http://github.com/lex-lingo/lingo] and submit a\r\n{pull request}[http://github.com/lex-lingo/lingo/pulls]\r\n(bonus points for topic branches).\r\n\r\nTo make sure that Lingo's tests pass, install hen[http://blackwinter.github.com/hen]\r\n(typically <tt>gem install hen</tt>) and all development dependencies (either with\r\n<tt>gem install --development lingo</tt> or manually; see <tt>rake gem:dependencies</tt>).\r\nThen run <tt>rake test</tt> for the basic tests or <tt>rake test:all</tt> for\r\nthe full test suite.\r\n\r\n\r\n== LINKS\r\n\r\nWebsite::       http://lex-lingo.de\r\nDemo::          http://lex-lingo.de/lingoweb\r\nDocumentation:: http://lex-lingo.de/doc\r\nSource code::   https://github.com/lex-lingo/lingo\r\nRubyGem::       https://rubygems.org/gems/lingo\r\nBug tracker::   https://github.com/lex-lingo/lingo/issues\r\nTravis CI::     https://travis-ci.org/lex-lingo/lingo\r\n\r\n\r\n== LITERATURE\r\n\r\n=== Background and Theory\r\n\r\n* Godert, W.; Lepsky, K.; Nagelschmidt, M.: <em>{Informationserschliessung und Automatisches Indexieren: ein Lehr- und Arbeitsbuch}[http://dx.doi.org/10.1007/978-3-642-23513-9]</em>. (German) Berlin etc.: Springer, 2012.\r\n* Lepsky, K.; Vorhauer, J.: <em>{Lingo - ein open source System fur die automatische Indexierung deutschsprachiger Dokumente}[http://dx.doi.org/10.1515/ABITECH.2006.26.1.18]</em>. (German) In: ABI Technik 26 (1), 2006. pp 18-29.\r\n* Nohr, H.: <em>{Grundlagen der automatischen Indexierung: ein Lehrbuch}[http://logos-verlag.de/cgi-bin/buch/isbn/0121]</em>. (German) Berlin: Logos, 2005.\r\n* Hausser, R.: <em>{Grundlagen der Computerlinguistik. Mensch-Maschine-Kommunikation in naturlicher Sprache}[http://zbmath.org/?q=an:0956.68141]</em>. (German) Berlin etc.: Springer, 2000.\r\n* Allen, J.: <em>{Natural language understanding}[http://zbmath.org/?q=an:0851.68106]</em>. (English) Redwood City, CA: Benjamin/Cummings, 1995.\r\n* Grishman, R.: <em>{Computational linguistics: an introduction}[http://cambridge.org/9780521310383]</em>. (English) Cambridge: Cambridge Univ. Press, 1986.\r\n* Salton, G.; McGill, M.: <em>{Introduction to modern information retrieval}[http://zbmath.org/?q=an:0523.68084]</em>. (English) New York etc.: McGraw-Hill, 1983.\r\n* Porter, M.: <em>{An algorithm for suffix stripping}[http://tartarus.org/~martin/PorterStemmer/]</em>. (English) In: Program 14 (3), 1980. pp 130-137.\r\n\r\n=== Research publications\r\n\r\n* Siebenkas, A.; Markscheffel, B.: <em>{Conception of a workflow for the semi-automatic construction of a thesaurus for the German printing industry}[https://zenodo.org/record/17945]</em>. (English) In: Re:inventing Information Science in the Networked Society. Proceedings of the 14th International Symposium on Information Science (ISI 2015), Zadar, Croatia, 19th-21st May 2015. Eds.: F. Pehar, C. Schlogl, C. Wolff. Gluckstadt: Verlag Werner Hulsbusch, 2015. pp 217-229\r\n* Grun, S.: <em>Bildung von Komposita-Indextermen auf der Basis einer algorithmischen Mehrwortgruppenanalyse mit Lingo</em>. (German) Koln: Fachhochschule Koln, 2015.\r\n* Bredack, J.; Lepsky, K.: <em>{Automatische Extraktion von Fachterminologie aus Volltexten}[http://dx.doi.org/10.1515/abitech-2014-0002]</em>. (German) In: ABI Technik 34 (1), 2014. pp 2-12.\r\n* Bredack, J.: <em>{Terminologieextraktion von Mehrwortgruppen in kunsthistorischen Fachtexten}[http://ixtrieve.fh-koeln.de/lehre/bredack-2013.pdf]</em>. (German) Koln: Fachhochschule Koln, 2013.\r\n* Maylein, L.; Langenstein, A.: <em>{Neues vom Relevanz-Ranking im HEIDI-Katalog der Universitatsbibliothek Heidelberg}[http://b-i-t-online.de/heft/2013-03-fachbeitrag-maylein.pdf]</em>. (German) In: b.i.t.online 16 (3), 2013. pp 190-200.\r\n* Godert, W.: <em>{Detecting multiword phrases in mathematical text corpora}[http://arxiv.org/abs/1210.0852]</em>. (English) arXiv:1210.0852 [cs.CL], 2012.\r\n* Jersek, T.: <em>{Automatische DDC-Klassifizierung mit Lingo: Vorgehensweise und Ergebnisse}[http://www.citeulike.org/user/klaus-lepsky/article/12476139]</em>. (German) Koln: Fachhochschule Koln, 2012.\r\n* Glaesener, L.: <em>{Automatisches Indexieren einer informationswissenschaftlichen Datenbank mit Mehrwortgruppen}[http://www.citeulike.org/user/klaus-lepsky/article/12476133]</em>. (German) Koln: Fachhochschule Koln, 2012.\r\n* Schiffer, R.: <em>{Automatisches Indexieren technischer Kongressschriften}[http://ixtrieve.fh-koeln.de/lehre/schiffer-2007.pdf]</em>. (German) Koln: Fachhochschule Koln, 2007.\r\n\r\n\r\n== CREDITS\r\n\r\nLingo is based on a collective development by Klaus Lepsky and John Vorhauer.\r\n\r\n=== Authors\r\n\r\n* John Vorhauer <mailto:lingo@vorhauer.de>\r\n* Jens Wille <mailto:jens.wille@gmail.com>\r\n\r\n=== Contributors\r\n\r\n* Klaus Lepsky <mailto:klaus@lepsky.de>\r\n* Jan-Helge Jacobs <mailto:plancton@web.de>\r\n* Thomas Muller <mailto:thomas.mueller@gesis.org>\r\n* Yulia Dorokhova <mailto:jdorokhova@hse.ru>\r\n\r\n\r\n== LICENSE AND COPYRIGHT\r\n\r\nCopyright (C) 2005-2007 John Vorhauer\r\nCopyright (C) 2007-2015 John Vorhauer, Jens Wille\r\n\r\nLingo is free software: you can redistribute it and/or modify it under the\r\nterms of the GNU Affero General Public License as published by the Free\r\nSoftware Foundation, either version 3 of the License, or (at your option)\r\nany later version.\r\n\r\nLingo is distributed in the hope that it will be useful, but WITHOUT ANY\r\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\nFOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\r\ndetails.\r\n\r\nYou should have received a copy of the GNU Affero General Public License along\r\nwith Lingo. If not, see <http://www.gnu.org/licenses/>.\r\n", 
  "read_at": 1462552207, 
  "description": "A full-featured automatic indexing system.", 
  "id": 1203227
}
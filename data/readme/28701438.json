{
  "read_at": 1462551834, 
  "description": "Python library for finite element exterior calclulus on arbitrary hermitian manifolds", 
  "README.md": "pyfeec is a discrete exterior calculus framework for Hermitian manifolds.\n\nPlease refer to http://arxiv.org/abs/1405.7879 for a full description.\n\n#Meshes\n\npyfeec provides three ways of triangulating an N dimensional cube:\n* Symmetric Grid\n* Asymmetric Grid\n* Random Mesh\n\n##Symmetric and Asymmetric Grids\n\nThe symmetric and asymmetric grid results in a mesh documented at http://arxiv.org/abs/1405.7879.\n\nTo create a(n) (a)symmetric, you will first need to create a dictionary of grid indices.\nThis is a dictionary that maps a set of coordinate indices (grid indices) to the index of the corresponding vertex (vertex indices).\nFor example, the origin's grid index would be (0,0,...,0), and might be mapped to the first vertex, vertex 0.\nOne step in the Nth direction would yeild a grid index of (0,0,...,1).\nThis might be mapped to vertex 1, and so on.\n\nUse pyfeec.grid_indices([M1, M2,..., MN]) to create a dictionary of grid indices for an M1xM2x...xMN grid.\n\n**Example**\n```python\nimport pyfeec\nshape = [4,5,3]\ngrid_indices = pyfeec.grid_indices(shape)\n```\n\nThe space can now be divided into simplices using the symmetric or asymmetric grid functions (pyfeec.symmetric_grid and pyfeec.grid respectively).\nIn the above example, a 4x5x3 grid is used.\n\n**Example**\n```python\nsymmetric_grid_simplices = pyfeec.grid(grid_indices)\nasymmetric_grid_simplices = pyfeec.asymmetric_grid(grid_indices)\n```\n\nBoth functions return a 2D numpy array of simplices. Each row is a list of vertex indices that forms a simplex.\n\n\n##Random Meshes\n\nRandom meshes are created without grid indices.\nInstead, pyfeec's random\\_mesh function takes the number of points on the interior of the mesh and the dimension of the mesh as arguements.\n\n**Example**\n```python\nvertices, stitches = pyfeec.random_mesh(150, 3)\n```\n\nIn the above example, the mesh will be 3 dimensional and have have 150 points on its interior. vertices is a 2D numpy array of coordinates.\nThe ith row gives the coordinates of the ith vertex. In the above usage, stitches will be an empty python dictionary.\nrandom_mesh can take a third argument for imposing periodic boundary conditions.\nThis will result in stitches becomming a nonempty dictionary and will be discussed in the next section.\n\nrandom\\_mesh can also take a keyword (or fourth argument), alpha. This parameter determines how close the points can be to each other. Statistically speaking, the points would be an average distance of N ^ (1 / dim) apart, wtih N being the number of points on the interior and dim being the dimension of the complex. random_mesh will ensure the points are no closer than alpha * N ^ (1 / dim) apart. alpha is set to 0.5 by default. Increasing alpha will increase the time it takes to randomly generate a suitable set of points.\n\n#Customizing Topology\n\nGiven a triangulated N dimensional cube, it possible to create any desired topology by gluing or \"stitching\" vertices together.\nWhen using pyfeec, these \"stitches\" are stored as a dictionary that maps vertex indices to the corresponding vertex indices they should be stitched to.\nTo create a torus for periodic boundary conditions, points on opposite sides of the grid are stitched together.\npyfeec comes with a function called pbc_stitches that creates the stitches necessary to impose periodic boundary conditions in any combination of directions.\n\n**Example**\n```python\nstitches = pyfeec.pbc_stitches(grid_indices, shape, [0, 2])\n```\n\nThe third argument is a list of (zero indexed) directions that should be periodic.\nIn the above example, the first and third directions are to be periodic. For random meshes, this list of directions is specified as a third argument.\n\n**Example**\n```python\nvertices, stitches = pyfeec.random_mesh(150, 3, [0, 2])\n```\n\n#Embedding the Vertices\n\nThe next step is choosing a coordinate system to embed the vertices.\n\n##Symmetric and Asymmetric Grids\nThe embed function is used to create a list of coordinates from grid indices.\n\n**Example**\n```python\nfrom numpy import linspace\ncoordinates = [linspace(0,1,s) for s in shape]\nvertices = pyfeec.embed(grid_indices, coordinates)\n```\n\nHere, coordinates are the coordinates of each N-1 dimensional hyperplane that discretizes your N dimensional cubic space. For example, say\n\n```python\nshape=[2, 3, 2]\n```\n\nA uniform mesh on the unit cube is generated with the following hyperplane coordinates:\n\n```python\n[\n [0, 1],\n [0, 0.5, 1],\n [0, 1]\n]\n```\n\nThis means that the x-axis is discretized with following coordinates:\nx=0, x=1\nThe y-axis is discretized with the following coordinates:\ny=0, y=0.5, y=1\nThe z-axis is discretized with the following coordinates:\nz=0, z=1\n\nSay there is more interesting phenomina near y=1. Then one might choose to use a nonuniform mesh with the following coordinates:\n\n```python\n[\n [0, 1],\n [0, 0.8, 1],\n [0, 1]\n]\n```\n\n##Random Meshes\nRandom meshes automatically embed vertices on the unit N-cube. The coordinates of these vertices are returned as shown below:\n\n```python\nvertices, stitches = pyfeec.random_mesh(150, 3, [0,2])\n```\n\n#Creating a Simplicial Complex\n\nSimplicial complexes are created with the SimplicialComplex class. It can be initialized as follows:\n\n```python\nsc = pyfeec.SimplicialComplex(simplices, vertices)\n```\n\nFor a customized topology, use\n\n```python\nsc = pyfeec.SimplicialComplex(simplices, vertices, stitches=stitches)\n```\n\n#Specifying a Metric\n\nBy default, the Euclidian metric is used.\nThe metric takes the form of a DxD hermitian matrix (for a D dimensional embedding) at each N-dimensional simplex (where N is the complex dimension). \nThis can be specified in the form of one of the following:\n\n* a MxDxD array: for a complex composed of M N-dimensional simplices.\n* a DxD array: for a homogeneous complex. This metric is assumed to be constant throughout the complex.\n* a D array: for a homogenous complex with a diagonal metric.\n\n#de Rham maps\nThe de Rham map returns a two element list containing the average of the input function over the domain of each simplex in the complex.\nSee http://arxiv.org/abs/1405.7879 for more on this process.\nIn general, the pyfeec's de Rham map uses a generalized trapeziodal rule.\nThe number of points sampled along each direction during this process is specified with the keyword, subdivisions.\n\n**Example** (the metric for polar coordinates)\n\n```python\nfrom numpy import asarray\ndef g(pt):\n    r, theta = pt\n    m = asarray([\n                 [1, 0],\n                 [0, r ** 2]\n                ], dtype=\"complex\")\n    return m\n    \nmetrics = pyfeec.derham_map(vertices[simplices], g, subdivision=3)\nsc = pyfeec.SimplicialComplex(simplices, vertices, stitches=stitches, metrics=metrics)\n```\n\n#Cohomological Operators\n\nSimplicial complexes are really a list of p-skeletons. Each p-skeleton computes and stores information related to the p-skeleton (set of p-simplicies) of the simplicial complex.\nThese properties are computed as needed--an idea borrowed from PyDEC.\nThe following properties are generally of the most interest:\n\n* exterior_derivative\n* star\n* inverse_star\n* codifferential = star dot exterior_derivative\n* laplace_beltrami = codifferential dot exterior_derivative\n* laplace_derham = laplace_beltrami + exterior_derivative dot codifferential\n\nAll operators are stored as a sparse csr_matrix (see scipy docs).\n\nFor example, the laplacian for scalar fields is given by:\n\n```python\nL_scalar = sc[0].laplace_beltrami\n```\n\nThe laplacian for vector fields is then given by:\n\n```python\nL_vector = sc[1].laplace_beltrami\n```\n\nAnd so on.\n\n#Sharpening a Differential Form\n\nEach p-skeleton has a method called sharpen that can be used to turn a differential p-form into a antisymmetric p-rank tensor field.\nGiven a p-form (stored as a one dimensional numpy array of coefficients of p-simplices), one can use sharpen as follows:\n\n```python\ntensor_field = sc[p].sharpen(p_form)\n```\n\nEach tensor in the tensor field is located at the barycenter of a corresponding N-simplex.\n\n#Visualizing Fields\n\npyfeec comes with two tools to visualize 2D fields. Tools for animating 2D fields to visualize 3D ones may come soon.\nTo visualize scalar fields, use the scalar_field2d function. This returns a matplotlib image of the field interpolated.\n\n**Example**\n```python\nfrom matplotlib.pylab import show \n\nbarycenters = sc.points.mean(1)\nscalar_field = sc[0].sharpen(form)\n\npyfeec.scalar_field2d(barycenters, scalar_field, 1000)\nshow()\n```\n\nThis will interpolate the scalar field over a 1000x1000 grid.\n\nSimilarly, one can use vector_field2d to visualize a vector field.\n\n**Example**\n```python\nfrom matplotlib.pylab import show \n\nbarycenters = sc.points.mean(1)\nvector_field = sc[1].sharpen(form)\n\npyfeec.vector_field2d(barycenters, vector_field, 20)\nshow()\n```\n", 
  "id": 28701438
}
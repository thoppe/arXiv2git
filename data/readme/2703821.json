{
  "read_at": 1462543299, 
  "description": "", 
  "README.md": "serf\n====\n\nCode your Interactors with policy protection.\n\nSerf (a Serf App) -- an individual rack-like call chain.\n* Interactors define your business logic\n* Policies decide access\n* Middleware augment the request processing\n\nSerf Map -- a set of Serfs.\n* A registry of Serfs, mapped by the parcel kinds.\n\nSerf Links\n----------\n\n* Source: https://github.com/byu/serf\n* Continuous Integration: https://travis-ci.org/byu/serf\n  * [![Build Status](https://secure.travis-ci.org/byu/serf.png)](http://travis-ci.org/byu/serf)\n* RubyGems: http://rubygems.org/gems/serf\n* RubyDocs: http://rubydoc.info/gems/serf\n\nInteractors\n-----------\n\nThe piece of work to be done. This takes in a request, represented by the\n\"Message\" within the given \"Parcel\", and returns an \"Event\" as its result.\nThe Interactor is the \"Domain Controller\" with respect to performing\nDomain Layer business logic in coordinating and interacting with\nthe Domain Layer's Model (Entities, Value Objects and Entity Gateways).\n\n1. Include the \"Serf::Interactor\" module in your class.\n2. Implement the 'call(parcel)' method.\n3. Return the tuple: (kind, message, headers)\n  a. The kind is the string representation of the message type,\n    This field is RECOMMENDED.\n  b. The message field provides detailed return data about the\n    interactor's processing. The main meat of the Domain Object.\n    Hashie::Mash is suggested for the message, nil is acceptable.\n  c. The headers are OPTIONAL. The headers are there primarily to return\n    out of band data about the processing of the request. For example,\n    the Interactor can return debug tags about connections to external\n    databases.\n    The *ONE* semantic relevant piece of information is that the\n    Interactor may specify the version the domain object, as represented\n    by the message of type 'kind', in the 'version' header field.\n  d. By default, returning nil for both kind and message will still\n    result in a response parcel signifying that some Interactor received\n    the inbound parcel. But that is just a almost worthless piece of\n    information for the observer.\n\nThe reason that the interactor SHOULD return a kind is to properly\nidentify the semantic meaning of the returned message, even if\nsaid returned message is empty. This also assists the handling\nof response parcels in other pipelines without the need to\nintrospect the parcel's message.\n\nExample:\n\n    require 'hashie'\n    require 'optser'\n\n    class MyInteractor\n      attr_reader :model\n\n      def initialize(*args, &block)\n        # Do some validation here, or extra parameter setting with the args\n        opts = Optser.extract_options! args\n        @model = opts :model, MyModel\n      end\n\n      def call(parcel)\n        # Do something w/ the message and opts.\n        # Simple data structures for the Interactor's \"Request\".\n\n        item = model.find parcel.message.model_id\n\n        # Make a simple data structure as the Interactor \"Response\".\n        response = Hashie::Mash.new\n        response.item = item\n        # Return the response 'kind' and the response data.\n        return 'my_app/events/did_something', response\n      end\n    end\n\n\nParcels\n-------\n\nA Parcel is just the package of Headers and Message. Serf's convention\nrepresents requests and responses as (mostly) just Plain Old Hash Objects\n(POHO as opposed to PORO) over the Boundaries (see Architecture Lost Years).\nThis simplifies marshalling over the network. It also gives us easier\nsemantics in defining Request and Responses without need of extra classes,\ncode, etc.\n\nThe Parcel in Ruby (Datastructure) is represented simply as a hash.\n\n* The *message* is stored in the \"message\" property of the parcel.\n* And  *header* fields exist in the top level namespace of the parcel.\n\nFor example,\n\n    {\n      kind: 'serf/messages/my_kind',\n      uuid: 'gvGshlXTEeKj-AQMzuOZ7g',\n      another_header_field: '123456',\n      message: {\n        # Some message object\n      }\n    }\n\nSerf *RESERVES* the following set of header names:\n\n* kind\n* version\n* message\n* uuid\n* parent_uuid\n* origin_uuid\n* serf_*\n\n*Messages* are the representation of a Business Request or Business Event.\n\nIn the parcel, the message is the business data. It specifies what\nbusiness work needs to be done, or what business was done.\nEverything that an Interactor needs to execute its Use Case SHOULD\nbe in the message.\n\n  RECOMMENDED: Use JSON Schema to validate the structure of a message.\n    https://github.com/hoxworth/json-schema\n    This can be implemented in the 'Policy' chain.\n\n*Headers* are the processing meta data that is associated with a Message.\n\nHeaders provide information that would assist in processing, tracking\na Message. But SHOULD NOT provide business relevant information to\nthe Interactor for it to process a Request or Event Message.\n\n*kind* field identifies the ontological meaning of the message, which\nmay be used to route messages over messaging channels to Interactors.\nThe convention is 'mymodule/requests/my_business_request' for Requests,\nand 'mymodule/events/my_business_event' for Events.\n\n*version* field MAY be used to identify the semantic version of the\n  message of the given 'kind'. The triplet of (kind, version, message)\n  constitutes the prime parts of domain object as represented by the\n  parcel. All other header fields are incidental data that pertain to\n  the processing. This field is optional, and is returned in the\n  headers portion of the interactor's return results.\n\n*UUIDs* are used to track request and events, providing a sequential\norder of execution of commands. Already Implemented by Serf middleware.\n\n* uuid - The identification of the specific parcel.\n* parent_uuid - The identification of the parcel that caused the current\n  parcel to be generated.\n* origin_uuid - The original parcel (request or event) that started\n  the chain of requests and event parcels to be generated from Interactors\n  processing.\n\nThe format of the UUIDs is Serf's `coded_uuid`. It is a URI safe base64\nstring encoded from a UTC timestamped Type 1 UUID. This allows for both\ngood uniqueness and timestamp auditing (if servers are network time synced).\n\n*serf headers* are prefixed with the \"serf_\" string. Example:\n\n    {\n      kind: 'my_lib/messages/my_kind',\n      serf_elapsed_time: 12034,\n      message: {\n      }\n    }\n\nApplications can add their own headers to parcels for application\nspecific tracking. Namespacing SHOULD be used.\n\nFor example,\n\n    {\n      kind: 'my_lib/messages/my_kind',\n      my_middleware: {\n        data_point_a: 1234\n      },\n      my_middleware_data_poing_b: 5678,\n      message: {\n      }\n    }\n\nExamples of other header uses:\n\n* Current User that sent the request. For authentication and authorization.\n* Host and Application Server that is processing this request.\n\nGenerally, the header information is populated only by the infrastructure\nthat hosts the Interactors. The Interactors themselves do not\nreturn any headers in the response. The Interactors are tasked to provide\nonly business relevant data in the Event messages they return.\n\nHowever, the full request parcel is given to the Interactors so the\nrequest's header information can be used to annotate subsequent\nchained requests to other Interactors. For example, the UUIDs in headers in\n\"Request A\" given to \"Interactor A\" can be used to generate new tracking\nUUID headers for \"Request B\" that is sent to \"Interactor B\". This allows\nus to track the origin point of any piece of processing request and event..\n\nNOTE: Hashie::Mash is *Awesome*. (https://github.com/intridea/hashie)\nNOTE: Serf passes the parcel as frozen Hashie::Mash instances\n  to Interactor' call method by default.\n\nPolicies\n--------\n\nSerf implements Policy Chains to validate, check the incoming Parcels before\nactually executing Interactors.\n\nExample Benefits:\n* Authorization to execute Command.\n* Validation of Message schema\n\nPolicies only need to implement a single method:\n\n    def check!(parcel)\n      raise 'Failure' # To fail the policy, raise an error.\n    end\n\n  RECOMMENDED: Use `Serf::Errors::PolicyFailure` error type.\n\n\nThread Safety\n-------------\n\nYes and No, it depends:\n* Serf Middleware and Serf Utils are all *Thread Safe* by default.\n  It may not be the case if thread unsafe options are passed in the\n  instantiation of these objects.\n* Built Serfs are *Thread Safe* **if** the developer took care\n  in the creation of the Interactors and in the dependency injection\n  wiring of the Serfs by the builder and loader.\n* The Builder and Loader are *Thread UNSAFE* because it just doesn't make\n  sense that multiple threads should compete/coordinate in the creation\n  and wiring of the created Serfs (Serf Apps) and Serf Maps.\n  This is usually done at start up by the main thread.\n  This includes the utility classes that the loader uses.\n\n\nReferences\n==========\n\nKeynote: Architecture the Lost Years, by Robert Martin\n  * http://confreaks.com/videos/759\n  * http://vimeo.com/43612849\n\nDomain Driven Design by Eric Evans:\n  * http://books.google.com/books?id=7dlaMs0SECsC&dq=domain+driven+design\n\nPatterns of Enterprise Application Architecture by Martin Fowler\n  * http://martinfowler.com/books/eip.html\n  * Command (Unit of Work) Pattern\n  * Event Sourcing\n\nEnterprise Integration Patterns by Hohpe and Woolf\n  * http://www.eaipatterns.com/\n\nDDD for Rails Developers Series:\n  * http://rubysource.com/ddd-for-rails-developers-part-1-layered-architecture/\n  * http://rubysource.com/ddd-for-rails-developers-part-2-entities-and-values/ \n  * http://rubysource.com/ddd-for-rails-developers-part-3-aggregates/\n\nDCI in Ruby\n  * Maybe use DCI to better manage business logic in Entities.\n  * http://mikepackdev.com/blog_posts/24-the-right-way-to-code-dci-in-ruby\n  * http://mikepackdev.com/blog_posts/35-dci-with-ruby-refinements\n  * http://nicksda.apotomo.de/2011/12/ruby-on-rest-2-representers-and-the-dci-pattern/\n\nCQRS\n  * http://www.udidahan.com/2009/12/09/clarified-cqrs/\n  * http://elegantcode.com/2009/11/11/cqrs-la-greg-young/\n  * http://elegantcode.com/2009/11/20/cqrs-the-domain-events/\n\nLife beyond Distributed Transactions: an Apostate's Opinion by Pat Helland\n  * http://www.ics.uci.edu/~cs223/papers/cidr07p15.pdf\n\nBuilding on Quicksand by Pat Helland\n  * http://arxiv.org/ftp/arxiv/papers/0909/0909.1788.pdf\n\nThe Domain Layer (from DDD):\n\n1. Entities (Model Entities)- What your application is.\n  * Also remember Value Objects.\n  * How your Domain Model is structured, but NOT necessarily tied to the\n    underlying storage infrastructure.\n  * http://rubysource.com/ddd-for-rails-developers-part-2-entities-and-values/\n2. Domain Controllers (Interactors) - What your application does.\n  * The business logic of coordinating different entities.\n    Different than a Rails controller.\n  * Keynote: Architecture The Lost Years\n    Robert Martin\n    Ruby Midwest 2011\n    http://confreaks.com/videos/759\n  * Your Rails Application is Missing a Domain Controller\n    Nicholas Henry\n    http://blog.firsthand.ca/2011/12/your-rails-application-is-missing.html\n3. There is a balancing game of what business logic code lives in an\n    Entity vs a Domain Controller... Do what works for you.\n    But mostly follow \"Use Cases\" in Domain Controllers,\n    and \"Application Agnostic Logic\" in Entities.\n\n\nSerf Builder Example\n====================\n\n    # Require our libraries\n    require 'json'\n    require 'yell'\n\n    require 'serf/builder'\n\n    # create a simple logger for this example\n    my_logger = Yell.new STDOUT\n\n    # my_lib/my_policy.rb\n    class MyPolicy\n\n      def check!(parcel)\n        raise 'Policy Error: User is nil' unless parcel.current_user\n      end\n\n    end\n\n    # my_lib/my_interactor.rb\n    class MyInteractor\n\n      def call(parcel)\n        raise 'Error' if parcel.message.raise_an_error\n\n        # And return a message as result. Nil is valid response.\n        return 'my_lib/events/success_event',\n          { success: true },\n          { version: \"1.2.3\" }\n\n        # Optionally just return the kind\n        # return 'my_lib/events/success_event'\n      end\n\n    end\n\n    # Create a new builder for this Serf (aka Serf App).\n    serf = Serf::Builder.new(\n      interactor: MyInteractor.new,\n      policy_chain: [\n        MyPolicy.new\n      ]).to_app\n\n    # This will submit a 'my_message' message (as a hash) to Serfer.\n    # Missing data field will raise an error within the interactor, which\n    # will be caught by the serfer.\n    results = serf.call nil\n    my_logger.info \"Call 1: #{results.to_json}\"\n\n    # Here is good result\n    results = serf.call(\n      current_user: 'user_info_1',\n      message: {\n      })\n    my_logger.info \"Call 2: #{results.to_json}\"\n\n    # Here get an error that was raised from the interactor\n    results = serf.call(\n      current_user: 'user_info_1',\n      message: {\n        raise_an_error: true\n      })\n    my_logger.info \"Call 3: #{results.to_json}\"\n\n\nSerf Loader Example\n===================\n\nLook inside the example subdirectory for the serf files in this example.\n\n\n    ####\n    ## File: example/serfs/create_widget.serf\n    ####\n\n    require 'json'\n    # require 'subsystem/commands/my_create_widget'\n    # Throwing in this class definition to make example work\n    class MyCreateWidget\n\n      def initialize(logger, success_message)\n        @logger = logger\n        @success_message = success_message\n      end\n\n      def call(parcel)\n        @logger.info \"In My Create Widget, creating a widget: #{parcel.to_json}\"\n        return 'subsystem/events/mywidget_created',\n          { success_message: @success_message }\n      end\n    end\n\n    ##\n    # Registers a serf that responds to a parcel with the given request \"kind\".\n    # The interactor is instantiated by asking for other components in the\n    # registry and for parameters set in the environment variable.\n    registry.add 'subsystem/requests/create_widget' do |r, env|\n      serf interactor: MyCreateWidget.new(r[:logger], env[:success_message])\n    end\n\n\n    ####\n    ## In another ruby script, where we may load and use serfs.\n    ####\n\n    require 'hashie'\n    require 'json'\n    require 'yell'\n\n    require 'serf/loader'\n\n    # Making a logger for the top level example\n    logger = Yell.new STDOUT\n\n    # Globs to search for serf files\n    globs = [\n      'example/**/*.serf'\n    ]\n    # The serf requests that the loaded Serf Map will handle.\n    serfs = [\n      'subsystem/requests/create_widget'\n    ]\n    # A simple environment variables hash, runtime configuration\n    env = Hashie::Mash.new(\n      success_message: 'Some environment variable like redis URL'\n    )\n\n    # Loading the configuration, creating the serfs.\n    serf_map = Serf::Loader.serfup globs: globs, serfs: serfs, env: env\n\n    # Make an example request parcel\n    request_parcel = {\n      kind: 'subsystem/requests/create_widget',\n      message: {\n        name: 'some widget name'\n      }\n    }\n\n    #\n    # Look up the create widget serf by a request kind name,\n    # execute the serf, and log the results\n    serf = serf_map[request_parcel[:kind]]\n    results = serf.call request_parcel\n    logger.info results.to_json\n\n\nContributing\n============\n\n1. Fork it\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create new Pull Request\n\nCopyright\n=========\n\nCopyright (c) 2011-2012 Benjamin Yu. See LICENSE.txt for further details.\n\n", 
  "id": 2703821
}
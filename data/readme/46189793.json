{
  "read_at": 1462554820, 
  "description": "An erlang implementation of MAP-Elites ", 
  "README.md": "# Meridian\n\nMeridian is an Erlang implementation of the MAP-Elites algorithm\nand a library for building programs that use MAP-Elites.\n\n## MAP-Elites\n\nMAP-Elites is an algorithm for mapping the \"performance\" of a genome\nthat describes the solution to a problem according to the phenotypic\ndescriptors of the genome. This is a bad description - The draft paper\nis here (http://arxiv.org/abs/1504.04909).\n\n## Rationale\n\n1. I wanted to write something non-trivial in erlang\n2. MAP-Elites is cool\n3. MAP-Elites benefits from concurrency and parallelism\n\n## How it works\n\n### Version 1\n\nMapElites is defined as an OTP Behavior. In order to use it a module declasres \n```erlang\n-behavior(map_elites).\n```\nand implements all of the required callbacks (described below). To run the algorithm \nthe function `map_elites:start/4` is called.\n\nWhen the algorithm starts there is a master process which does no work\nexcept to track the total number of iterations and terminate the workers \nwhen enough have been performed. At that point the master loads the \nvisualization. All workers share access to an ETS table where they write \nthe results of their evaluations and drawn new genomes for mutation and evaluation.\n\nWhen workers receive a stop message from the master, they terminate. \nNote that there is no guarantee that they will not do more iterations \nthan are required, in fact it is likely that they will overrun by at least\none iteration. At worst the number of extra iterations that are performed \n_should_ be only the number of workers. \n\nThe interface for starting a `map_elites` behavior is shown below.\n\n```erlang\n-spec start(Callbacks :: module(), \n            InitailPopulationSize :: integer(), \n            NumWorkers :: integer(), \n            Options :: list({atom(), term()})) -> ok.\n```\n\nPossible options are:\n\nOption      | Description                               | default\n------      | -----------                               | ----\nname        | the name of the table that stores the map | `'unnamed_mape'`\ngranularity | the granularity of the map                | `256`\niterations  | the number of iterations (may be greatter)| `5000`\n\n### Dependencies\n\nYou must have gnuplot installed and in your path for the visualization to work.\nI think the output from the wx terminal looks better tha the qt terminal, so \nif you have that as the default terminal you will probably be happier.\n\n### Usage\nUsers write a module that defines the following callbacks to implement\nthe `map_elites` behavior.\n\n```erlang\n-type genotype()  :: term().\n-type phenotype() :: {genotype(), term()}.\n\n%% return a random genome.\n-callback init() -> genotype().\n%% evaluate a genome and return the phenotype.\n-callback evaluate(Genome :: genotype()) -> {ok, phenotype()}.\n%% mutate a genome.\n-callback mutate(Genome :: genotype()) -> genotype().\n%% true if the phenotype A has \"better fitness\" than B.\n-callback compare(A :: phenotype(), B :: phenotype()) -> boolean().\n%% given a phenotype return the objective value.\n-callback objective(phenotype()) -> float().\n%% behavior descriptors must be non-negative.\n-callback to_behavior(phenotype()) -> list(float()).\n%% The returned tuples {A, B} must satisfy A < B furthermore the space\n-callback behavior_space() -> list({float(), float()}).\n```\n\n#### Building\nTo build use rebar3 (http://github.com/rebar/rebar3).\n\n```\n$ rebar3 compile\n```\n\nThis will compile all of the modules needed for writing a program\nwith Meridian and put them in a really annoying place (at some boint\nthe build system will be better, and the place will be less\nannoyting).\n\nIn order to compile and run the examples (or your own modules) you\nwill need to add the directory that contains the `map_elites` behavior\nto the code path (shown below).\n\n```\n$ erl\n> code:add_path(\"/path/to/Meridian/_build/default/lib/Meridian/ebin\").\n> c('examples/knapsack'). % or whatever\n```\n\n#### TODO\n[x] Need a faster way to lookup a random genome from the map. Currently this process is \n    O(n^d) where n is the granularity of the map and d is the dimensionality of the behavior space.\n    It turns out that random lookups in an\n    ETS table are not so straight forward and the simplest solution is to treat it like \n    a random lookup in a linked list.\n\n**Concurrency**\n    \n[x] Workers update the map concurrently\n\n[ ] Distribute workers across multiple nodes.\n\n**Utilities**\n\n[x] Binary genomes\n\n[ ] Crossover and selection (? select N cells at random, chose the\n\"fittest one\" and select the fittest neighbor -- out of eight\nneighboring cells to use for xover).\n\n**Visualization**\n\n[x] Viz of the resulting matrix\n\n[x] Faster viz\n\n[ ] Visualize progress as the algorithm runs\n\n**Results**\n\n[ ] Reporting the elites at the end of the run.\n\n[ ] Save lineages\n\n\n\n\n", 
  "id": 46189793
}
{
  "read_at": 1462551853, 
  "description": "Codes to generate limb-darkening coefficients using arbitrary response functions as explained in Espinoza & Jordan (2015)", 
  "README.md": "# limb-darkening\n\nThis repository stores codes to generate limb-darkening coefficients using arbitrary response functions. \n\nThis code assumes you don't have the ATLAS and PHOENIX model atmospheres in your system, so it downloads \nthem depending on your specific needs. However, if you already have models, you can create a new folder \ncalled \"atlas_models/raw_models\" for ATLAS and \"phoenix_models/raw_models\" for PHOENIX.\n\nIf you use this code for your research, please consider citing Espinoza & Jordan (2015; http://arxiv.org/abs/1503.07020).\n\nDEPENDENCIES\n------------\n\nThis code makes use of three important libraries:\n\n\t+ Numpy.\n\t+ Scipy.\n\t+ Pyfits.\n\nAll of them are open source and can be easily installed in any machine. Furthermore, \nit makes use of wget to download the model atmospheres needed for your specific needs.\n\nUSAGE\n-----\n\nBefore running the code, you must generate a file in the \"input_files\" directory with \nthe following input data separated by tabs or spaces (see the \"input_files\" folder for \nan example input file):\n\n    Name:         Target name.\n\n    Teff:         Effective temperature of the target star.\n\n    log(g):       Logarithm of the gravity of the star.\n\n    M/H:          Metallicity of the star. It is usually safe to assume it is ~[Fe/H].\n\n    Vturb:        Microturbulent velocity (km/s). If not known, set this to -1, which \n                  will define it to be 2 km/s.\n\n    RF:           RF stands for the Response Function. Input values can be:\n\n                  KpHiRes  : Kepler HIRES\n                  KpLowRes : Kepler LOWRES\n                  IRAC1    : Spitzer IRAC1\n                  IRAC2    : Spitzer IRAC2\n\n                  It can also be a filename, in which case the response function\n                  with that filename must be in the \"response_functions\" folder. \n                  e.g., if RF is set to my_response_function.dat, the file \n                  my_response_function.dat must be in the \"response_functions\" \n                  folder, where the first column must be the wavelength *IN \n                  ANGSTROMS* and the second column the response.\n\n    FT:           FT stands for Fitting Technique. Input values have to be one of \n                  the following:\n\n                  A17:  LDs using ATLAS with all its 17 angles\n                  A100: LDs using ATLAS models interpolating 100 mu-points with a \n                        cubic spline (i.e., like Claret & Bloemen, 2011)\n                  AS:   LDs using ATLAS with 15 angles for linear, quadratic and \n                        three-parameter laws, bit 17 angles for the non-linear \n                        law (i.e., like Sing, 2010)\n                  P:    LDs using PHOENIX models (Husser et al., 2013).\n                  PS:   LDs using PHOENIX models using the methods of Sing (2010).\n                  PQS:  LDs using PHOENIX quasi-spherical models (mu>=0.1 only)\n                  P100: LDs using PHOENIX models and interpolating 100 mu-points \n                        with cubic spline (i.e., like Claret & Bloemen, 2011)\n\n\n                  All the PHOENIX limb-darkening coefficients are calculated in \n                  order to be comparable to plane-parallel models (see Section \n                  2.2 in Espinoza & Jordan, 2015).\n\n                  You can indicate various fitting techniques at the same time per \n                  target. For example, if for one target you want all the methods \n                  to be calculated, just put:  A17,A100,AS,P in that column.\n\t\n    min_w:        Minimum wavelength of the bin you wish to integrate. If set to \n                  -1, all the filter passband will be integrated.\n\n    max_w:        Maximum wavelength of the bin you wish to integrate. If set to \n                  -1, all the filter passband will be integrated.\n\nAfter this is done, you can edit the options in the get_lds.py file in order to define with which \ninput file you want to run the code, the output filename (that will be stored in the \"results\" \nfolder, see below) and some optional definitions. After all this is done, you simply run:\n\n\t\tpython get_lds.py\n\nAnd the code will calculate the limb-darkening coefficients for the targets defined in the \ninput file. If you automatize the creation of the input filename, you can run everything \ndirectly from terminal by running:\n\n                python get_lds.y -ifile input_filename -ofile output_filename\n\nWhere input_filename is the location of your input filename (e.g., /home/myfolder/input_file.dat), \nand output_filename is the name of the file that will be saved under the \"results\" folder.\n\nOUTPUTS\n-------\n\nThe code will generate limb-darkening coefficients for the given targets in the \ninput file under the \"results\" folder. Each file has a description for each column; see \nthe example files in that folder for an example output.\n\n\nFrequently Asked Questions (FAQ)\n--------------------------------\n\nQ: *Why are you not including my favorite bandpass (e.g., ugriz, UBVRI) in the \"Standard\" response functions?*\n\nA: This is because the actual response function of your favorite instrument depends not only on the filter being used, \n   but also on the properties of the mirrors, lenses, etc. being used by your favorite instrument. The \n   \"Standard\" response functions, on the other hand, have all that in consideration in the final response \n   function curves given here. Although some authors have decided to assume some coatings of the mirrors being \n   used and using that provide response functions for some of the most common filters, we have decided not to \n   do this in order to force the users to measure or ask for the real response functions being measured by \n   the different instrument being used, which can dramatically affect the final limb-darkening coefficients.\n\nQ: *Why are the HST bandpasses not in the repository anymore?*\n\nA: Because the updated versions can be obtained via PySynphot (http://ssb.stsci.edu/pysynphot/docs/index.html). \n   Furthermore, those vary with time, so the response function that you should use is the one corresponding to \n   the dates of your observations!\n", 
  "id": 30085925
}
{
  "read_at": 1462543898, 
  "description": "Fast, minimal memory, consistent hash algorithm", 
  "README.md": "# Jump Consistent Hash\n\n[![Build Status](https://travis-ci.org/renstrom/python-jump-consistent-hash.svg?branch=master)](https://travis-ci.org/renstrom/python-jump-consistent-hash)\n\nPython implementation of the jump consistent hash algorithm by John Lamping and\nEric Veach[1]. Tested on Python 2.6, 2.7, and 3.3+.\n\n[1] http://arxiv.org/pdf/1406.2294v1.pdf\n\n## Usage\n\n```python\n>>> import jump\n>>> jump.hash(256, 1024)\n520\n```\n\nOr if you want to use the C++ extension:\n\n```python\n>>> jump.fasthash(256, 1024)\n520\n```\n\nIf you want to use a `str` as a key instead of an `int`, you can pass it\nthrough a hash function to compute a real key. Here's a couple of examples\nusing Python 3:\n\n```python\n>>> import hashlib\n>>> int(hashlib.md5(b'127.0.0.1').hexdigest(), 16)\n325870950296970981340734819828239218902\n\n>>> int(hashlib.sha1(b'127.0.0.1').hexdigest(), 16)\n431133456357828263809343936597625557575256328153\n\n>>> import binascii\n>>> binascii.crc32(b'127.0.0.1') & 0xffffffff\n3619153832\n\n>>> abs(hash('127.0.0.1'))\n7536019783825143230\n```\n\n## Benchmarks\n\nHere's some benchmarks comparing the pure Python solution vs the C++ extension.\nInterestingly, the pure Python solution running on PyPy is almost as fast as\nthe C++ variant on CPython. These benchmarks were run on my mid 2013 MacBook\nAir, so take it with a grain of salt.\n\n**CPython 3.4.3**\n\n```python\n>>> timeit.timeit('import jump; jump.hash(256, 1024)', number=1000000)\n8.3571082999988\n>>> timeit.timeit('import jump; jump.fasthash(256, 1024)', number=1000000)\n0.748130168998614\n```\n\n**PyPy 3.2.5**\n\n```python\n>>>> timeit.timeit('import jump; jump.hash(256, 1024)', number=1000000)\n1.1917212009429932\n>>>> timeit.timeit('import jump; jump.fasthash(256, 1024)', number=1000000)\n4.380352973937988\n```\n\n## License\n\nMIT\n", 
  "id": 32383240
}
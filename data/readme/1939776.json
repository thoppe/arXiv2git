{
  "read_at": 1462510569, 
  "description": "Computing with matrix factorisations", 
  "README.md": "# mf\n\nThis project is a Singular library for computing with [matrix factorisations](https://ncatlab.org/nlab/show/matrix+factorization), mathematical objects appearing in singularity theory and topological field theory. Features include:\n\n* Computing Khovanov-Rozansky knot homology (`linkhom.lib`)\n* Fusion of defects in Landau-Ginzburg models (`blow.lib`,`mfweb.lib`)\n* Moduli spaces of matrix factorisations (`moduli.lib`) \n\nThe code was written by [Nils Carqueville](http://nils.carqueville.net/) and [Daniel Murfet](http://therisingsea.org) as part of the paper \"[Computing Khovanov-Rozansky homology and defect fusion](http://arxiv.org/abs/1108.1081)\". Other contributors are most welcome! If you have any questions, please don't hesitate to [get in touch](mailto:d.murfet@unimelb.edu.au).\n\n# Installation & Usage\n\nFirst you need a working installation of the commutative algebra package [Singular](https://www.singular.uni-kl.de/). Singular is available for Linux, Windows and Mac OS X and is [easy to install](https://www.singular.uni-kl.de/index.php/singular-download.html). Then you should either clone this git repository onto your local machine, or [download it as a ZIP file](https://github.com/dmurfet/mf/archive/master.zip).\n\nFrom within the folder containing this repository, run `Singular`. You will see a welcome screen like this:\n\n```\n                     SINGULAR                                 /\n A Computer Algebra System for Polynomial Computations       /   version 4.0.1\n                                                           0<\n by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \\   Sep 2014\nFB Mathematik der Universitaet, D-67653 Kaiserslautern        \\\n```\n\nAt this point you can start cutting and pasting into the Singular shell from the files in the folder `examples` of this repository. In `examples/examples.txt` and `examples/blow-example.txt` you will find examples relating to defect fusion (i.e. functors between categories of matrix factorisations) while in `examples/linkhom-example.txt` you will find examples of Khovanov-Rozansky homology calculations.\n\nHere is an extract from `examples.txt` which shows the canonical way to compute fusions using the library:\n\n```\n////////////////////////////////////////////////\n// Example of defect fusion using webCompilePair\n////////////////////////////////////////////////\n\n// For the fusion of defects with boundary conditions, or defect-defect fusion\n// (i.e. convolution of matrix factorisation \"kernels\") we use webCompilePair,\n// which takes as input an oriented graph (called a \"web\") whose edges are\n// decorated with potentials (i.e. the equation of an isolated singularity) and\n// whose vertices are decorated with matrix factorisations. The output is a finite\n// rank matrix factorisation homotopy equivalent to the \"total factorisation\" of\n// the web. All these terms are defined more precisely in the preamble of mfweb.lib\n// and the paper arXiv: 1108.1081, but let us proceed to the example.\n//\n// The web has two vertices (marked with X,Y) and two edges (marked x^3, y^5)\n//\n//    X ---- x^3 ----> Y ---- y^5 ---->\n//\n// Here the second edge (labelled with y^5) goes to the boundary.\n//\n// For this to be a valid web, Y needs to be a matrix factorisation of y^5 - x^3\n// (i.e. outgoing potential minus incoming potential) while X needs to be a matrix\n// factorisation of x^3. The total factorisation is Y \\otimes X, as a matrix\n// factorisation of y^5 over the variables y. This is infinite rank but is\n// homotopy equivalent to a finite rank matrix factorisation.\n//\n// This finite rank matrix factorisation is, by definition, the image of\n// X \\in hmf(x^3) under the functor hmf(x^3) --> hmf(y^5) induced\n// by the kernel Y. Let us compute this finite rank guy now. Then we will move\n// onto more complicated examples.\n\noption(noredefine);option(noloadLib);option(redSB);\nLIB \"mfweb.lib\";\nring rr=0,(x,y),dp;\n\n// We encode the web given above as a pair of edges, and a pair of vertices.\n// Format for an edge is (source, target, variable, potential). Start indexing\n// your vertices at 1, since 0 stands for the boundary.\nlist e1 = list(1,2,list(x),x^3);\nlist e2 = list(2,0,list(y),y^5);\nlist edgeList = list(e1,e2);\n\n// Now define the mfs X,Y to be placed at each vertex \nmatrix X[2][2] = 0, x^2, x, 0;\n\nmatrix Y0[2][2] = -x, y, -y^4, x^2;\nmatrix Y1[2][2] = x^2, -y, y^4, -x;\nmatrix z[2][2];\nmatrix Y = blockmat(z,Y1,Y0,z);\n\nlist mfs = X, Y;\n\n// Define the web\nlist web = list(2, edgeList, mfs); // 2 for the number of vertices\nwebVerify(web);\n\n// The compilation of this web is the fusion of Y with X. \nlist compStrat = defaultCompStratForWeb(web);\nlist L = webCompilePair(web, compStrat);\nprint(L[1]);\n\n// The answer is a direct sum of two copies of the Koszul factorisation (y,y^4)\n```\n\nFor an explanation of the mathematics behind this code, see [Dyckerhoff-Murfet](http://arxiv.org/abs/1102.2957) and [Murfet](http://arxiv.org/abs/1402.4541). There is also extensive documentation within the libraries themselves, see `blow.lib`, `mfweb.lib` and `linkhom.lib`.", 
  "id": 1939776
}
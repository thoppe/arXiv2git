{
  "read_at": 1462554155, 
  "description": "Command line tool to select elements from large XML files, fast.", 
  "README.md": "README\n======\n\n> The game ain't in me no more. [None of it](https://www.youtube.com/watch?v=h7yf8Vp2KAI&feature=youtu.be&t=1m46s).\n\nxmlcutty is a simple tool for carving out elements from *large* XML files,\n*fast*. Since it works in a streaming fashion, it uses almost no memory and\ncan process around 1G of XML per minute.\n\nWhy? [Background](http://stackoverflow.com/q/33653844/89391).\n\nInstall\n-------\n\nUse a deb or rpm [release](https://github.com/miku/xmlcutty/releases). It's in\n[AUR](https://aur.archlinux.org/packages/?K=xmlcutty), too.\n\nOr install with the go tool:\n\n    $ go get github.com/miku/xmlcutty/cmd/xmlcutty\n\nUsage\n-----\n\n```sh\n$ cat fixtures/sample.xml\n<a>\n    <b>\n        <c></c>\n    </b>\n    <b>\n        <c></c>\n    </b>\n</a>\n```\n\nOptions:\n\n```sh\n$ xmlcutty -h\nUsage of xmlcutty:\n  -path string\n        select path (default \"/\")\n  -rename string\n        rename wrapper element to this name\n  -root string\n        synthetic root element\n  -v    show version\n```\n\nIt *looks* a bit like [XPath](https://en.wikipedia.org/wiki/XPath), but it really\nis only a simple matcher.\n\n```sh\n$ xmlcutty -path /a fixtures/sample.xml\n<a>\n    <b>\n        <c></c>\n    </b>\n    <b>\n        <c></c>\n    </b>\n</a>\n```\n\nYou specify a path, e.g. `/a/b` and all elements matching this path are printed:\n\n```sh\n$ xmlcutty -path /a/b fixtures/sample.xml\n<b>\n    <c></c>\n</b>\n<b>\n    <c></c>\n</b>\n```\n\nYou can end up with an XML document without a root. To make tools like\n[xmllint](http://xmlsoft.org/xmllint.html) happy, you can add a\nsynthetic root element on the fly:\n\n```sh\n$ xmlcutty -root hello -path /a/b fixtures/sample.xml | xmllint --format -\n<?xml version=\"1.0\"?>\n<hello>\n    <b>\n        <c></c>\n    </b>\n    <b>\n        <c></c>\n    </b>\n</hello>\n```\n\nRename wrapper element - that is the last element of the matching path:\n\n```sh\n$ xmlcutty -rename beee -path /a/b fixtures/sample.xml\n<beee>\n    <c></c>\n</beee>\n<beee>\n    <c></c>\n</beee>\n```\n\nAll options, synthetic root element and a renamed path element:\n\n```sh\n$ xmlcutty -root hi -rename ceee -path /a/b/c fixtures/sample.xml | xmllint --format -\n<?xml version=\"1.0\"?>\n<hi>\n    <ceee/>\n    <ceee/>\n</hi>\n```\n\nIt will parse XML files without a root element just fine.\n\n```sh\n$ head fixtures/oai.xml\n<record>\n    <header>\n        <identifier>oai:arXiv.org:0704.0004</identifier>\n        <datestamp>2007-05-23</datestamp>\n        <setSpec>math</setSpec>\n    </header>\n    <metadata>\n        <oai_dc:dc xmlns:oai_dc=\"http://www.openarchives.org/OAI/2.0/oai_dc/\"... >\n            <dc:title>A determinant of Stirling cycle numbers counts ...\n            <dc:type>text</dc:type>\n            <dc:identifier>http://arxiv.org/abs/0704.0004</dc:identifier>\n...\n```\n\nThis is an example XML response from a web service. We can slice out the\nidentifier elements. Note that any namespace - here `oai_dc` - is completely\nignored for the sake of simplicity:\n\n```sh\n$ cat fixtures/oai.xml | xmlcutty -root x -path /record/metadata/dc/identifier \\\n                       | xmllint --format -\n<?xml version=\"1.0\"?>\n<x>\n    <identifier>http://arxiv.org/abs/0704.0004</identifier>\n    <identifier>http://arxiv.org/abs/0704.0010</identifier>\n    <identifier>http://arxiv.org/abs/0704.0012</identifier>\n</x>\n```\n\nWe can go a bit further and extract the text element, which is like a poor man\n`text()` in XPath terms. By using the a newline as argument to rename, we\neffectively get rid of the enclosing XML tag:\n\n```sh\n$ cat fixtures/oai.xml | xmlcutty -rename '\\n' -path /record/metadata/dc/identifier \\\n                       | grep -v \"^$\"\nhttp://arxiv.org/abs/0704.0004\nhttp://arxiv.org/abs/0704.0010\nhttp://arxiv.org/abs/0704.0012\n```\n\nThis last feature is nice to quickly extract text from large XML files.\n", 
  "id": 46054972
}
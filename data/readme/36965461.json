{
  "read_at": 1462549650, 
  "description": "", 
  "README.md": "OverFeat\n========\n\nOverFeat is a Convolutional Network-based image classifier and feature extractor.\n\nOverFeat was trained on the ImageNet dataset and participated in the ImageNet 2013 competition.\n\nThis package allows researchers to use OverFeat to recognize images and extract features.\n\nA library with C++ source code is provided for running the OverFeat convolutional network, together with wrappers in various scripting languages (Python, Lua, Matlab coming soon).\n\nOverFeat was trained with the Torch7 package ( http://www.torch.ch ). The OverFeat package provides tools to run the network in a standalone fashion. The training code is not distributed at this time.\n\n\nCREDITS, LICENSE, CITATION\n--------------------------\n\nOverFeat is Copyright NYU 2013. Authors of the present package are Michael Mathieu, Pierre Sermanet, and Yann LeCun.\n\nThe OverFeat system is by Pierre Sermanet, David Eigen, Xiang Zhang, Michael Mathieu, Rob Fergus, and Yann LeCun.\n\nPlease refer to the LICENSE file in the same directory as the present file for licensing information.\n\nIf you use OverFeat in your research, please cite the following paper: \n\n\"OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks\", Pierre Sermanet, David Eigen, Xiang Zhang, Michael Mathieu, Rob Fergus, Yann LeCun http://arxiv.org/abs/1312.6229\n\n\nINSTALLATION:\n-------------\n\nDownload the archive from http://cilvr.cs.nyu.edu/doku.php?id=software:overfeat:start\n\nExtract the files:\n```\ntar xvf overfeat-vXX.tgz\ncd overfeat\n```\n\nOverfeat uses external weight files. Since these files are large and do not change often, they are not included in the archive.\nWe provide a script to automatically download the weights :\n```\n./download_weights.py\n```\nThe weight files should be in the folder data/default in the overfeat directory.\n\nOverfeat can run without BLAS, however it would be very slow. We *strongly*\nadvice you to install openblas on linux (on MacOS, Accelerate should be available\nwithout any installation). On Ubuntu/Debian you should compile it (it might take\na while, but it is worth it) :\n```\nsudo apt-get install build-essential gcc g++ gfortran git libgfortran3\ncd /tmp\ngit clone https://github.com/xianyi/OpenBLAS.git\ncd OpenBLAS\nmake NO_AFFINITY=1 USE_OPENMP=1\nsudo make install\n```\nFor some reason, on 32 bits Ubuntu, libgfortran doesn't create the correct symlink.\nIf you have issues linking with libgfortran, locate where libgfortran is installed\n(for instance /usr/lib/i386-linux-gnu) and create the correct symlink :\n```\ncd <folder_containing_libgfortran.so.3>\nsudo ln -sf libgfortran.so.3 libgfortran.so\n```\nThe precompiled binaries use BLAS. If you don't want to (or can't, for some reason)\nuse BLAS, you must recompile overfeat.\n\nRUNNING THE PRE-COMPILED BINARIES\n\nPre-compiled binaries are provided for Ubuntu Linux (32 bits and 64 bits) and Mac OS. The pre-requisites are python and imagemagick, which are installed by default on most popular Linux distros.\n\n**Important note:** OverFeat compiled from source on your computer will run faster\nthan the pre-compiled binaries.\n\nExample of image classification, printing the 6 highest-scoring categories:\n```\nbin/YOUR_OS/overfeat -n 6 samples/bee.jpg\n```\nwhere YOUR_OS can be either linux_64, linux_32, or macos.\n\nRunning the webcam demo:\n```\nbin/YOUR_OS/webcam\n```\n\nGPU PRE-COMPILED BINARIES (EXPERIMENTAL)\n\nWe are providing precompiled binaries to run overfeat on GPU. Because the code\nis not released yet, we do not provide the source for now. The GPU release is\nexperimental and for now only runs on linux 64bits. It requires a Nvidia GPU\nwith CUDA architecture >= 2.0 (that covers all recent GPUs from Nvidia).\n\nYou will need openblas to run the GPU binaries.\n\nThe binaries are located in\n```\nbin/linux_64/cuda\n```\nAnd work the same way as the CPU versions. You can include the static library the\nsame way as the CPU version.\n\nCOMPILING FROM SOURCE\n\nInstall dependencies : python, imagemagick, git, gcc, cmake (pkg-config and opencv required for the webcam demo).\nOn Ubuntu/Debian :\n```\napt-get install g++ git python imagemagick cmake\n```\nFor the webcam demo :\n```\napt-get install pkg-config libopencv-dev libopencv-highgui-dev\n```\n\nHere are the instructions to build the OverFeat library and tools:\n\nGo to the src folder :\n```\ncd src\n```\n\nBuild the tensor library (TH), OverFeat and the command-line tools:\n```\nmake all\n```\n\nBuild the webcam demo (OpenCV required) :\n```\nmake cam\n```\n\nOn Mac OS, the default gcc doesn't support OpenMP. We strongly recommend to install\na gcc version with OpenMP support. With MacPort :\n```\nsudo port install gcc48\n```\nWhich will provide g++-mp-48 . If you don't install this version, you will have to\nchange the two corresponding lines in the Makefile.\n\nUPDATING\n\nA git repository is provided with the archive. You can update by typing\n```\ngit pull\n```\nfrom the overfeat directory.\n\nHIGH LEVEL INTERFACE:\n---------------------\n\nThe feature extractor requires a weight file, containing the weights of the\nnetwork. We provide a weight file located in data/default/net_weight .\nThe software we provide should be able to locate it automatically. In case\nit doesn't, the option -d can be used to manually provide a path.\n\nOverfeat can use two sizes of network. By default, it uses the smaller one.\nFor more accuracy, the option -l can be used to use a larger, but slower, network.\n\nCLASSIFICATION:\n\nIn order to get the top <N> (by default, <N>=5) classes from a number of images :\n```\nbin/linux_64/overfeat [-n <N>] [-d <path_to_weights>] [-l] path_to_image1 [path_to_image2 [path_to_image3 [... ] ] ]\n```\n\nTo use overfeat online (feeding an image stream),\nfeed its stdin stream with a sequence of ppm images (ended\nby end of file ('\\0') character). In this case, please use\noption -p. For instance :\n```\nconvert image1.jpg image2.jpg -resize 231x231 ppm:- | ./overfeat [-n <N>] [-d <path_to_weights>] [-l] -p\n```\nPlease note that to get the classes from an image, the image size should be 231x231.\nThe image will be cropped if one dimension is larger than 231, and the network\nwon't be able to work if both dimension are larger.\nFor feature extraction without classification, it can be any size greater or\nequal to 231x231 for the small network, and 221x221 for the large network .\n\nFEATURE EXTRACTION:\n\nIn order to extract the features instead of classifying, use -f option. For instance :\n```\nbin/linux_64/overfeat [-d <path_to_weights>] [-l] -f image1.png image2.jpg\n```\nIt is compatible with option -p.\nThe option -L (overrides -f) can be used to return the output of any layer.\nFor instance\n```\nbin/linux_64/overfeat [-d <path_to_weights>] [-l] -L 12 image1.png\n```\nreturns the output of layer 12. The option -f corresponds to layer 19 for the small layer\nand 22 for the large one.\n\nIt writes the features on stdout as a sequence. Each feature starts with three integers\nseparated by spaces, the first is the number of features (n),\nthe second is the number of rows (h) and the last is the number of columns (w).\nIt is followed by a end of line ('\\n') character. Then follows n*h*w floating point\nnumbers (written in ascii) separated by spaces. The feature is the first dimension\n(so that to obtain the next feature, you must add w*h to your index), followed by the\nrow (to obtain the next row, add w to your index).\nThat means that if you want the features corresponding to the top-left window, you need\nto read pixels i*h*w for i=0..4095 .\n\nThe output is going to be a 3D tensor. The first dimension correspond to the features,\nwhile dimensions 2 and 3 are spatial (y and x respectively).\nThe spatial dimension is reduced at each layer, and with the default network, using\noption -f, the output has size nFeatures * h * w where\n  - for the small network, \n    - nFeatures = 4096\n    - h = ((H-11)/4 + 1)/8-6\n    - w = ((W-11)/4 + 1)/8-6\n  - for the large network,\n    - nFeatures = 4096\n    - h = ((H-7)/2 + 1)/18-5\n    - w = ((W-7)/2 + 1)/18-5\nif the input has size 3*H*W . Each pixel in the feature map corresponds to a\nlocalized window in the input. With the small network, the windows are 231x231\npixels, overlapping so that the i-th window begins at pixel 32*i, while for the\nlarge network, the windows are 221x221, and the i-th window begins at pixel 36*i.\n\nWEBCAM:\n\nWe provide a live classifier based on the webcam. It reads images from the webcam,\nand displays the most likely classes along with the probabilities.\nIt can be run with\n```\nbin/linux_64/webcam [-d <path_to_weights>] [-l] [-w <webcam_idx>]\n```\n\nBATCH:\n\nWe also provide an easy way to process a whole folder :\n```\n./bin/linux_64/overfeat_batch [-d <path_to_weights>] [-l] -i <input_dir> -o <output_dir>\n```\n\nIt process each image in the input folder and produces a corresponding\nfile in the output directory, containing the features,in the same format\nas before.\n\nEXAMPLES:\n\nClassify image samples/bee.jpg, getting the 3 most likely classes :\n```\nbin/linux_64/overfeat -n 3 samples/bee.jpg\n```\n\nExtract features from samples/pliers.jpg with the large network :\n```\nbin/linux_64/overfeat -f -l samples/pliers.jpg\n```\n\nExtract the features from all files in samples :\n```\n./bin/linux_64/overfeat_batch -i samples -o samples_features\n```\n\nRun the webcam demo with the large network :\n```\nbin/linux_64/webcam -l\n```\n\nADVANCED:\n\nThe true program is actually overfeatcmd, where overfeat is only a python script calling\noverfeatcmd. overfeatcmd is not designed to be used by itself, but can be if necessary.\nIt taked three arguments :\n```\nbin/linux_64/overfeatcmd <path_to_weights> <N> <I> <L>\n```\nIf <N> is positive, it is, as before, the number of top classes to display.\nIf <N> is nonpositive, the features are going to be the output. The option <L>\nspecifies from which layer the features are obtained\n(by default, <L>=16, corresponding to the last layer before the classifier).\n<I> corresponds to the size of the network : 0 for small, 1 for large.\n\nAPIs:\n----\n\nC++:\n\nThe library is written in C++. It consists of one static library named liboverfeat.a .\nThe corresponding header is overfeat.hpp . It uses the low level torch tensor\nlibrary (TH). Sample code can be found in overfeatcmd.cpp and webcam.cpp.\n\nThe library provides several functions in the namespace overfeat :\n\n- `void init(const std::string & weight_file_path, int net_idx)` : \nThis function must be called once before using the feature extractor.\nIt reads the weights and must be passed a path to the weight files.\nIt must also be passed the size of the network (net_idx), which should be 0,\nor 1, respectively for small or large networks. Note that the\nweight file must correspond to the size of the network.\n\n- `void free()` : This function releases the ressources and should be called when the\nfeature extractor is no longer used.\n\n- `THTensor* fprop(THTensor* input)` : \nThis is the main function. It takes an image stored in a THTensor* and runs the network on it.\nIt returns a pointer to a THTensor containing the output of the classifier. \nIf the input is 3*H*W, the output is going to be nClasses * h * w, where\n  - for the small network :\n    - nClasses = 1000\n    - h = ((H-11)/4 + 1)/8 - 6\n    - w = ((W-11)/4 + 1)/8 - 6\n  - for the large network :\n    - nClasses = 1000\n    - h = ((H-7)/2 + 1)/18 - 5\n    - w = ((W-7)/2 + 1)/18 - 5\nEach pixel of the output corresponds to a 231x231 window on the input for the\nsmall network, and 221x221 for the large network. The windows overlap in the same\nway as described earlier for the feature extraction.\nEach class gets a score, but they are not probabilities (they are not normalized).\n\n- `THTensor* get_output(int i)` : Once fprop has been computed, this function returns the \noutput of any layer. For instance, in the default network, layer 16 corresponds to the\nfinal features before the classifier.\n\n- `int get_n_layers()` : Returns the total number of layers of the network.\n\n- `void soft_max(THTensor* input, THTensor* output)` : This function converts \nthe output to probabilities. It only works if h = w = 1 (only one output pixel).\n\n- ` std::string get_class_name(int i)` : This function returns the string corresponding to the i-th class.\n\n- `std::vector<std::pair<std::string, float> > get_top_classes(THTensor* probas, int n)` : \nGiven a vector with nClasses elements containing scores or\nprobabilities, this function returns the names of the top `n` classes, along with their\nscore/probabilities.\n\nWhen compiling code using liboverfeat.a, the code must also be linked against\nlibTH.a, the tensor library. The file libTH.a will have been produced when\ncompiling torch.\n\n\nTorch7:\n\nWe have bindings for torch, in the directory API/torch. The file\nAPI/torch/README contains more details.\n\n\nPython:\n\nThe bindings for python are in API/python. See API/python/README .\n", 
  "id": 36965461
}
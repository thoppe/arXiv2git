{
  "read_at": 1462557941, 
  "description": "A Parallel Graphlet Decomposition Library for Large Graphs", 
  "README.md": "# Parallel Parameterized Graphlet Decomposition (PGD) Library\n\nA fast parallel graphlet decomposition library for large graphs.\n\nPlease refer to the paper [1] for detailed discussion on the algorithm.\n\n\n\n\nSynopsis\n--------\n\nIn short, a parameterized high performance library for counting motifs in large sparse graphs.\n\n\n### Setup\nFirst, you'll need to compile PGD.  \n\n        $ cd path/to/pgd/\n        $ make\n\nAfterwards, the following should work:  \n\n        # compute the motif counts\n        ./pgd -f sample_graph.csv\n\nCurrently, PGD supports only UNIX-based systems.\n*PGD* has been tested on Ubuntu linux (10.10 tested) and Mac OSX (Lion tested) with gcc-mp-4.7 and gcc-mp-4.5.4\n\nPlease let us know if you run into any issues.  \n\n  \n  \nMotif | Symbol | Description | Comp. | &rho; | &delta; | d<sub>avg</sub> | r | T | K | &chi; | D | B | C\n----- | ------- | ------------ | --------- | ------- | ----- | ------------ | --------- | ------- | ----- | ------------ | --------- | ------- | -----\n<img src=\"http://graphlets.org/img/4-clique.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>1</sub></sub>  | 4-clique |  <img src=\"http://graphlets.org/img/4-node-indep.svg\" width=\"30px\" height=\"30px\" > | 1.00 | 3 | 3.0 | 1.00 | 4 | 3 | 4 | 1 | 0 | 1 \n<img src=\"http://graphlets.org/img/chordal-cycle.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>2</sub></sub>  | 4-chordal-cycle |  <img src=\"http://graphlets.org/img/4-node-1edge.svg\" width=\"30px\" height=\"30px\" > | 0.83 | 3 | 2.5 | -0.66 | 2 | 2 | 3 | 2 | 1 | 1  \n<img src=\"http://graphlets.org/img/tailed-triangle.svg\" width=\"30px\" height=\"30px\" >| g<sub>4<sub>3</sub></sub>  | 4-tailed-triangle |  <img src=\"http://graphlets.org/img/4-node-star.svg\" width=\"30px\" height=\"30px\" > | 0.67 | 3 | 2.0 | -0.71 | 1 | 2 | 3 | 2 | 2 | 1\n<img src=\"http://graphlets.org/img/4-cycle.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>4</sub></sub>  | 4-cycle |  <img src=\"http://graphlets.org/img/4-node-2edges.svg\" width=\"30px\" height=\"30px\" > | 0.67 | 2 | 2.0 | 1.00 | 0 | 2 | 2 | 2 | 1 | 1\n<img src=\"http://graphlets.org/img/3-star.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>5</sub></sub>  | 3-star |  <img src=\"http://graphlets.org/img/4-node-triangle.svg\" width=\"30px\" height=\"30px\" > | 0.50 | 3 | 1.5 | -1.00 | 0 | 1 | 2 | 2 | 3 | 1\n<img src=\"http://graphlets.org/img/4-path.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>6</sub></sub>  | 4-path |  <img src=\"http://graphlets.org/img/4-path.svg\" width=\"30px\" height=\"30px\" > | 0.50 | 2 | 1.5 | -0.50 | 0 | 1 | 2 | 3 | 2 | 1\n<img src=\"http://graphlets.org/img/4-node-triangle.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>7</sub></sub>  | 4-node-1-triangle |  <img src=\"http://graphlets.org/img/3-star.svg\" width=\"30px\" height=\"30px\" > | 0.50 | 2 | 1.5 | 1.00 | 1 | 2 | 3 | 1 | 0 | 2\n<img src=\"http://graphlets.org/img/4-node-star.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>8</sub></sub>  | 4-node-2-star | <img src=\"http://graphlets.org/img/tailed-triangle.svg\" width=\"30px\" height=\"30px\" > | 0.33 | 2 | 1.0 | -1.00 | 0 | 1 | 2 | 2 | 1 | 2\n<img src=\"http://graphlets.org/img/4-node-2edges.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>9</sub></sub>  | 4-node-2-edge |  <img src=\"http://graphlets.org/img/4-cycle.svg\" width=\"30px\" height=\"30px\" > | 0.33 | 1 | 1.0 | 1.00 | 0 | 1 | 2 | 1 | 0 | 2\n<img src=\"http://graphlets.org/img/4-node-1edge.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>10</sub></sub>  | 4-node-1-edge |  <img src=\"http://graphlets.org/img/chordal-cycle.svg\" width=\"30px\" height=\"30px\" > | 0.17 | 1 | 0.5 | 1.00 | 0 | 1 | 2 | 1 | 0 | 3\n<img src=\"http://graphlets.org/img/4-node-indep.svg\" width=\"30px\" height=\"30px\" > | g<sub>4<sub>11</sub></sub>  | 4-node-independent |  <img src=\"http://graphlets.org/img/4-clique.svg\" width=\"30px\" height=\"30px\" > | 0.00 | 0 | 0.0 | 0.00 | 0 | 0 | 1 | &infin; | 0 | 4\n<img src=\"http://graphlets.org/img/3-triangle.svg\" width=\"30px\" height=\"30px\" > | g<sub>3<sub>1</sub></sub>  | triangle |  <img src=\"http://graphlets.org/img/3-disconnected-indep.svg\" width=\"30px\" height=\"30px\" > | 1.00 | 2 | 2.0 | 1.00 | 1 | 2 | 3 | 1 | 0 | 1\n<img src=\"http://graphlets.org/img/3-path.svg\" width=\"30px\" height=\"30px\" > | g<sub>3<sub>2</sub></sub>  | 2-star |  <img src=\"http://graphlets.org/img/3-disconnected-1edge.svg\" width=\"30px\" height=\"30px\" > | 0.67 | 2 | 1.33 | -1.00  | 0 | 1 | 2 | 2 | 1 | 1 \n<img src=\"http://graphlets.org/img/3-disconnected-1edge.svg\" width=\"30px\" height=\"30px\" > | g<sub>3<sub>3</sub></sub>  | 3-node-1-edge |  <img src=\"http://graphlets.org/img/3-path.svg\" width=\"30px\" height=\"30px\" > | 0.33 | 1 | 0.67 | 1.00  | 0 | 1 | 2 | 1 | 0 | 2 \n<img src=\"http://graphlets.org/img/3-disconnected-indep.svg\" width=\"30px\" height=\"30px\" > | g<sub>3<sub>4</sub></sub>  | 3-node-independent |  <img src=\"http://graphlets.org/img/3-triangle.svg\" width=\"30px\" height=\"30px\" > | 0.00 | 0 | 0.00 | 0.00  | 0 | 0 | 1 | &infin; | 0 | 3\n<img src=\"http://graphlets.org/img/2-edge.svg\" width=\"30px\" height=\"30px\" > | g<sub>2<sub>1</sub></sub>  | edge |  <img src=\"http://graphlets.org/img/2-disconnected.svg\" width=\"30px\" height=\"30px\" > | 1.00 | 1 | 1.0 | 1.00  | 0 | 1 | 2 | 1 | 0 | 1 \n<img src=\"http://graphlets.org/img/2-disconnected.svg\" width=\"30px\" height=\"30px\" > | g<sub>2<sub>2</sub></sub>  | 2-node-independent |  <img src=\"http://graphlets.org/img/2-edge.svg\" width=\"30px\" height=\"30px\" > | 0.00 | 0 | 0.0 | 0.00  | 0 | 0 | 1 | &infin; | 0 | 2 \n\n\n\n\n### Input file format\n\n+ Matrix Market Coordinate Format (symmetric)  \nFor details see: <http://math.nist.gov/MatrixMarket/formats.html#MMformat>  \n\n        %%MatrixMarket matrix coordinate pattern symmetric  \n        4 4 6  \n        2 1  \n        3 1  \n        3 2  \n        4 1  \n        4 2  \n        4 3 \n\nNote comments are denoted by `%`. First line represents `n n m` where n is the number of nodes and m is the number of edges |E|. \nFor instance, the first line above is `4 4 6` and indicates the number of nodes is n=4 and number of edges is m=6.\n\nA graph file with the extension `.mtx` is read using this strict mtx graph reader. \nThus, if the graph file does not strictly follow the above mtx format, \nthen the file extension should be changed to allow it to be read by the more flexible graph reader discussed below.\n\n\n+ Edge list: These codes are designed to be as flexible as possible and accept many variations of edge lists. Note these codes may be slightly slower than the mtx reader. This is due to allowing flexible edge list formats. Hence, this reader must perform many checks to figure out the exact format of the input file, and performs any necessary preprocessing work that may be required.\n\n\n    * Delimiters: The mcpack reader accepts comma, space, or tab delimited edge lists.\n            \n    * Comments: Comments are allowed and should be denoted with the first character of a newline as # or %\n\n    * Weights: If an edge list contains weights on the 3rd column, they are simply ignored. A user may specify to read the weights by setting the wt parameter or by noting the graph is in fact a temporal graph.\n\n    * Multigraph: When an edge list contains multiple edges, we simply remove the duplicate edges.\n\n    * The edge list may also contain gaps in the vertex ids (non sequential vertex ids) and start from any positive integer. Self-loops are removed.\n\n    * The edge list is assumed to be undirected. However, if a directed graph is given, it is simply treated as undirected.\n\n\n\n\nOutput Graphlet Quantities\n----------------\n\nThe _PGD_ family of graphlet decomposition algorithms provide three types of output \n    1. Global macro statistics indicating the total frequency of each motif\n    2. Local micro statistics representing the number of times each motif appears (for each edge or node in the graph)\n    3. Graphlet frequency distribution\n    \nNOTE: The total counts for each motif is outputted to the screen by default.\n\n### Macro motif counts\nThe macro (global) graphlet counts are printed to the screen by default.\nThese statistics may also be saved to a file using `--macro filename.macro` where `filename.macro` is the path to save stats.\n\n        ./pgd -f sample_graph.csv --macro sample_graph.macro\n        \n\n### Micro motif counts\nThe motif counts for each edge may also be saved using the `--micro filename.micro`. \n\n        ./pgd -f sample_graph.csv --micro sample_graph.micro\n        \n\n### Graphlet frequency distribution (GFD)\nTo output the graphlet frequency distribution, use the `--gfd filename.gfd` option.\n\n        ./pgd -f sample_graph.csv --gfd sample_graph.gfd\n    \n    \n    \n\n\n\nAdvanced\n----------------\n\n### Orderings\n\nThe PGD algorithms are easily adapted to use various ordering strategies. \nTo prescribe an ordering, use the -o option with one of the following:\n\n\nOrdering techniques | Description\n------------------- | -------------\n`deg`           | order by degree\n`kcore`         | degeneracy order\n`dual_deg`      | ordering defined by the sum of degrees from neighbors\n`dual_kcore`    | order by the sum of core numbers from neighbors\n`kcore_deg`     | order by the weight k(v)d(v)\n`rand`          | uniformly random order\n`natural`       | use the order given as input\n\n\n\n### Direction of ordering\n\nDescending order is the default (largest to smallest). \nFor ascending order (smallest to largest), simply set ``--s2l`` as follows:\n\n```\n./pgd -f sample_graph.csv --s2l\n```\n\nTo reverse the order of the neighbors (for each node) use `--s2l_neigh``.\n\n\n\n\n\n\nCommand Line Interface (CLI)\n---------\n\nYou can execute PGD with ``--help`` to see the list of options\n\n\t\n\t$ ./pgd --help\n\t\n\t=================================================================================\n\tParallel Parameterized Graphlet Decomposition (PGD) Library\n\t=================================================================================\n\t-f, --file,--graph              : Input GRAPH file for computing the graphlets (e.g., matrix market format, simple edge list). \n\t-a, --algorithm                 : Algorithm for the GRAPHLET DECOMPOSITION. Default: exact, approximate, etc.\n\t---------------------------------------------------------------------------------\n\t-w, --workers                   : Number of WORKERS (processing units) for the algorithm to use (default = max). \n\t-b, --block_size                : Size of blocks assigned to workers (processing units), that is, 1, 64, 512, etc.  Default: -b 64\n\t---------------------------------------------------------------------------------\n\t-o, --ordering                  : Strategy used to determine the order in which the edge/node graphlets are computed.\n\t                                  Default: -o degree (kcore, rand, natural/off, etc.).\n\t    --s2l                       : Direction of the ordering (default: largest to smallest).\n\t                                  Note to order from smallest to largest, set '--s2l'  \n\t-n, --neigh_ordering            : Ordering to use for the neighbors of each node. \n                        \t           Default: degree (kcore, rand, natural, etc.)\n\t                                   Note only applicable if CSC/CSR is used (-r csc).\n\t    --s2l_neigh                 : Order direction for neighbor/csc ordering strategy\n\t                                  (e.g., --neigh_ordering degree --s2l_neigh, default: largest to smallest)\n\t---------------------------------------------------------------------------------\n\t-c, --counts,--macro            : Compute MACRO (GLOBAL) GRAPHLET FEATURES and save counts to file (e.g., --counts name.graphlets)\n\t-m, --micro                     : Compute MICRO (LOCAL) GRAPHLET FEATURES and save EDGE-by-MOTIF feature matrix (-m name.micro_graphlets)\n\t                                  Default: OFF. NOTE: Turn ON edge graphlet counting by specifying an output file, e.g., '-m name.micro_graphlets' \n\t---------------------------------------------------------------------------------\n\t-v, --verbose                   : Output additional details to the screen. \n\t-?, -h, --help                  : Print out this help menu. \n\t\n\t\n\tREPRESENTATION: Example: ./pgd -r csc (adj, etc.)\n\t=================================================================================\n\t-r,   --rep                     : Graph representation [adj, csc, hybrid, auto, etc].\n\t                                  Default: Auto select optimal. \n\t   'adj'    - adjacency matrix  : dense n by n matrix, O(|V|^2) storage cost\n\t   'csc'    - comp. sparse col  : large sparse graphs, O(|V|+|E|) storage cost\n\t   'hybrid' -  csc + adj        : small sparse and dense graphs, O(|V|^2 + |V| + |E|) storage cost\n\t-l, --adj_limit                 : Threshold/limit for creating adj representation. Default: '-l 10000' (that is <10000 nodes).\n\t\n\t\n\tORDERING TECHNIQUES: Example: ./pgd -o degree (kcore, rand, etc.)\n\t=================================================================================\n\t'degree',   'deg'                    : O(|V|)\n\t'kcore',                             : O(|E|)\n\t'rand', 'random'                     : O(|V|)\n\t'off',  'natural'                    \n\t\n\t Other methods for ordering include: \n\t'kcore_degree', 'kcore_deg'          : O(|V|)\n\t'degree_vol',   'deg_vol'            : O(|E|)\n\t'kcore_vol',                         : O(|E|)\n\t'deg_kcore_vol'                      : O(|E|)\n\t------------------------------------------------------------------\n\tNOTE: Default ordering is kcore (degeneracy order). For natural order, use '-o off' or '-o natural'\n\n\n\n\n\nAPI and Sample Codes\n------------------------\n\n### Exact Sample Codes\nSample codes for computing exact graphlet statistics using the family of `exact` graphlet decomposition algorithms from [pgd library](http://nesreenahmed.com/graphlets).\n\n* macro graphlet statistics\n* micro graphlet statistics\n\nLet us note that if the micro-level graphlet statistics are not needed, then it is recommended to use the macro graphlet decomposition algorithms. These are highly optimized for this task and thus are significantly more space-efficient while also faster and more scalable.\n\n\n#### Macro graphlet statistics\nCompute the global frequency of the various motif patterns with just two lines:\n\n```cpp\n// read graph, optimize alg/data structs, etc.\ngraphlet_core G(\"sample_graph.csv\");\nG.graphlet_decomposition();\n```\n\nAfterwards, it is easy to print or write global motif counts to a file.\n\n```cpp\nG.print_graphlet_counts(); // print to screen\n```\n\nor SAVE to a file,\n\n```cpp\nG.write_macro_stats(path);\n```\n\n\n#### Micro graphlet statistics\nCompute the frequency of the various motif patterns with just two lines:\n\n```cpp\n// read graph, optimize alg/data structs, etc.\ngraphlet_core G(\"sample_graph.csv\");\nG.graphlet_decomposition_micro();\n```\n\nAfterwards, it is easy to print or write the motif counts to a file.\n\n```cpp\nG.print_micro_stats(); // print to screen\n```\n\nor SAVE to a file,\n\n```cpp\nG.write_micro_stats(path);\n```\n\n\n### GFD Sample Codes\n\n#### Estimate GFD\nTo obtain a fast and accurate estimation of the graphlet frequency distribution, use the following:\n\n```cpp\n// Approximate GFD by sampling uniformly at random 10% of the edges (vertices) to use\nG.graphlet_approximation(0.10);\n```\n\nAfterwards, the GFD can be approximated from these counts as follows:\n\n```cpp\n// Estimate graphlet distribution for connected and disconnected motifs\nG.compute_GFD();\n```\n\n\nDistribution | API Call\n------------------- | -------------\n Graphlet Freq. Distribution (GFD) | `compute_GFD()` \n Connected GFD | `compute_connected_GFD()` \n Disconnected GFD | `compute_disconnected_GFD()` \n\n\n\t\n\n\n#### Exact GFD\nExact graphlet distributions may also be computed fast by simply using an exact graphlet decomposition method from those expressed by the pgd library and then using the API calls above in the table.\n\n```cpp\nG.graphlet_decomposition();\nG.compute_GFD();\n```\n\n\nDocumentation\n--------------\nThe documentation is generated (using doxygen) by simply typing `make doc` in the root directory of pgd.\n\n    make doc\n    \nThis creates the `./doc` directory with the documentation.\nTo update the documentation, use `make cleandoc` then `make doc`.\n\nDoxygen and graphvis are required and installed via homebrew (if not installed already).\nCurrently, this works only for Mac OSX and other Unix-based systems.\n\n\n\nAdditional Info.\n----------------\n\nTo generate the documentation you must have doxygen and graphviz installed. \nOn Mac OSX these can be stalled using *homebrew* with the following commands:\n\n    # install doxygen and graphviz using homebrew on Mac OSX\n    brew install doxygen\n    brew install graphviz\n\nAfterwards, the documentation is generated by simply typing `make docs` in the root directory of pgd.\nThis creates the `./docs` directory with the documentation.\n\n\n\n\nTerms and conditions\n--------------------\nPlease feel free to use the [PGD library](http://nesreenahmed.com/graphlets). We only ask that you cite:  \n\n1. Nesreen K. Ahmed, Jennifer Neville, Ryan A. Rossi, Nick Duffield, \n    \t[Efficient Graphlet Counting for Large Networks](http://www.nesreenahmed.com/publications/ahmed-et-al-icdm2015.pdf), *IEEE International Conference on Data Mining (ICDM)*, pages 10, 2015.\n\n\tAlso the BiBTeX for [1] is:\n\n\t\t@inproceedings{ahmed2015icdm,\n\t\t    title={Efficient Graphlet Counting for Large Networks},\n\t\t    author={Nesreen K. Ahmed and Jennifer Neville and Ryan A. Rossi and Nick Duffield},\n\t\t    booktitle={ICDM},\n\t\t    pages={1--10},\n\t\t    year={2015}\n\t\t}\n\n2. Nesreen K. Ahmed, Jennifer Neville, Ryan A. Rossi, Nick Duffield\n        Fast Parallel Graphlet Counting for Large Networks, arXiv preprint \n        1506.04322, 2015.\n\n\n\nGraph Datasets\n--------------------\nPlease check the following link for additional graph datasets:\n[Network Repository] (http://networkrepository.com/)\n\n\nSee the LICENSE file for further information.\nCopyright 2012-2015, [Nesreen K. Ahmed](http://nesreenahmed.com) and [Ryan A. Rossi](http://ryanrossi.com). All rights reserved.\n", 
  "id": 51054489
}
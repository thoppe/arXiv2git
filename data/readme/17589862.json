{
  "README": "FSC: Finite State Coder\n\nAn implementation of the compression technique described\nin http://arxiv.org/pdf/1311.2540v2.pdf\n\nTo understand ANS, i extensively used the FSE project:\n\nhttps://github.com/Cyan4973/FiniteStateEntropy\n\nfrom Yann Collet, which is referenced by Jarek's paper.\nSee the blog entry:\n  http://fastcompression.blogspot.fr/2013/12/finite-state-entropy-new-breed-of.html\n\nFabian Giesen also has interesting implementations ideas. See his blog for pointers:\n\nhttp://fgiesen.wordpress.com/\n\nCode is located here: https://github.com/rygorous/ryg_rans\nI re-implemented some his ideas (Alias method, interleaving, etc.) for\nexperimentation purpose.\n\nBuilding:\n=========\nThere is a primitive \"Makefile\" to help you build the library (libfsc.a)\nand tests. Just type 'make'. This code has been developed and tested on\nLinux/x86_64 mostly. Expect moderate surprises on other platforms.\n\n\nQuick description of the source files:\n======================================\n* fsc.h: main header\n* fsc_enc.c: encoder\n* fsc_dec.c: decoder\n* bits.c / bits.h: bit reading and writing function\n\n* fsc_utils.[ch]: non-critical utility functions for testing\n\n* test.c / bit_test.c: tests\n* fsc.c: sample program to compress / decompress\n\nAPI:\n====\n\n// Compresses input buffer (in / in_size) using FSC.\n// log_tab_size must be in [log(alphabet_size)..14] range\n// for method 0 to 3. For word-based method, the value doesn't matter.\n// Compressed output (*out / out_size) must be deallocated using free().\nint FSCEncode(const uint8_t* in, size_t in_size,\n              uint8_t** out, size_t* out_size,\n              int log_tab_size, FSCCodingMethod method);\n\n// Decompresses compressed bytes.\n// Decompressed output (*out / out_size) must be deallocated using free().\nint FSCDecode(const uint8_t* in, size_t in_size, uint8_t* out, size_t out_size);\n", 
  "read_at": 1462553664, 
  "description": "Finite State Coder", 
  "README.md": "Finite State Coder\n\nThis project is an experimental implementation of Jarek Duda's assymetric\nnumeral systems (ANS), as described in the following paper:\n\nhttp://arxiv.org/abs/1311.2540\n\nTo understand ANS, i extensively used the FSE project:\n\nhttps://github.com/Cyan4973/FiniteStateEntropy\n\nby Yann Collet, which is referenced by Jarek's paper.\nSee the blog entry:\n  http://fastcompression.blogspot.fr/2013/12/finite-state-entropy-new-breed-of.html\n\nFabian Giesen also has interesting implementations ideas. See his blog for pointers:\n\nhttp://fgiesen.wordpress.com/\n\nCode is located here: https://github.com/rygorous/ryg_rans\nI re-implemented some his ideas (Alias method, interleaving, etc.) for\nexperimentation purpose.\n\n-------------------\n\nThe word-based coding methods (CODING_METHOD_16B and up) will use b=2^16\nand write 16b-words at a time. They also have variants with interleaving\nand alias method.\n\nThe default CODING_METHOD_16B_4X is the fastest so far, but experimentation\nis still underway...\n\n-------------------\n\nThe other implementations (CODING_METHOD_BUCKET, etc.) use bit-by-bit\nencoding/decoding, or byte-by-byte, where bits are grouped in packets of 8bits.\nNote that the coder still emits bits one by one though (b=2, in the\nANS terminology).\n\nThere are several 'Spread Function' available to try different\nsymbol <-> slots assignments (see BuildSpreadTableXXX() functions).\nYou can switch from one to another in the command line (-buck, -mod, etc.)\n\nKnown limitations:\n  - alphabet size should be <= 256\n  - max table size is 2 ^ 14\n\n-------------------\n\nCommand line help:\n\n```\n./fsc -h\nusage: ./fsc [options] < in_file > out_file\noptions:\n-c           : compression mode (default)\n-d           : decompression mode\n-s           : don't emit output, just print stats\n-l           : change log-table-size (in [2..14], default 12)\n-w                 : use word-based coding.\n-w2                : use word-based coding 2x interleave.\n-w4                : use word-based coding 4x interleave.\n-a                 : use word-based coding + alias.\n-a2                : use word-based coding + alias + interleave.\n-mod               : use modulo spread function\n-rev               : use reverse spread function\n-pack              : use pack spread function\n-buck              : use bucket spread function\n-h           : this help\n\n./test -h\nusage: ./test [options] [size]\noptions:\n-t <int>           : distribution type (in [0..5])\n-p <int>           : distribution param (>=0)\n-s <int>           : number of symbols (in [2..256]))\n-l <int>           : max table size bits (<= LOG_TAB_SIZE)\n-save <string>     : save input message to file\n-d                 : print distribution\n-f <string>        : message file name\n-w                 : use word-based coding.\n-w2                : use word-based coding 2x interleave.\n-w4                : use word-based coding 4x interleave.\n-a                 : use word-based coding + alias.\n-a2                : use word-based coding + alias + interleave.\n-mod               : use modulo spread function\n-rev               : use reverse spread function\n-pack              : use pack spread function\n-buck              : use bucket spread function\n-h                 : this help\n\n./bit_test -h\nusage: ./bit_test [options] [size]\n-l <int>           : max table size bits for bit-by-bit\n-l8 <int>          : max table size bits for byte-by-byte\n-p <int>           : try only one proba value\n-fsc               : skip FSC\n-fsc8              : skip FSC8\n-w                 : use word-based coding.\n-w2                : use word-based coding 2x interleave.\n-w4                : use word-based coding 4x interleave.\n-a                 : use word-based coding + alias.\n-a2                : use word-based coding + alias + interleave.\n-mod               : use modulo spread function\n-rev               : use reverse spread function\n-pack              : use pack spread function\n-buck              : use bucket spread function\n-h                 : this help\n\n```\n", 
  "id": 17589862
}
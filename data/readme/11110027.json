{
  "read_at": 1462556973, 
  "description": "Julia package for function approximation", 
  "README.md": "# ApproxFun.jl\n\n[![Build Status](https://travis-ci.org/ApproxFun/ApproxFun.jl.svg?branch=master)](https://travis-ci.org/ApproxFun/ApproxFun.jl) [![Coverage Status](https://img.shields.io/coveralls/ApproxFun/ApproxFun.jl.svg)](https://coveralls.io/r/ApproxFun/ApproxFun.jl?branch=master) [![Join the chat at https://gitter.im/ApproxFun/ApproxFun.jl](https://badges.gitter.im/ApproxFun/ApproxFun.jl.svg)](https://gitter.im/ApproxFun/ApproxFun.jl?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n`ApproxFun` is a package for approximating functions. It is heavily influenced by the Matlab\npackage [`Chebfun`](http://www.chebfun.org) and the Mathematica package [`RHPackage`](http://www.maths.usyd.edu.au/u/olver/projects/RHPackage.html).\n\n\nTake your two favourite functions on an interval and create approximations to them as simply as:\n\n```julia\nusing ApproxFun\nx = Fun(identity,[0.,10.])\nf = sin(x^2)\ng = cos(x)\n```\n\nEvaluating `f(.1)` will return a high\naccuracy approximation to `sin(0.01)`. All the algebraic manipulations of functions\nare supported and more.  For example, we can add `f` and `g^2` together and compute\nthe roots and extrema:\n\n```julia\nh = f + g^2\nr = roots(h)\nrp = roots(h')\n\nusing Plots\nplot(h)\nscatter!(r,h(r);color=:green)\nscatter!(rp,h(rp);color=:red)\n```\n\n![Extrema](https://github.com/ApproxFun/ApproxFun.jl/raw/master/images/extrema.png)\n\n\n# Differentiation and integration\n\n\nNotice from above that to find the extrema, we used `'` overridden for the `differentiate` function. Several other `Julia`\nbase functions are overridden for the purposes of calculus. Because the exponential is its own\nderivative, the `norm` is small:\n\n```julia\nf = Fun(x->exp(x),[-1.,1.])\nnorm(f-f')\n```\n\nSimilarly, `cumsum` defines an indefinite integration operator:\n\n```julia\ng = cumsum(f)\ng = g + f(-1)\nnorm(f-g)\n```\n\n`Fun`s in `ApproxFun` are instances of `Julia` types with one field to store coefficients and another\nto describe the function space. Similarly, each function space has one field describing\nits domain, or another function space. Let's explore:\n\n```julia\nx = Fun(identity)\nf = exp(x)\ng = f/sqrt(1-x^2)\nspace(f)   # Chebyshev(Interval(-1.0,1.0))\nspace(g)   # JacobiWeight(-0.5,-0.5,Interval(-1.0,1.0))\n```\n\nThe absolute value is\nanother case where the space of the output is inferred from the operation:\n\n```julia\nf = Fun(x->cospi(5x))\ng = abs(f)\nspace(f)   # Chebyshev(Interval(-1.0,1.0))\nspace(g)   # PiecewiseSpace((Chebyshev(Interval(-1.,-.9)),...))\n```\n\nAlgebraic and differential operations are also implemented where possible, and most of Julia's built-in functions are overridden to accept `Fun`s:\n\n```julia\nx = Fun()\nf = erf(x)\ng = besselj(3,exp(f))\nh = airyai(10asin(f)+2g)\n```\n\n\n# Solving ordinary differential equations\n\n\nSolve the Airy ODE `u'' - x u = 0` as a BVP on `[-1000,200]`:\n\n```julia\nx = Fun(identity,[-1000.,200.])\nd = domain(x)\nD = Derivative(d)\nB = dirichlet(d)\nL = D^2 - x\nu = [B;L] \\ [airyai(d.a);airyai(d.b)]\nplot(u)\n```\n\n![Airy](https://github.com/ApproxFun/ApproxFun.jl/raw/master/images/airy.png)\n\n\n# Nonlinear Boundary Value problems\n\nSolve a nonlinear boundary value problem satisfying the ODE `0.001u'' + 6*(1-x^2)*u' + u^2 = 1` with boundary conditions `u(-1)==1`, `u(1)==-0.5` on `[-1,1]`:\n\n```julia\nx=Fun()\nu0=0.x\n\nN=u->[u(-1.)-1.,u(1.)+0.5,0.001u''+6*(1-x^2)*u'+u^2-1.]\nu=newton(N,u0)\nplot(u)\n```\n![BVP](https://github.com/ApproxFun/ApproxFun.jl/raw/master/images/nbvp.png)\n\n\n# Periodic functions\n\n\nThere is also support for Fourier representations of functions on periodic intervals.\nSpecify the space `Fourier` to ensure that the representation is periodic:\n\n```julia\nf = Fun(cos,Fourier([-p,p]))\nnorm(f' + Fun(sin,Fourier([-p,p]))\n```\n\nDue to the periodicity, Fourier representations allow for the asymptotic savings of `2/p`\nin the number of coefficients that need to be stored compared with a Chebyshev representation.\nODEs can also be solved when the solution is periodic:\n\n```julia\ns = Chebyshev([-p,p])\na = Fun(t-> 1+sin(cos(2t)),s)\nL = Derivative() + a\nf = Fun(t->exp(sin(10t)),s)\nB = periodic(s,0)\nuChebyshev = [B;L]\\[0.;f]\n\ns = Fourier([-p,p])\na = Fun(t-> 1+sin(cos(2t)),s)\nL = Derivative() + a\nf = Fun(t->exp(sin(10t)),s)\nuFourier = L\\f\n\nlength(uFourier)/length(uChebyshev),2/p\nplot(uFourier)\n```\n\n![Periodic](https://github.com/ApproxFun/ApproxFun.jl/raw/master/images/periodic.png)\n\n\n# Sampling\n\n\nOther operations including random number sampling using [Olver & Townsend 2013].  The\nfollowing code samples 10,000 from a PDF given as the absolute value of the sine function on `[-5,5]`:\n\n```julia\nf = abs(Fun(sin,[-5,5]))\nx = ApproxFun.sample(f,10000)\nplot(x;t=:density)\nplot!(f/sum(f))\n```\n\n![Sampling](https://github.com/ApproxFun/ApproxFun.jl/raw/master/images/sample.png)\n\n\n# Solving partial differential equations\n\n\nWe can solve PDEs, the following solves Helmholtz `Du + 100u=0` with `u(+-1,y)=u(x,+-1)=1`\non a square\n\n```julia\nd = Interval()^2          \t\t\t\t\t# Defines a rectangle\n\nu = [dirichlet(d);lap(d)+100I]\\ones(4)\t\t# First four entries of rhs are\n    \t\t\t\t\t\t\t\t\t\t# boundary conditions\nplot(u)\t                                    # contour plot\n```\n\n\n<!-- We can also evolve PDEs.  The following solves advection--diffusion\n`u_t = 0.01Du - 4u_x -3u_y` on a rectangle\n\n```julia\nd = Interval()^2\nu0 = Fun((x,y)->exp(-40(x-.1)^2-40(y+.2)^2),d)\nB = dirichlet(d)\nD = Derivative(Interval())\nL = (0.01D^2-4D)[?]I + I[?](0.01D^2-3D)\nh = 0.002\ntimeevolution(B,L,u0,h)                    # Requires GLPlot\n``` -->\n\n\n# High precision\n\nSolving differential equations with high precision types is available.  The following calculates `e` to 300 digits by solving the ODE `u' = u`:\n\n```julia\nwith_bigfloat_precision(1000) do\n    d=Interval{BigFloat}(0,1)\n    D=Derivative(d)\n    u=[ldirichlet();D-I]\\[1]\n    u(1)\nend\n```\n\n\n# Further reading\n\nThe [ApproxFun Documentation](https://github.com/ApproxFun/ApproxFun.jl/wiki/ApproxFun-Documentation) is a work-in-process Wiki documentating the internal workings of `ApproxFun`\n\n\n\n# References\n\nS. Olver & A. Townsend (2014), A practical framework for infinite-dimensional linear algebra, Proceedings of the 1st First Workshop for High Performance Technical Computing in Dynamic Languages, 57-62\n\nA. Townsend & S. Olver (2014), The automatic solution of partial differential equations using a global spectral method,  J. Comp. Phys., 299: 106-123\n\nS. Olver & A. Townsend (2013), Fast inverse transform sampling in one and two dimensions, arXiv:1307.1223\n\nS. Olver & A. Townsend (2013), A fast and well-conditioned spectral method, SIAM Review, 55:462-489\n", 
  "id": 11110027
}
{
  "id": 42554050, 
  "read_at": 1462548685, 
  "README.rst": "bAbI tasks\n==========\n\nThis repository contains code to generate the `bAbI tasks` as described in the paper\n`Towards AI-Complete Question Answering: A Set of Prerequisite Toy Tasks`.\nPlease cite the paper if you use this code in your work.\n\n__ http://fb.ai/babi\n__ http://arxiv.org/abs/1502.05698\n__ http://dblp.uni-trier.de/rec/bibtex/journals/corr/WestonBCM15\n\n.. contents:: :depth: 2\n\nInstallation\n------------\n\nThis project requires Torch to be installed. The easiest way to install Torch\nis by following the installation instructions at `torch/distro`__.  To use the\nlibrary, install it with LuaRocks by running the following command from the\nroot directory.\n\n.. code:: bash\n\n   luarocks make babitasks-scm-1.rockspec\n\n__ https://github.com/torch/distro\n\nUsage\n-----\n\nTo generate a task, run the command\n\n.. code:: bash\n\n    babi-tasks <task-id>\n\nwhere ``<task-id>`` is either a class name (like ``PathFinding``) or the task\nnumber (e.g. 19). One can quickly generate 200 \"stories\" of each task with the following (*NOTE: this is not equivalent to having 200 questions per task as there can be multiple questions per story, the original bAbI task data at http://fb.ai/babi specifically uses 1000 questions as training*):\n\n.. code:: bash\n\n    for i in `seq 1 20`; do babi-tasks $i 200 > task_$i.txt; done\n\nTasks\n-----\n\nThe tasks in ``babi/tasks`` correspond to those from the original dataset as\nfollows:\n\n== ============================================= ===================\n#   Task                                         Class name\n== ============================================= ===================\n 1  Basic factoid QA with single supporting fact WhereIsActor\n 2  Factoid QA with two supporting facts         WhereIsObject\n 3  Factoid QA with three supporting facts       WhereWasObject\n 4  Two argument relations: subject vs. object   IsDir\n 5  Three argument relations                     WhoWhatGave\n 6  Yes/No questions                             IsActorThere\n 7  Counting                                     Counting\n 8  Lists/Sets                                   Listing\n 9  Simple Negation                              Negation\n10  Indefinite Knowledge                         Indefinite\n11  Basic coreference                            BasicCoreference\n12  Conjunction                                  Conjunction\n13  Compound coreference                         CompoundCoreference\n14  Time manipulation                            Time\n15  Basic deduction                              Deduction\n16  Basic induction                              Induction\n17  Positional reasoning                         PositionalReasoning\n18  Reasoning about size                         Size\n19  Path finding                                 PathFinding\n20  Reasoning about agent's motivation           Motivations\n== ============================================= ===================\n\n    Note: This code is a rewrite of the original code that was used to\n    generate the publicly available dataset at `fb.ai/babi`__. As such, it\n    is not possible to produce exactly the same dataset.\n    However, we have verified that numbers obtained are very similar.\n\n__ http://fb.ai/babi\n\nTask flags\n~~~~~~~~~~\nSome tasks accept configuration flags that will change their output.\n\nIn both the ``PathFinding`` and ``Size`` the number of inference steps required\nto answer the question can be changed. You can also control the number of\n\"decoys\" (locations that are not part of the path).\n\n.. code:: bash\n\n   babi-tasks PathFinding --path-length 3 --decoys 1\n   babi-tasks Size --steps 3\n\nCurrently the path length plus the number of decoys has to be 5 or less.\nSimilarly, the number of size comparisons cannot be more than 5.\n\nFor tasks involving people moving around, the use of coreferences and\nconjunctions can be controlled with the flags ``--coreference`` and\n``--conjunction``. These flags take a number between 0 and 1 as an argument,\ndetermining the fraction of the time coreferences and conjunctions are used\nrespectively.\n\n.. code:: bash\n\n   babi-tasks WhereIsActor --coreference 1.0\n\nTasks can also be rendered in a more symbolic manner. Use the flag ``--symbolic\ntrue`` to enable this.::\n\n  1 H teleport N\n  2 H teleport F\n  3 eval H is_in  F       2\n\nCode Overview\n-------------\n\nTasks are generated through simulation: We have a world containing entities_,\nand actions_ that can add new entities to the world, or modify entities' states.\nSimulations then just take the form of sampling actions that are valid.\n\nWe often want to ask questions that require some sort of logical inference. Some\ntypes of inference can be re-used in multiple tasks, for example the deduction\nthat a person and the object they are holding are in the same place is used\nseveral times. For this reason, some of the reasoning has been factored out: We\nkeep track of what the reader of a story knows about the world, and each time a\nnew line is read, we update this knowledge_.\n\nWhat follows is a brief overview of the classes and concepts used, which should\nhelp guide the understanding of the code.\n\nWorld\n~~~~~\n\nA world is a collection of entities. Worlds can be loaded from text files such\nas those found in ``babi/tasks/worlds`` using the ``world:load(filename)``\ncommand.\n\n.. _entities:\n\nEntity\n~~~~~~\n\nAll concepts and objects in the simulations are entities. They are effectively\nLua tables that describe the entity's properties.\n\nActions\n~~~~~~~\n\nActions modify the state of the world. Each action is performed by an entity,\neven actions like setting the location or size of another entity (these are\nusually performed by the entity \"god\").\n\nAn action's ``is_valid`` method will test whether an action can be performed\ne.g. John cannot move to the kitchen if he is already there. The ``perform``\nmethod assumes that the action is valid, and modifies the world accordingly\ni.e. it will change the location of John.\n\nLastly, actions can update the reader's knowledge_ of the world. For example,\nif we know that John is in the kitchen, the action \"John grabs the milk\"\ninforms the reader that the milk is in the kitchen as well.\n\nKnowledge\n~~~~~~~~~\n\nThe ``Knowledge`` class keeps track of what a reader currently knows about the\nworld. When actions_ are performed, the ``Action.update_knowledge`` method can\nupdate this knowledge accordingly. For example, when ``Knowledge`` contains\nthe information that John is in the kitchen, the action of dropping the milk\nwill result in the knowledge being updated to say that the milk is in the\nkitchen, and that it isn't being held by anyone.\n\nThe ``Knowledge`` class takes into account some basic logical rules. For\nexample, some properties are \"exclusive\" in the sense that only one value can be\ntrue (John cannot be in the kitchen and the garden at the same time, but he can\nbe not in the kitchen and not in the garden at the same time). Reversely, this\nmeans that if John is in the garden, the reader knows that he is not in the\nkitchen.\n\nWe keep track of which actions gave us which pieces of information about the\nworld. This way, we can provide the user with the supporting facts when asking\nquestions.\n\n.. _clauses:\n\nClause\n~~~~~~\n\nFacts about the world are expressed as clauses of the form ``(truth value,\nactor, action, arguments)``. For example ``(true, john, teleport, kitchen)``\nmeans that John moved to the kitchen, while ``(false, john, drop, milk)``\nmeans that John did *not* drop the milk. Note that because all information\nmust be conveyed as actions, the sentence \"John is in the garden\" is\nrepresented as ``(true, god, set_property, is_in, garden)``.\n\n.. _questions:\n\nQuestion\n~~~~~~~~\n\nA question is represented as a tuple of the form ``(question type, clause,\nsupport)``.\n\n    | 1 John is in the garden.\n    | 2 Where is John?  garden  1\n\nThis story is represented as a clause, ``clause = (true, god, set_property,\njohn, is_in, garden)``, followed by a question, ``question = (evaluate, clause,\n{1})``. A question like \"Is john in the garden?\" would instead be represented as\n``question = (yes_no, clause, {1})``.\n\nNatural language generation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAfter the simulation is complete, a story (task) is nothing more but a list of\nclauses_ and questions_. We turn this into text using the ``stringify``\nfunction. This function performs a simple process: It repeatedly tries to find\ntemplates that can turn the next clause(s) or question(s) into text. It randomly\nsamples a template from the matching ones, and goes on to the next clause that\nneeds to be converted.\n\nTemplates can be selected further based on configuration (each task has a\ndefault configuration, but they can be passed through the command line as\nwell). This enables turning on things like coreferences, conjunctions, etc.\n\nReferences\n----------\n\n* Jason Weston, Antoine Bordes, Sumit Chopra, Alexander M. Rush, Bart van Merrienboer, Armand Joulin, Tomas Mikolov. \"`Towards AI-Complete Question Answering: A Set of Prerequisite Toy Tasks`__\", *arXiv:1502.05698 [cs.AI]*.\n* Sainbayar Sukhbaatar, Arthur Szlam, Jason Weston, Rob Fergus, \"`End-To-End\n  Memory Networks`__\", *arXiv:1503.08895 [cs.NE]*.\n\n__ http://arxiv.org/abs/1502.05698\n__ http://arxiv.org/abs/1503.08895\n", 
  "description": "Task generation for testing text understanding and reasoning"
}
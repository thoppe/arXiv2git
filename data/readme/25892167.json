{
  "read_at": 1462511406, 
  "description": "Higher-Order Approximate Relational Refinement Types for Mechanism Design and Differential Privacy", 
  "README.md": "# Welcome to the HOARe2 compiler distribution!\n\nWe provide the type checker and examples used in papers:\n\n* \"Higher-Order Approximate Relational Refinement Types for Mechanism\n   Design and Differential Privacy\"\n   (http://dl.acm.org/citation.cfm?id=2677000)\n   (http://arxiv.org/abs/1407.6845)\n\n* \"Computer-aided verification in mechanism design\"\n   (http://arxiv.org/abs/1502.04052)\n\n## Build instructions:\n\nWe recommend using OPAM to install the tool, you'll need a recent\nrepository and standard gnu tools (gcc and make).\n\n```\n$ opam switch 4.03.0\n$ opam install ocamlbuild why3 menhir\n$ why3 config --detect\n$ make\n$ ./arlc -L examples/popl/ examples/popl/dummysum.rlc\n```\n\n### Provers:\n\nYou want to install some SMT solvers to run the tool.\nWe recommend the following set:\n\n```\n$ why3 config --detect\nFound prover Alt-Ergo version 1.00.prv, OK.\nFound prover CVC4 version 1.4, OK.\nFound prover CVC4 version 1.4 (alternative: noBV)\nFound prover CVC3 version 2.4.1, OK.\nFound prover Eprover version 1.8-001, OK.\nFound prover Z3 version 4.3.1 (old version, please consider upgrading).\n```\n\nYou may be lucky with other versions. Links:\n\n- Alt-Ergo: (http://alt-ergo.ocamlpro.com/)\n- CVC3 2.4.1 and CVC4 1.4:\n  http://www.cs.nyu.edu/acsys/cvc3/\n  http://cvc4.cs.nyu.edu/web/\n- Eprover 1.8:\n  http://wwwlehre.dhbw-stuttgart.de/~sschulz/E/E.html\n\n### Running HOARe2:\n\nTo type-check a program just run:\n\n```\n$ ./arlc examples/ex01\n```\n\n`arlc --help` should display help for the tool.\n\n## Editing and viewing examples:\n\nThe examples are in the examples/ directory.\n\nWe recommend using Emacs and Tuareg-mode to open the .rlc files. It is\nnot perfect but it does a good job, as our syntax is closely based on\nOCaml's one.\n\nYou can add:\n\n```\n(add-to-list 'auto-mode-alist '(\"\\\\.rlc$\"      . tuareg-mode) t)\n```\n\nto your emacs to automate the mode-loading process.\n\n### Reproducing results:\n\nFor practical reasons, a couple of examples produce a .why file to be\nverified using the Why3ide.\n\nUse\n\n$ why3ide -I examples $file\n\nto proceed.\n\nIn particular:\n\n- examples/binary_vc_length_power_0.why:\n\n  Requires the use of Eprover, it will then check.\n\n- examples/binary_vc_m_ass_0_solved.why\n\n  This one is tricky and needs Eprover and CVC3 to check.\n\n- examples/summarization_vc_pSig_cut_0.why:\n\n  CVC4 can solve the file as is with a large enough timeout (90s),\n  using the split tactic in the IDE allows the goal to be solved\n  immediately.\n\n## More about the tool\n\nIf you are curious about the examples individually, we provide several\nverbosity options to witness the type checking process `-v 1` to `-v 9`.\n\nDepending on your machine the solvers may need a larger timeout. You\ncan control it using the --timeout parameter but the default should be\nfine for most.\n\nSome examples may take a long time, if they fail with a timeout,\ntry increasing it:\n\n```\n$ ./arlc --timeout 90 examples/summarization.rlc\n```\n\nThe tool is in alpha stage, it may be difficult to use for your own\nparticular programs, but we would be happy to help.\n\nThe most common failure of the typechecking is solvers failing to\nverify an assertion. If that happens, you can use:\n\n```\n$ why3ide arlc_current.why\n```\n\nto play with the proof context and debug the cause of failure.\n\n## Limitations of the tool\n\nThere are two important limitations of the tool, however  workarounds do exists:\n\n- Bidirectional type-checking is very limited at the moment. This\n  means that you may need to use a cut (see eq_v in dummysum.rlc for\n  example) in the leaves to hint the type checker about the return\n  type.\n\n  Also \"match\" require annotations.\n\n- Assertion checking may fail with an error if the assertion cannot be\n  translated to Why3. Why3 has limited support for higher-order and we\n  have not implemented a complete defunctionalization/demonadlization\n  procedure yet.\n\n  In most cases is possible to factorize the program to avoid\n  this error.\n\n## Language extensions\n\nIn order to help with development, two helper primitives \"trust\" and\n\"have\" are supported.\n\n```\nhave : { Assertion }        in\n```\n\nWill introduce a cut or intermediate lemma for helping the SMT. In\nquite a few cases, the SMTs cannot prove A -> B directly, but with a\nhint C, they are able to prove A -> C, and C -> B. (We usually\ndiscover this conditions using why3ide).\n\nThe `have` primitive just eases the introduction of cuts.\n\n```\ntrust (ass_name) res : T = e in\n```\n\nWill consider e to have type T without calling the SMTs. However, it\nwill output the pending proof to a file \"ass_name.why\", allowing to\nprove it using the why3ide. We also output a Coq file for the\nCoq-inclined user.\n\nWe hope you have fun, don't hesitate to contact us for any question or\nhelp.\n\n## Language reference:\n\nTODO\n\n", 
  "id": 25892167
}
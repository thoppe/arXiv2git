{
  "read_at": 1462556833, 
  "description": "Short Intro to Opetopes", 
  "README.md": "Short Intro to Opetopes\n===============\n\n\nSeminar 2013-11-19\n\nMy goals:\n 1. form an intuition of opetopic sets\n 2. sketch a calculus of (string) diagrams\n 3. discuss the missing piece of cartesian closure\n 4. potential applications to Omega 2.0\n\n\nOrigin\n======\n\nMid-1990'es by Baez and Dolan (_metatree_, _opetope_), published as [arXiv:q-alg/9702014](http://arxiv.org/pdf/q-alg/9702014.pdf).\n\nTQFTs [arXiv:q-alg/9503002](http://arxiv.org/pdf/q-alg/9503002.pdf)\n\nMany People\n===========\n\nVarious researchers/groups contributed since, and similar concepts go by a multitude of names\n\n - Multitopes - Hermida, Makkai\n - Opetopes - Eugenia Cheng (e.g. [arXiv:math/0304284](http://arxiv.org/pdf/math/0304284.pdf))\n - \"positive-to-one computads\" - Marek Zawadowski, [arXiv:0708.2658](http://arxiv.org/pdf/0708.2658.pdf)\n - Szawiel, Marek Zawadowski\t[arXiv:1011.2374](http://arxiv.org/pdf/1011.2374.pdf)\n - Joachim Kock, _et al_. [arXiv:0706.1033](http://arxiv.org/pdf/0706.1033.pdf)\n\nAt IAS:\n\n - Krzysztof Kapulkin\n - Eric Finster\n\nHigher-dimensional Trees\n========================\n\nPolynomial functors and monads (iterated construction)\n\n\n\nZooms and Complexes\n===================\n\nWe define _zooms_ as  configurable 'tree transformers'.\n\nThen we compose zooms to compexes, subject to boundary conditions.\n\nZoom definition\n----------------\n\n![A typical zoom](https://rawgithub.com/ggreif/seminar-opetope/master/zoom.svg)\n\nInput data: finite rooted (planar) trees (the nth dimension)\n\nFreely decorate with disks, adhering to rules:\n\n - disk must cut branch(es), but nothing else\n - every disk must capture a subtree\n\nInput-to-output translation\n----------------------------\n\n[Just change the perspective!](https://github.com/ggreif/seminar-opetope/blob/master/opetope2.stl)\n\nTranslate to tree in the (n+1)th dimension\n\n| Input  |   | Output  |\n| -----: |:-:| :------ |\n| branch | [?] |         |\n| dot    | = | (unit) branch |\n| disk   | = |  dot    |\n\nSpecial case: _corolla_\n------------------------\n\nA _corolla_ is a special zoom with just one dot in the left tree and no disks.\n\n![A corolla](https://rawgithub.com/ggreif/seminar-opetope/master/corolla.svg)\n\nThe output tree is thus a _unit branch_:\n\n![Corolla in zoom view](https://rawgithub.com/ggreif/seminar-opetope/master/corolla-zoom.svg)\n\n\nAssembling the complex\n-----------------------\n\nThe trees have labelled branches and dots (without repetition)\n\n![Labelled zoom](https://rawgithub.com/ggreif/seminar-opetope/master/labelled-zoom.svg)\n\nZooms can be joined when the trees match, forming a _zoom complex_.\n\n![Formed complex](https://rawgithub.com/ggreif/seminar-opetope/master/zoom-complex.svg)\n\n_Note:_ These complexes form a [semicategory](http://ncatlab.org/nlab/show/semicategory),\nas there are input trees not admitting an identity zoom (e.g. unit tree, most corollas).\n\n\nOpetope\n--------\n\nA zoom complex with dimensions\n\n| -2 | -1  | ... | _n+1_ |\n|---:|:---:|---|:--|\n| O  | (.) |   | . |\n\nand a _corolla_ appearing in the last dimension\nis called an _opetope_.\n\nOpetopes are normally drawn starting with dimension 0.\n\n * a 0-dimensional opetope is (isomorphic to) a natural number\n * the zoom in dimension 1 has a planar tree input\n\n[You can construct opetopes interactively.](http://sma.epfl.ch/~finster/opetope/opetope.html)\n\nInductive Datatypes\n===================\n\nFinster gives [data type](http://sma.epfl.ch/~finster/opetope/types-and-opetopes.pdf#page=26) + *typechecker*\n\nBut [intrinsic definition](http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus#Intrinsic_vs._extrinsic_interpretations)\nof `Zoom`s [is possible](https://code.google.com/p/omega/source/browse/trunk/tests/Opetope.prg).\n\n\nCategory of Opetopes\n====================\n\nSimilarly defined as the category of singular complexes [?]\n\n - Morphisms are face maps (corresponding to each 'round-ish thing')\n\n - Identity morphism (the top cell)\n\nPointers\n---------\n\nTo _mark_ (e.g.) a dot in a tree we use trees that only have one unit branch\n\n![A pointer](https://rawgithub.com/ggreif/seminar-opetope/master/pointer.svg)\n\nComposition\n------------\n\n\"pointer\" tree to mark a unit branch\n\nthen graft\n\nSubstitution\n-------------\n\nMark an n-ary node (or disk), swap it for an n-ary tree\n\n![Substitute](https://rawgithub.com/ggreif/seminar-opetope/master/substitution.svg)\n\nAnalogous to monadic _bind_.\n\nGeometric Realization\n======================\n\nAs _pasting diagrams_.\n\n![Pasting diagram](https://rawgithub.com/ggreif/seminar-opetope/master/pasting-diagram.svg)\n\n\n[As _string diagrams_](http://www-bcf.usc.edu/~lauda/xy/stringtutorial) (dual to the above).\n\nCoherence conditions\n====================\n\nAutomatically \"type-checked\"\n\n\nDeductions (following Finster)\n===============================\n\nLet's have a _formal language_ whose 'terms' are pasting diagrams.\n\nWe (say) start out with a set of basic opetopes (_axioms_).\n\nWhat are the _deduction rules_ to create new ones?\n\n<img src=\"http://latex.codecogs.com/svg.latex?\\mathbf{Set}^\\mathcal{O}\\rightarrow\\mathbf{Cat}^\\mathcal{O}\" border=\"0\"/>\n\nN.B.: How deductions (proof trees) map to adjuctions in <img src=\"http://latex.codecogs.com/svg.latex?\\mathbf{Cat}\" border=\"1\"/> is [nicely described here](http://www.cs.cmu.edu/~edmo/research/articles/morehouse-2013-thesis.pdf).\n\nEmpty rule\n-----------\n\nFrom any opetope one can derive an empty pasting diagram one dimension up.\n\n[See the corolla zoom](#special-case-corolla). It only shows the highest-dimensional\nzoom, but that is ok as nothing below changes.\n\nPaste rule\n-----------\n\nGiven _n_ pasting diagrams and a cell (corolla) with _n_ branches\n\n - such that the target cells of the pasting diagrams match the (input) branches\n - then a bigger pasting diagram can be created\n\n[See pointer guided composition](#composition), which is the atomic operation underlying this rule.\n\nComposite rule\n---------------\n\nUniversal cell introduction\n----------------------------\n\nUniversal cell elimination\n---------------------------\n\nSimilar to the [J-rule](http://homotopytypetheory.org/2011/04/10/just-kidding-understanding-identity-elimination-in-homotopy-type-theory/)\n\n![The power of the universal cell](http://images.amazon.com/images/G/01/dvd/cinderella-pumpkin-large.jpg)\n\nCan we Obtain Cartesian Closure?\n=================================\n\nTensor product on operads http://arxiv.org/pdf/math/0701293.pdf\n\nBoardman-Vogt tensoring: http://arxiv.org/pdf/1302.3711.pdf\n\nOperator categories: http://arxiv.org/pdf/1302.5756.pdf\n\nSymmetric monoidal closed, yes, but cartesian?\n\n - Gambino and Joyal: http://www1.maths.leeds.ac.uk/~pmtng/Research/Lectures/gambino-bmc.pdf\n\nExcursion: Lambda Calculus\n==========================\n\nSeveral notations, e.g. l (with m), [item notation (Kamareddine, Nederpelt)](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.6554)\n\nlet's come up with another one! (...see also Zena Ariola...)\n\n![Lambda Graph](https://omega.googlecode.com/svn/wiki/LambdaGraph.svg)\n\n## (Binary) search tree\n\nWe start with a lambda term\n<img src=\"http://latex.codecogs.com/svg.latex?(\\lambda x.xx)(\\lambda x.xx)\" border=\"0\"/>\n\nRespecting scope we build a search tree and retrofit it with references\n\n![Y combinator](https://rawgithub.com/ggreif/seminar-opetope/master/y-comb.svg)\n\nKind for shapes\n``` haskell\nkind Sh = Ap Sh Sh | Lm Sh | Rf Ref\nkind Ref = Up Ref | Stop | Left Ref | Right Ref | Down Ref\n```\n\nAbstraction / Binders\n======================\n\nKey insight: Trees admit naturals\n\n![Glue input](https://rawgithub.com/ggreif/seminar-opetope/master/glue-downstream.svg)\n\nBut we need _deBruijn_ + _extra sauce_\n\n![Docking stations](https://rawgithub.com/ggreif/seminar-opetope/master/docking-stations.svg)\n\n\nReferences: Identification, gluing\n===================================\n\n![References](https://rawgithub.com/ggreif/seminar-opetope/master/references.svg)\n\n - gluing an input on a (constructor) application [?] pattern matching\n - ... means: \"application dot\" here\n - gluing inputs _vanish_ from application dot\n - n-ary application possible? semantics?\n\nBeta-reduction\n===============\n\nWhen a selected external branch is _saturated_ by application,\nit completely dissolves, and the addressed binding station\ngets glued to the argument.\n\nDepending on the intended reduction strategy the _use_ references\nmay be expanded (_unsharing_).\n\nInternal Hom\n=============\n\n`(-)` is binary type constructor\n - profunctor (contra-/covariant)\n - Klein bottle (orientation-reversing)\n\n\nStrata in Omega\n================\n\n![Type strata](http://omega.googlecode.com/svn/wiki/Kind-hierarchy.svg)\n\nSingleton Types in Haskell\n---------------------------\n\nKind promotion\n\n![Nat'](https://rawgithub.com/ggreif/seminar-opetope/master/haskell-nats.svg)\n\n``` haskell\ndata {- kind -} Nat = Z | S Nat\n\ndata Nat' :: Nat -> * where\n  Z' :: Nat' Z\n  S' :: Nat' n -> Nat' (S n)\n```\n\nSingleton Types in Omega\n---------------------------\n\nKind definitions possible (at any level)\n\n![Omega's Nat'](https://rawgithub.com/ggreif/seminar-opetope/master/omega-nats.svg)\n\n``` haskell\nkind Nat = Z | S Nat\n\ndata Nat' :: Nat ~> * where\n  Z' :: Nat' Z\n  S' :: Nat' n -> Nat' (S n)\n```\n\nLevel Polymorphism\n-------------------\n\n``` haskell\ndata Nat :: level k . *k where\n  Z :: Nat\n  S :: Nat ~> Nat\n```\n\n![Omega's level polymorphism](https://rawgithub.com/ggreif/seminar-opetope/master/omega-levels.svg)\n\nCan we please have Curry-Howard back?\n--------------------------------------\n\nC-H lost as level-polymorphic type `Nat` above has no type parameter/index!\n\nIdea: parametrize with the same thing, but from one level up...\n\nUnfortunately this is not working out :-(\n\nI tried:\n\n![A failure](https://rawgithub.com/ggreif/seminar-opetope/master/singleton-levels.svg)\n\nFor a few levels (each differently named) [it can be made](https://code.google.com/p/omega/wiki/AutoLevelled#%CE%A9mega_example_for_%E2%80%B9%E2%80%B9Pat%E2%80%BA%E2%80%BA).\n\nNext idea\n----------\n\nparametrize on the **left**. Make access to parameter _optional_.\n\nthese all mean the same thing:\n``` haskell\nS Z :: Nat\nS Z :: S Z deg Nat\nS Z :: (S Z :: Nat) deg Nat\nS Z :: (S Z :: S Z deg Nat) deg Nat\n```\n\nAd infinitum, coinductively.\n\n_Programming in the Sky_\n-------------------------\n\nProgram in the (co)limit. Write a very simple `data` definition\n\n``` haskell\ndata Nat = Z | S Nat\n```\n\n... but have the refinement structure available when wanting to\nstate type-level propositions.\n\nConclusion\n===========\n\n 1. Opetopic calculus is rich and very interesting\n 2. It appears to be a solid basis for stratified type systems\n 3. Cartesian closure not completely understood yet\n\nQuestions?\n===========\n\nThanks for your attention!\n\nBtw. I am looking for collaborators\n 1. to make these ideas precise\n 2. kick-start an initial implementation.\n", 
  "id": 14339957
}
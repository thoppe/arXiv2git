{
  "read_at": 1462558431, 
  "description": "JUlia Quantum Simulator Toolbox", 
  "README.md": "# Juqst: JUlia Quantum Simulator Toolbox\n##Beginning of a quantum simulator toolbox, primarily written in the Julia Language\n\n###Done:\n\n* Implement the simulation of Stabiliser Circuits [Aaronson/Gottesman arXiv:quant-ph/0406196](http://arxiv.org/pdf/quant-ph/0406196)\n* Implement ability to select an arbitrary Clifford group element [Koenig/Smolin arXiv:quant-ph/1406.2170](http://arxiv.org/abs/1406.2170)\n* Implement the ability to decompose an arbitrary clifford unitary into a quantum circuit consistiting of hadamard, phase and two-qubit cnot gates.(Aaronson/Gottesman arXiv:quant-ph/0406196)\n* Draw the quantum circuit resulting from the decomposition of the clifford/unitary\n* Implement basic steps to rationalise the decomposed circuit\n* Simple brute force method to determine smallest circuit possible (runs in approximately (n*n)^(n*n) time - probably only for 3 qubits or less, or people with a serious amount of spare time)\n\n###Working on:\n\n- Shadow the stabiliser state with the exact density matrix representing the state (the **\"base representation\"**)\n- Integrate earlier work pre-defining the steane code generators and logical operators, allowing an arbitrary qubit to be projected into a steane code stabilised state.\n\n###To do:\n\n- randomised benchmarking from arbitrary cliffords\n- introduce the ability to add noise at the level of the \"base representation\" as well as in the stabilised state\n- explore noisy quantum channels\n- integrate tomography work\n- optimise the clifford compiler in sub-exponential time\n\n# To install\n\nThis has been developed on Julia 3.5. Currently there are two files that need to be loaded.\n\nThe current workbook which shows a number of examples is the \"A stabiliser run through\" workbook. It is probably worth running that one early.\n\nMove to the directory containing these files \n\n    cd(\"juqst\")\n\nThen \n\n    require(\"Initial.jl\")\n\nand \n\n    require(\"Symplectic.jl\")\n\n\n# Sample use\n\n## Stabiliser Circuits\n\n    state = setup(number_ofQubits)\n\nprepares the stabiliser state for the correct number of qubits in the |000..000> basis state\n\nThe state is represented internally as a matrix of the form:\n\n<img src=\"Matrix.png\"></img>\nAaronson/Gottesman arXiv:quant-ph/0406196\n\nCurrently I am just using Int32 Arrays, although binary arrays would save space (if it ever becomes necessary).\nRows 1 to n of the tableau represent the destabiliser generators, rows n+1 to 2n represent the stabiliser generators. Each row is read\nas follows: if the x<sub>ij</sub> and z<sub>ij</sub> are 1, the de/stabiliser is a Y, if they are both 0, its I otherwise its an X or Z depending on which one is set.\n \n    output(state)\n\nPrints the state in a human readable form. The states above the line are the 'destabiliser' state, below the line are the 'stabiliser' states. \n\nSo in a 3 qubit system the initial state of |000> is coded as \n\n```\nXII\nIXI\nIIX\n---\nZII\nIZI\nIIZ\n```\n\nThe following commands are defined\n\n    hadamard(state,qubit)  # apply a hadamard to the relevant qubit\n    phase(state,qubit)     # apply a phase gate to the relevant qubit\n    cnot(state,control,target) # apply a controlled not from control qubit to target qubit\n\nOutput of the resultant state can be supressed by adding an extra false parameter\n\n    hadamard(state,qubit,false) # hadamard as before, but supress output\n\n**NOTE! that these commands alter the state passed into them. I have broken Julia convention which requires functions \nwith side effects to be written thus - hadamard!(state,qubit).**\n\n## Arbitrary cliffords\n\n(Koenig/Smolin arXiv:quant-ph/1406.2170)\n\nThe idea behind this paper is that we can implement a one-to-one mapping between the cliffords and an integer (plus a random phase string).\n\nThe mapping is as follows:\n\n<img src=\"Clifford Mapping.png\">Koenig/Smolin arXiv:quant-ph/1406.2170</img>\n\nWe can generate the alpha,beta,gamma and delta via\n\n   symplectic(i,n) # i = integer represting the clifford, n is the number of qubits\n\nWhich returns the nxn arrays (alpha->delta) coded as follows:\n\n<img src=\"coding.png\">Koenig/Smolin arXiv:quant-ph/1406.2170</img>\n\nMore usefully these can be placed into a stabiliser tableau (that is the equivlent of passing the state |0000> through a gate that implements the unitary in question as follows:\n\n    stabiliseSymp(symp) # where symp is the symplectic of the clifford generated.\n\ne.g.\n\n    state = stabiliseSymp(symplectic(23,4)) # for the tableau of clifford '23' in a 4 qubit system\n\nOf course there are actually 4^n versions of of symplectic 23 (here n = 4), because of the different phases that we can have - this will be implemented shortly.\n\n# Decomposing a tableau (such as clifford)\n\nThis will be made more general, but just now it decomposes an arbitrary clifford\n\n    decompose(clifford_number, qubits)\n\n    more generally, you can also decomposeState(state)\n\n    Both the above have two additional parameters the first is supressOutput, defaults to false and the second is rationalise (default to true)\n    Rationalise simply eliminates 4 phases in a row, two hadamards in a row or self cancelling cnots.\n\nThis prints out the elementary gates that would reconstruct the relevant clifford unitary.\n\nThe commands are stored as string in the vector commands\nThe commands are also stored as Julia code in the vector executeCommands (so you can for instance execute them to re-create the tableau)\n\n# Draw the circuit\n\nThis is a bit more involved, just now I am using IJulia to provide the rich notebook needed to see the circuit.\n\nTo install IJulia, full instructions can be found here: https://github.com/JuliaLang/IJulia.jl but the summary is this\n\n- You need to have installed ipython, simplest way to do this is install pip if you haven't already and then\n\n     sudo pip install ipython[all]\n\nYou might also want to install scipy and numpy whilst you are at it, I am going to use them sometime (fer sure)\n\n- Then from within julia \n\n    Pkg.add(\"IJulia\")\n\n  If there are any errors fix it and Pkg.build(\"IJulia\") until it builds (it will!)\n\n````\n  using IJulia\n  notebook()\n````\ngets it up and running.\n\nYou will also need from within Julia to add the ImageView package Pkg.add(\"ImageView\")\n\nHere is a sample IJulia session showing how to use the new drawcircuit functionality. This might be out of date, use the stabiliser run through notebook in preference.\n\n[IJulia example notebook](http://rharper2.github.io/Juqst/Example%20of%20Draw%20Circuit.html)\n\nAnother example book showing how to use the new \"rationalise\" and bruteForce methods [Minimise Gates](http://rharper2.github.io/Juqst/minimiseGates.html)\n\n    getState(state) \n\nIs a simple funciton that returns the state the tableau is in vis-a-vis the Aarosnon/Gottesman decomposition algorithm.\n\n\n\n\n\n\n", 
  "id": 23531755
}
{
  "read_at": 1462553195, 
  "description": "", 
  "README.md": "Lock-free hash array mapped trie in Rust\n----------------------------------------------------------------------\n[![Build Status](https://travis-ci.org/ballard26/concurrent-hamt.svg?branch=master)](https://travis-ci.org/ballard26/concurrent-hamt)\n\nA naive/experimental implementation of a concurrent HAMT using \nHazardPointers for safe memory deallocation and an exponential back-off \nalgorithm for basic memory contention management.\n\nUsage\n----------------------------------------------------------------------\nTo use create a new HAMT then simply clone it into any process. The clones\nconnect to the same structure and once all clones and the original are\ndropped the structure will be deallocated.\n\nAdd this to your Cargo.toml:\n```toml\n[dependencies.hamt]\ngit = \"https://github.com/ballard26/concurrent-hamt\"\n```\n\nAnd then an example usage:\n```rust\nextern crate hamt;\n\nuse hamt::hamt::HAMT;\n\nfn main() {\n    let amt: HAMT<uint, uint> = HAMT::new();\n\n    for a in range(0, 10u) {\n        let cloned_amt = amt.clone();\n        spawn(proc() {\n            for x in range(a*100, (a+1)*100u) { \n                cloned_amt.insert(a, a);\n            }\n        });\n    }\n}\n```\n\nTodo\n----------------------------------------------------------------------\nCheck the top of every source file for a todo list. All comments and \ncontributions are more than welcome.\n\nNotes\n----------------------------------------------------------------------\nCompatibility\n- This project was only tested on OS X and Linux, no guarantee it will work on Windows.\n- As with above it was also only tested on x64_86 and x86. It will most likely work on \n  ARM platforms supported by the LLVM atomic intrinsics and Rust's standard lib.\n\nError Handling\n- Any errors that arise from deterministic misuse problems will fail!().\n    E.g. a ProtectedPointer must be loaded before it's read, loads never \n    fails if usage conditions are met, hence the program will fail!() if\n    an unloaded ProtectedPointer is read.\n- All other errors are handled with the Result type since they arise\n  due to the non-deterministic nature of a specific event.\n    E.g. when replacing a value in ProtectedPointer it is impossible to determine\n    if a value you expect to be there still is, hence a Result value is returned.\n\nSources Referenced\n----------------------------------------------------------------------\nBagwell, Phil (2000). \"Ideal Hash Trees\".\n<br>&nbsp;&nbsp;&nbsp;Infoscience Department, Ecole Polytechnique Federale de Lausanne.\n<br>Prokopec, A., Bronson N., Bagwell P., Odersky M. (2011).\n<br>&nbsp;&nbsp;&nbsp;\"Concurrent Tries with Efficient Non-Blocking Snapshots\".\n<br>Andrei Alexandrescu and Maged Michael (2004).\n<br>&nbsp;&nbsp;&nbsp;\"Lock-Free Data Structures with Hazard Pointers\". Dr Dobbs.\n<br>Dave Dice, Danny Hendler, Ilya Mirsky (2013).\n<br>&nbsp;&nbsp;&nbsp;\"Lightweight Contention Management for Efficient Compare-and-Swap Operations\".\n<br>&nbsp;&nbsp;&nbsp;arXiv:1305.5800.\n", 
  "id": 22531860
}
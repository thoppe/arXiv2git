{
  "read_at": 1462556902, 
  "description": "", 
  "README.md": "Description\n===========\nClass project to prove classical computers aren't any less powerful\nthan D-Wave One. Solve the combinatorial optimization problem with\nbetter success probabilities and lower running times.\n\nFiles\n--------\n* download.pl - Script to download the test files from \n[Arxiv](http://arxiv.org/src/1305.5837v1/anc/). The zipped file\nwasn't extracting properly for me, so had to do this.\n\n* sa.pl - Version 1 of the classical Simulated Annealing algorithm.\nGets good success probabilities. Running time = 4s (per run).\n\n* sa2.pl - Version 2. Implementation optimized to reduce running\ntime to 0.8s.\n\n* sa3.c - Version 3. Translation of version 2 in C.\nRunning time = 50ms.\n\n* sa4.c - Version 4 (LATEST). Slightly more optimized than (3),\nand should be compiled with `gcc -O3`. Running time = 35ms.\n\n* admin.pl - Wrapper script for invoking the executable for\ndifferent test instances.\n\n* results/ - Folder with csv data and graphs from 4 different\nruns-per-test-instance values R = {1, 10, 100, 1000}. The official\nR is 1000, and that's what I use to interpret the results.\n\nAlgorithm\n==========\nClassical Simulated Annealing with MAX = 1000000 (one million)\niterations. The minimum energy found over the course of the\niterations is returned as its output.\n\nIterations\n-----------\nSmaller values of MAX (like 100000, 10000, 1000) didn't give\ncomparably good results, and higher values didn't improve the\nsuccess probabilities to an extent that they were worth the\nhigher running costs. Hence this sweet spot :)\n\nTemperature Schedule\n-------------------------\n* Initial Temperature T0 = 1\n* Final Temperature   Tf = 0\n* Temperature Change  dT = (Tf - T0) / MAX = - 0.000001\n* Cooling down formula: T = T + dT\n  - Turned out it is better to cool down **only** when a higher\nenergy state has been accepted.\n  - This happens in 10% of the iterations, so roughly 100K times.\n  - In other cases, (rejecting flip or accepting lower energy state)\nleave the temperature unchanged.\n\n\nOptimizations\n--------------\nThe key observations in improving the running time of the\nalgorithm were the following.\n\n* Every iteration calculates the energy change dH brought about\nby a single spin flip. That's MAX = 1 million calculations.\n* The spin flip is \"in the air\" unless it is accepted, and that\nhappens only 10% of the time. So, 90% of all spin flips are \nrejections and are not worth actually *doing*.\n* Turns out that selecting particles (to flip spin) *sequentially*\nperformed as good as when they were chosen at random.\n\nThe equivalent changes were then:\n\n1. dH calculation was reduced to a *single* lookup.\n2. Data-structure-wise, spin flips were only really done when\n*accepted*.\n3. Sequential particle selection eliminated the cost of one `rand()`\ncall per iteration.\n\n(1), (2) reduced the run time from 4s to 0.8s in Perl, and to .05s\nin C. Adding (3) reduced the run time to .035s (35ms) in C.\n\nFuture Optimizations\n------------------------\nThere are currently two big cost contributors, each consuming about\nhalf of the total run time.\n\n1. The evaluation of `(rand() / RAND_MAX) < exp(- dH / T)`.\n2. Spin save and the associated energy contribution updates for\nneighboring particles.\n\nPossible solutions.\n* Faster Pseudo-Random Number Generators than `rand()` can be used.\nThese are based on Intel's SSE instruction set.\n* Unsure. But something smarter than what I could come up with :) \n\nResults\n===========\nExecutable : `gcc -O3 sa4.c -lm`.\n\nLaptop     : Lenovo G580 with Intel CPU i5-3210M @ 2.50GHz\n\n* Run Time\n  1. With 1000 test instances and 1000 runs-per instance, the total\ntime taken was 33169 seconds, giving an average run time of 33ms.\n  2. No parallel threading. One process/main-thread 'a.out' ran tests\nsequentially.\n  3. To compare, D-Wave One has a 2.5s cooling time + 15us annealing\ntime = 2.5s per run.\n\n* Success Probability **p(s)**\n  1. Compared instance-by-instance, the **p(s)** values are greater\nthan D-Wave One's on 995 out of the 1000 test instances.\n  2. In 2 of the remaining 5 instances, both D-Wave and the simulated\nannealing algorithm achieve probability 1, and so couldn't beat each\nother :)\n\nConclusion\n-----------\nThis was a very good exercise in getting to understand the apparent\npower and potential of D-Wave One.\n", 
  "id": 14092210
}
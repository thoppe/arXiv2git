{
  "read_at": 1462557222, 
  "description": "", 
  "ReadMe.txt": "Copyright (c) 2014 Visesh Chari, Simon-Lacoste Julien, Ivan Laptev, Josef Sivic.\n\nLICENSING TERMS\n\nThis program is granted free of charge for non-commercial research and\neducation purposes. However you must obtain a license from the author\nto use it for commercial purposes.\n\nScientific results produced using the software provided shall\nacknowledge the use of this code. Please cite as\n\nVisesh Chari, Simon-Lacoste Julien, Ivan Laptev, Josef Sivic\n\"On Pairwise Cost for Multi-Object Network Flow Tracking\"\nArXiv, July, 2014\n\nMoreover shall the author of code be informed about the\npublication.\n\nThe software and derivatives of the software must not be distributed\nwithout prior permission of the author.\n\nBy using this code you agree to the licensing terms.\n\n\nNO WARRANTY\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT\nWHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER\nPARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND,\nEITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\nPROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME\nTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF\nTHE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO\nLOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY\nOTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGES.\n\n\n----------------------------------------------------------------------------------\n\nOBTAINING:\nThis code can be downloaded from the following url\n\tURL:\n\nDEPENDENCIES:\n\tThis code requires the installation of CPLEX. CPLEX is an optimization\n\tsoftware with license provided FREE FOR ACADEMIC PURPOSES by IBM.\n\tYou can download CPLEX by following this link.\n\n\thttp://www.ibm.com/developerworks/downloads/ws/ilogcplex/index.html?cmp=dwenu&cpb=dwweb&ct=dwcom&cr=dwcom&ccy=zz\n\n\tCheck out the IBM Academic initiative to get a free license.\n\n\thttp://www-304.ibm.com/ibm/university/academic/pub/page/ban_ilog_programming\n\nUNPACKING:\n\tUnpack the tar file using the command in linux\n\t> tar -xvzf pairwisecost.tar.gz\n\n\tThis should create a directory \"PairwiseCost\" in the folder you execute\n\tthis operation in..\n\n\tMove into the folder\n\t> cd PairwiseCost\n\n\tYou should see five directories\n\t> ls\n\tdisplayfuncs - codes for displaying\n\tgreedycode - code by Deva et al. for greedy optimization [1]\n\tscripts - sample scripts for running the entire optimization\n\tutils - utility functions\n\tutilsopt - utility functions for the optimization\n\nCOMPILING:\n\n\tOpen MATLAB, and go to the \"PairwiseCost\" folder.\n\tFirst run\n\t> pathadd\n\n\tThis should add all the required paths to your PATH variable in MATLAB.\n\t\n\tCompile using the command\n\t> make\n\n\tThis should compile the mex files in the code.\n\n\t> demo\n\tThis runs the sample example and shows the result. Please wait a few minutes for the code to\n\tcomplete. It might take time depending on the system. We tried/tested this code\n\ton linux machines with over 8GB of RAM. We suggest you do the same.\n\nUSAGE:\n\n\tUsage of this code for your own purposes requires understanding of two main things\n\t1) How to setup the datastructures required for optimization.\n\t2) How to setup the constraint functions.\n\n\t1) How to setup the datastructures.\n\n\t\tOptimization variable: The optimization variable consists of 4 components. Let n be the\n\t\tnumber of detections and m be the number of edges. Then the optimization variable \n\t\tis of size [m + n + 2*n + k] x 1, \n\t\twhere k is the number of constraint variables. The first m variables denote edge selections,\n\t\t& the next n denote detection selections. The next 2*n variables denote selections of \n\t\tconnections between each detection and the dummy source and sink. The final k denote\n\t\tselection of constraint variables.\n\n\t\tIn order to setup the optimization, we first have to define the 'param' structure. This\n\t\tis done by using the command.\n\n\t> param = SetUpOptimVarsAndConstraints( detections, edges, framenums ) \n\t\tdetections \t- a matrix of size n x 5 in which the first 4 columns denote the top-left and\n\t\t\t\t\tbottom right corners of each detection, and the 5th column denotes the\n\t\t\t\t\tconfidence. Each row of this variable represents 1 detection.\n\t\t\t\t\tIts format is thus [x11 y11 x12 y12 c1; ....; xn1 yn1 xn2 yn2 cn] ;\n\t\tedges\t\t- a matrix of size m x 3 in which the first 2 columns are indices into the\n\t\t\t\t\trows of the detections variable. The last column is edge confidence.\n\t\t\t\t\tIts format is [i11 i12 e1; ...; im1 im2 em] ;\n\t\tframenums\t- a matrix of size n x 1 where each element is a number that denotes the frame\n\t\t\t\t\t\tnumber that the corresponding detection belongs to i.e. the ith element\n\t\t\t\t\t\tof this matrix gives the frame number of the detection in the \n\t\t\t\t\t\tith row of 'detections' matrix.\n\t\tNOTE: 1) Always structure edges such that framenums( edges(i, 1) ) < framenums( edges(i, 2) ) \n\t\t\t  2) Please avoid duplicating edges, since this will create many separate variables\n\t\t\t  \t\tfor 1 edge in the actual graph.\n\n\tparam datastructure contains all the elements needed to run the optimization procedure.\n\tLook at step 2 to see how to create constraint functions.\n\tThe variable 'param.nConstraints' stores the different type of constraints you have defined.\n\tNOTE: param.nConstraints is NOT EQUAL to 'k' mentioned above. param.nConstraints represents\n\tthe type of constraints you have added. For example, lets say you add two types of constraints,\n\ttemporal and spatial. There are 1000 temporal variables and 2000 spatial variables. Then\n\tk = 3000 and param.nConstraints = 2. See paper for more details.\n\n\tAt this point, you might want to save the 'param' variable in a mat file, since this structure\n\tnow contains all variables needed to perform the optimization (except weights).\n\n\tNext, we set the weights of these variables using the sparse function. \n\t> weights.model.w = sparse([1, 0, 1, 0, 0, 0])' ; % sample weight, general idea is 4 + 2*param.nConstraints\n\tThe weights structure stores the weights that you might want to give for 'scaling' and 'biasing'\n\tdifferent elements of the optimization. The different elements are 'edges', 'detections',\n\t'constraints'\n\t\n\t'edges' \t\t- The first two elements in 'w' store the scaling and bias given to edge variables.\n\t\t\t\t\tThus in the optimization, an edge confidence ei is multiplied by the scaling variable and added\n\t\t\t\t\tto the bias variable. \n\t'detections' \t- The next two elements in 'w' store scaling and bias given to detection\n\t\t\t\t\tvariables. Detection confidences are then modified the same way as edge\n\t\t\t\t\tconfidences in the optimization.\n\t'constraints'\t- The next 2*param.nConstraints variables in 'w' store scaling and bias given to constraint\n\t\t\t\t\t\tvariables. They are stored in the format [scaling1, bias1, scaling2, bias2, ...]'\n\t\t\t\t\t\tConstraint variables are then scaled and biased accordingly.\n\n\tFinally, you can perform the optimization by calling the following function.\n\t> [yint, ypred] = predict( param, weights ) ;\n\tIt returns two variables, 'yint' and 'ypred'\n\t'yint' \t\t\t- Optimization variable representing integer solution, obtained after final\n\t\t\t\t\t\tFrank-Wolfe rounding step. See paper for details. This is the output you\n\t\t\t\t\t\tgenerally want.\n\t'ypred'\t\t\t- Optimization variable containting fractional solution before running the \n\t\t\t\t\t\tFrank-Wolfe rounding step. Generally its a good practice to check the\n\t\t\t\t\t\tdifference between them to assess how far the integer solution is from\n\t\t\t\t\t\tthe fractional solution.\n\t\t\t\t\t\tThe 'predict' function normally outputs some statistics of how good \n\t\t\t\t\t\tthe rounding has been, but we provide the fractional solution additionally\n\t\t\t\t\t\tso that you can run your own tests if/when needed. Its also generally\n\t\t\t\t\t\ta good idea to save both solutions.\n\n\tFinally, you now need to convert the optimization output into a datastructure that you can\n\tvisualize/evaluate. This command converts the optimization variable to such a datastructure.\n\t> opttracks = findalltracks( yint([param.optstruct.detids param.optstruct.connids]), ...\n\t\t\t\t\tparam.ndets, param.ntrcks, param.edge_xi, param.edge_xj, ...\n\t\t\t\t\tparam.edgemat, param.nedgs, param.alldets ) ;\n\t> dresdp = convert_opttracks_to_dres( opttracks, param.xs ) ;\n\n\tdresdp is now a datastructure that contains the following fields.\n\tdresdp.x \t\t- matrix of size n x 1 containing top-left x-coordinate of all detections.\n\tdresdp.y \t\t- matrix of size n x 1 containing top-left y-coordinate of all detections.\n\tdresdp.w \t\t- matrix of size n x 1 containing width of all detections.\n\tdresdp.h \t\t- matrix of size n x 1 containing height of all detections.\n\tdresdp.fr \t\t- matrix of size n x 1 containing frame number of all detections.\n\tdresdp.id \t\t- matrix of size n x 1 containing track number of all detections (-1 denotes detections not selected)\n\tdresdp.hogconf \t- matrix of size n x 1 containing confidences of all detections (includes edge confidences)\n\n\tYou can now evaluate your solution w.r.t the ground truth. Check demo.m to see details on how\n\tto do this.\n\n\t2) Setting up a constraint function\n\tA constraint function is of the form\n\tQ_data = constraintFunction( variable arguments designed by user )\n\t\tQ_data is a matrix of the form k x 3, where there are k number of pairwise constraints. Each\n\t\trow of Q_data is of the form [v11 v12 k1] where\n\t\tv1 and v2 denote the two optimization variables (edges or detections) that form a pairwise\n\t\tconstraint. k1 denotes the penalty of selecting v1 and v2 simultaneously. \n\t\tFor example, let us say we want to enforce the pairwise cosntraint\n\t\t'Edge 1 and Detection 10 must always be selected simultaneously'\n\t\tIn such a case v1 = 1 (edge number 1)\n\t\tv2 = m + 10 (since optimization contains edge variables first, the 10 detection is\n\t\t\t\t\trepresented by the variable number m + 10 in 'yint' and 'ypred')\n\t\tk1 = -ve number (because we want to give a 'boost' to joint selection. If you want\n\t\t\t\t\t\tto supress, give a +ve number).\n\n\t\tYou can model your constraint function by using already implemented examples available in\n\t\tthe directory 'utilsopt/Constraints'\n\n\t\tFinally, you have to edit SetUpOptimVarsAndConstraints.m, to add your function to the \n\t\toptimization process. There are sample constraints already added in the file. Please\n\t\tedit it to add your own.\n\n\t3) Plotting functions\n\t\tplotTracks( dresdp ) - plots tracks, with each track in different color.\n\t\tshowboxes( im, bxs ) - overlays bounding boxes onto images.\n\t\tshowboxes( im, bxs, clrs ) - shows each box with a different color, specified by the nx3\n\t\t\t\t\t\t\t\t\tmatrix clrs. 0.0 <= clrs(i) <= 1.0\n\t\t\t\t\t\t\t- see demoscript.m for an example on how to use this function\n\t\t\t\t\t\t\t\t\tto show tracks overlayed on a set of images.\n\t\t\t\t\t\t\t- save these images and use a function like mencoder to create a result\n\t\t\t\t\t\t\t\t\tvideo for tracking. \n\nIf you have any questions please email Visesh Chari. You can find his email id\nat http://www.di.ens.fr/~chari\n", 
  "id": 27819797
}
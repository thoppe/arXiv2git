{
  "README": "\n           Anant  -- Algorithmic 'n Analytic Number Theory\n           -----------------------------------------------\n                           Version 0.2.1\n                      Linas Vepstas April 2012\n                       linasvepstas@gmail.com\n\n\nThis project contains ad-hoc implementations of assorted analytic\nfunctions of interest in number theory, including the gamma function,\nthe Riemann zeta function, the polylogarithm, and the Minkowski\nquestion mark function. The implementation uses the Gnu Multi-Precision\nlibrary (GMP) to perform all low-level operations.  The code herein\nis licensed under the terms of the Gnu GPLv3 license.\n\nThis project is *NOT* meant to be a replacement for other, more\nestablished multi-precision systems, such as PARI/GP.  It is meant to\nbe a staging area for implementations of functions that have not (yet)\nreceived much attention in the more established packages. Users are\nstrongly encouraged to port the contents of this package to other\nsystems.\n\nA note about floating-point exceptions: many of the special functions\ncomputed here have poles at various values.  These will show up as\nmysterious floating-point exceptions deep within the code.  If you\nget an exception, make sure you are not evaluating a function at a pole!\n\nThis package has its origins as a collection of tools & utilities for\nthe benefit of the author.  As such, it was never really intended for\npublic consumption, and thus, will not have the usual amenities of\nestablished projects, such as clear documentation, a website, unit\ntest cases, or even a robust build system.  Caveat Emptor!\n\nThere are several publications that describe this code, or make use of\nit. The most notable is this:\n\nVepstas, L. (2008) \"An efficient algorithm for accelerating\nthe convergence of oscillatory series, useful for computing the\npolylogarithm and Hurwitz zeta functions\". Numerical Algorithms\nvol. 47 issue 3: pp. 211-252. arXiv:math.CA/0702243.\ndoi:10.1007/s11075-007-9153-8.\n\nSupported functions\n-------------------\nMany of the functions below are not \"difficult\"; what makes the code\nhere unique is that many of these using caching and partial computation\nto avoid repeated computations. In some cases, the functions are\nparticularly fast when called in \"sequential\" order, as would naturally\noccur in summations.\n\nArbitrary precision constants:\n------------------------------\n* sqrt(3)/2, log(2)\n* e, e^pi\n* pi, 2pi, pi/2, sqrt(2pi), log(2pi), 2/pi\n* Euler-Mascheroni const\n* Riemann zeta(1/2)\n\nCombinatorial functions:\n------------------------\n* Rising pochhammer symbol (integer)\n* Reciprocal factorial\n* Sequential binomial coefficient\n* Stirling Numbers of the First kind\n* Stirling Numbers of the Second kind\n* Bernoulli Numbers\n* Binomial transform of power sum\n* Rising pochhammer symbol (real)    i.e. (s)_n for real s\n* Rising pochhammer symbol (complex) i.e. (s)_n for complex s\n* Binomial coefficient (complex)     i.e. (s choose n) for complex s\n\nElementary functions:\n---------------------\n* pow, exp, log, sine, cosine, tangent for real, complex arguments\n* arctan, arctan2 for real argument\n* log(1-x) for real, complex x\n* sqrt for complex argument\n\nClassical functions:\n--------------------\n* gamma (factorial) for real, complex argument\n* polylogarithm, using multiple algorithms: Borwein-style, Euler-Maclaurin\n* polylogarithm on multiple sheets (monodromy)\n* Periodic zeta function\n* Hurwitz zeta function, using multiple algorithms; complex arguments.\n* Riemann zeta function, using multiple algorithms: Borwein, Hasse, brute-force\n  for integer, real and complex arguments.\n* Confluent hypergeometric function, complex arguments\n\nNumber-theoretic functions:\n---------------------------\n* General complex-valued harmonic number\n* Gauss-Kuzmin-Wirsing operator matrix elements\n* Minkowski Question Mark function (Stern-Brocot tree), and its inverse\n* Taylor's series coefficients for the topologist's sin -- sin(2pi/(1+x))\n\nUtilities:\n----------\n* Powell's method for zero-finding on complex plane (noise-cancelling variant).\n\n\nPre-requisites, Compiling, Installing, Testing\n----------------------------------------------\nThis package requires a copy of the Berkeley DB database to be\navailable. The database is used to cache certain intermediate values, to\nimprove performance of various internal algorithms.\n\nThis package has minimal build support. cd to the src directory, and\n'make'.  If you want to install the files somewhere, you will have to do\nthis by hand, or custom-tailor to suit your needs.\n\nThere is a unit test, rather ad-hoc in nature, and it is not\n\"user-freindly\".  It will report some errors in the last few decimal\nplaces of various routines, depending on how it was invoked. It is up\nto you to figure out if these are serious errors or not.  Caveat Emptor!\n\n(I mean, its 'error-free' for me, i.e. 'good enough'.  There is nothing\nin here that is horribly broken, as far as I know.  If quibbling over\nthe last few decimal places is important to you, you might have a\ndifferent opinion.)\n\n\nPrecision\n---------\nMost of the algorithms deal with precision issues in a fairly ad-hoc\nkind of way.  Many/most routines require an argument specifying the\nnumber of decimal places of desired precision, and will typically\nreturn answers that are accurate from about 90% to 100% of the specified\nprecision. However, many of the algorithms use internal, intermediate\nresults that need to be maintained at a higher level of precision than\nthe \"desired\" precision. Thus, correct usage requires that the user\nspecify an mpf_set_default_prec() that is 10% to 50% larger than the\ndesired precision of the results.  The proper amount to use is up to\nyou to figure out!  A reasonable rule-of-thumb seems to be to use\nmpf_set_default_prec(5*desired_decimal_places) -- noting that log_2(10)\nis 2.3.\n\n\nExample Usage\n-------------\nThe below provides an example of how to use the functions in this\nlibrary.\n\n      // Standard include headers\n      #include <gmp.h>\n      #include <stdio.h>\n      #include \"mp-polylog.h\"\n      #include \"mp-misc.h\"\n\n      int main()\n      {\n         cpx_t plog, ess, zee;  // Complex variant of mpf_t\n         int nbits;\n         int decimal_prec;\n\n         // decimal_prec is the number of decimal places of desired\n         // precision.\n         //\n         // 3.3 is equal to log_2(10), and is used to convert decimal\n         // places to number of binary bits.\n         //\n         // The +600 adds some extra \"padding precision\" for\n         // intermediate calculations. Most algorithms require some\n         // fair amount of additional bits of precision to be used in\n         // computing intermediate results.  The precise amount needed\n         // is somewhat ad-hoc, and not well-characterized for the\n         // different functions; typically, an extra 20% to 50% is\n         // needed.\n         //\n         decimal_prec = 500;\n         nbits = 3.3*decimal_prec + 600;\n         mpf_set_default_prec (nbits);\n\n         // Initialization\n         cpx_init (plog);\n         cpx_init (ess);\n         cpx_init (zee);\n\n         // Set values for which computation will be done.\n         cpx_set_d(ess, 2.1, 0.0);\n         cpx_set_d(zee, 0.5, 0.0);\n\n         // Compute ...\n         int rc = cpx_polylog(plog, ess, zee, decimal_prec);\n\n         // Check for error conditions\n         if (0 != rc)\n         {\n         \tprintf(\"Error occured during computation! rc=%d\\n\", rc);\n         \treturn 1;\n         }\n         cpx_prt(\"Answer is \", plog);\n         printf(\"\\n\");\n\n         return 0;\n      }\n\n\nCurrent repository:\n-------------------\nin Bazaar, on Launchpad:\n   https://launchpad.net/anant\n\nin Git, on Github:\n   https://github.com/linas/anant\n\nSource tarballs are available there too.\n", 
  "read_at": 1462556632, 
  "description": "Analytic Number Theory high-precision GnuMP routines", 
  "id": 43644876
}
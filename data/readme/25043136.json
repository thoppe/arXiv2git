{
  "read_at": 1462511049, 
  "description": "CorEx or \"Correlation Explanation\" constructs a hierarchy of maximally informative representations of complex data.", 
  "README.md": "#Correlation Explanation (CorEx)\n\nThe principle of *Cor*-relation *Ex*-planation has recently been introduced as a way to build rich representations that\nare maximally informative about the data. This project consists of python code to build these representations.\n\nA preliminary version of the technique is described in this paper.      \n*Discovering Structure in High-Dimensional Data Through Correlation Explanation*    \nGreg Ver Steeg and Aram Galstyan, NIPS 2014, http://arxiv.org/abs/1406.1222        \n\nSome theoretical developments are described here:      \n*Maximally Informative Hierarchical Representions of High-Dimensional Data*    \nGreg Ver Steeg and Aram Galstyan, AISTATS 2015, http://arxiv.org/abs/1410.7404   \n\nThe code here is written by Greg Ver Steeg and Gabriel Pereyra. \n\nCurrent version implements only the techniques of the first paper. \nAdditional theoretical developments appear in the second paper and more are underway. \nNew functionality will be added over time. \n\n###Dependencies\n\nCorEx requires numpy and scipy. If you use OS X, I recommend installing the Scipy Superpack:             \nhttp://fonnesbeck.github.io/ScipySuperpack/\n\n###Install\n\nTo install, download using the link on the right or clone the project by executing this command in your target directory:\n```\ngit clone https://github.com/gregversteeg/CorEx.git\n```\nUse *git pull* to get updates. The code is under development. \nPlease feel free to raise issues or request features using the github interface. \n\n## Basic Usage\n\n### Example\n\n```python\nimport corex as ce\n\nX = np.array([[0,0,0,0,0], # A matrix with rows as samples and columns as variables.\n              [0,0,0,1,1],\n              [1,1,1,0,0],\n              [1,1,1,1,1]], dtype=int)\n\nlayer1 = ce.Corex(n_hidden=2)  # Define the number of hidden factors to use.\nlayer1.fit(X)\n\nlayer1.clusters  # Each variable/column is associated with one Y_j\n# array([0, 0, 0, 1, 1])\nlayer1.labels[0]  # Labels for each sample for Y_0\n# array([0, 0, 1, 1])\nlayer1.labels[1]  # Labels for each sample for Y_1\n# array([0, 1, 0, 1])\nlayer1.tcs  # TC(X;Y_j) (all info measures reported in nats). \n# array([ 1.385,  0.692])\n# TC(X_Gj) >=TC(X_Gj ; Y_j)\n# For this example, TC(X1,X2,X3)=1.386, TC(X4,X5) = 0.693\n```\n\n### Data format\n\nFor the basic version of CorEx, you must input a matrix of integers whose rows represent samples and whose columns\nrepresent different variables. The values must be integers {0,1,...,k-1} where k represents the maximum number of \nvalues that each variable, x_i can take. By default, entries equal to -1 are treated as missing. This can be \naltered by passing a *missing_values* argument when initializing CorEx. \n\n### CorEx outputs\n\nAs shown in the example, *clusters* gives the variable clusters for each hidden factor Y_j and \n*labels* gives the labels for each sample for each Y_j. \nProbabilistic labels can be accessed with *p_y_given_x*. \n\nThe total correlation explained by each hidden factor, TC(X;Y_j), is accessed with *tcs*. Outputs are sorted\nso that Y_0 is always the component that explains the highest TC. \nLike point-wise mutual information, you can define point-wise total correlation measure for an individual sample, x^l     \nTC(X = x^l;Y_j) == log Z_j(x)   \nThis quantity is accessed with *log_z*. This represents the correlations explained by Y_j for an individual sample.\nA low (or even negative!) number can be obtained. This can be interpreted as a measure of how surprising an individual\nobservation is. This can be useful for anomaly detection. \n\n\n### Generalizations\n\n#### Hierarchical CorEx\nThe simplest extension is to stack CorEx representations on top of each other. \n```\nlayer1 = ce.Corex(n_hidden=100)\nlayer2 = ce.Corex(n_hidden=10)\nlayer3 = ce.Corex(n_hidden=1)\nY1 = layer1.fit_transform(X)\nY2 = layer2.fit_transform(Y1)\nY3 = layer2.fit_transform(Y2)\n```\nThe sum of total correlations explained by each layer provides a successively tighter lower bound on TC(X). \nThis will be detailed in a paper in progress. To assess how large your representations should be, look at quantities\nlike layer.tcs. Do all the Y_j's explain some correlation (i.e., all the TCs are significantly larger than 0)? If not\nyou should probably use a smaller representation.\n\n#### Missing values\nYou can set missing values (by specifying missing_values=-1, when calling, e.g.). CorEx is very robust to missing data.\nThis hasn't been extensively tested yet so be careful with this feature. (E.g., while the distribution of missing values\nshould not matter in principle, it does have an effect in this version.)\n\n#### Future versions\nWe are currently testing extensions that allow for arbitrary data types such as continuous variables. \n\n## Visualization\n\nSee http://bit.ly/corexvis for examples of some of the rich visualization capabilities. \nEventually, these will be added here. \n", 
  "id": 25043136
}
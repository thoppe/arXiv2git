{
  "README": "This act implements a nested-interval tree. You can find all descendants or all\nancestors with just one select query. You can insert and delete records without\na full table update.\n\nThis act requires a \"parent_id\" foreign key column, and \"lftp\" and \"lftq\"\ninteger columns. If your database does not support stored procedures then you\nalso need \"rgtp\" and \"rgtq\" integer columns, and if your database does not\nsupport functional indexes then you also need a \"rgt\" float column. The \"lft\"\nfloat column is optional.\n\nExample:\n  create_table :regions do |t|\n    t.integer :parent_id\n    t.integer :lftp, :null => false\n    t.integer :lftq, :null => false\n    t.integer :rgtp, :null => false\n    t.integer :rgtq, :null => false\n    t.float :lft, :null => false\n    t.float :rgt, :null => false\n    t.string :name, :null => false\n  end\n  create_index :regions, :parent_id\n  create_index :regions, :lftp\n  create_index :regions, :lftq\n  create_index :regions, :lft\n  create_index :regions, :rgt\n\nThe size of the tree is limited by the precision of the integer and floating\npoint data types in the database.\n\nThis act provides these named scopes:\n  roots -- returns roots of tree.\n  preorder -- returns records for preorder traversal.\n\nThis act provides these instance methods:\n  parent -- returns parent of record.\n  children -- returns children of record.\n  ancestors -- returns scoped ancestors of record.\n  descendants -- returns scoped descendants of record.\n  depth -- returns depth of record.\n\nExample:\n  class Region < ActiveRecord::Base\n    acts_as_nested_interval\n  end\n\n  earth = Region.create :name => \"Earth\"\n  oceania = Region.create :name => \"Oceania\", :parent => earth\n  australia = Region.create :name => \"Australia\", :parent => oceania\n  new_zealand = Region.new :name => \"New Zealand\"\n  oceania.children << new_zealand\n  earth.descendants\n  # => [oceania, australia, new_zealand]\n  earth.children\n  # => [oceania]\n  oceania.children\n  # => [australia, new_zealand]\n  oceania.depth\n  # => 1\n  australia.parent\n  # => oceania\n  new_zealand.ancestors\n  # => [earth, oceania]\n  Region.roots\n  # => [earth]\n\nThe \"mediant\" of two rationals is the rational with the sum of the two\nnumerators for the numerator, and the sum of the two denominators for the\ndenominator (where the denominators are positive). The mediant is numerically\nbetween the two rationals. Example: 3 / 5 is the mediant of 1 / 2 and 2 / 3,\nand 1 / 2 < 3 / 5 < 2 / 3.\n\nEach record \"covers\" a half-open interval (lftp / lftq, rgtp / rgtq]. The tree\nroot covers (0 / 1, 1 / 1]. The first child of a record covers interval\n(mediant{lftp / lftq, rgtp / rgtq}, rgtp / rgtq]; the next child covers\ninterval (mediant{lftp / lftq, mediant{lftp / lftq, rgtp / rgtq}},\n                   mediant{lftp / lftq, rgtp / rgtq}].\n\nWith this construction each lftp and lftq are relatively prime and the identity\nlftq * rgtp = 1 + lftp * rgtq holds.\n\nExample:\n               0/1                           1/2   3/5 2/3                 1/1\n  earth         (-----------------------------------------------------------]\n  oceania                                     (-----------------------------]\n  australia                                             (-------------------]\n  new zealand                                       (---]\n\nThe descendants of a record are those records that cover subintervals of the\ninterval covered by the record, and the ancestors are those records that cover\nsuperintervals.\n\nOnly the left end of an interval needs to be stored, since the right end can be\ncalculated (with special exceptions) using the above identity:\n  rgtp := x\n  rgtq := (x * lftq - 1) / lftp\nwhere x is the inverse of lftq modulo lftp.\n\nSimilarly, the left end of the interval covered by the parent of a record can\nbe calculated using the above identity:\n  lftp := (x * lftp - 1) / lftq\n  lftq := x\nwhere x is the inverse of lftp modulo lftq.\n\nTo move a record from old.lftp, old.lftq to new.lftp, new.lftq, apply this\nlinear transform to lftp, lftq of all descendants:\n  lftp := (old.lftq * new.rgtp - old.rgtq * new.lftp) * lftp\n           + (old.rgtp * new.lftp - old.lftp * new.rgtp) * lftq\n  lftq := (old.lftq * new.rgtq - old.rgtq * new.lftq) * lftp\n           + (old.rgtp * new.lftq - old.lftp * new.rgtq) * lftq\n\nYou should acquire a table lock before moving a record.\n\nExample:\n  pacific = Region.create :name => \"Pacific\", :parent => earth\n  oceania.parent = pacific\n  oceania.save!\n\nAcknowledgement:\n  http://arxiv.org/html/cs.DB/0401014 by Vadim Tropashko.\n", 
  "read_at": 1462547066, 
  "description": "This act implements a nested-interval tree.", 
  "id": 82221
}
{
  "read_at": 1462547045, 
  "description": "high-order Geometric Multigrid using Hexahedral Finite Elements", 
  "README.md": "# HoMG\n\nHigh-order finite-element package using hexahedral elements. The code is a\ntestbed for geometric multigrid approaches for high order discretizations. The\ncurrent implementation supports setting up a combination of $h$ and $p$\nheirarchy. The following smoothers are supported,\n * Jacobi\n * Chebyshev-accelerated Jacobi\n * block Jacobi\n * Symmetric SOR \n\n[Project Page](http://hsundar.github.io/homg/)\n\nDetails about the implementation and a comparison of the different methods can\nbe found in   \n\n[Comparison of multigrid algorithms for high-order continuous finite element discretizations](http://onlinelibrary.wiley.com/doi/10.1002/nla.1979/abstract), _Hari Sundar, Georg Stadler, George Biros_, Numer. Linear Algebra Appl., doi: [10.1002/nla.1979](http://dx.doi.org/10.1002/nla.1979).\n\nor\n   \n[Comparison of Multigrid Algorithms for High-order Continuous Finite Element\nDiscretizations](http://arxiv.org/pdf/1402.5938v1) _Hari Sundar, Georg Stadler, George Biros_\n[arXiv](http://arxiv.org/abs/1402.5938)\n\n\n## Basic Usage\n\nA simple example in 2D\n```matlab\n\n% specify the coefficients\nmu = @(x,y)(1 + 1e6*( cos(2*pi*x)^2 + cos(2*pi*y)^2 ) );\n\n% create the mesh heirarchy, for a warped mesh\n% in this case we create a h+p heirarchy\n%     grid 4 --> 32x32, p=4  (finest)\n%     grid 3 --> 32x32, p=2      \n%     grid 2 --> 32x32, p=1\n%     grid 1 --> 16x16, p=1\n%     grid 0 -->  8x8,  p=1  (coarsest)\n\ng = create_hexmesh_grids(2, mu, @homg.xform.shell, [1 2 4], [8 16 32]);\n\n% now solve using multigrid as the solver and the choice of smoother\ng.solve (150, 'jacobi', 3,3, g.L, g.get_u0);\ng.solve (150, 'chebyshev', 3,3, g.L, g.get_u0);\ng.solve (150, 'ssor', 2,1, g.L, g.get_u0);\n\n% or solve using CG preconditioned using multigrid\ng.solve_pcg(150, 'jacobi', 3,3, g.L, g.get_u0);\ng.solve_pcg(150, 'chebyshev', 3,3, g.L, g.get_u0);\ng.solve_pcg(150, 'ssor', 2,1, g.L, g.get_u0);\n\n```\nThe 3D example is similar with a few changes in the grid setup.\n\n```matlab\n\n% specify the coefficients\nmu = @(x,y,z)(1 + 10^6*( cos(2*pi*x)^2 + cos(2*pi*y)^2 + cos(2*pi*z)^2) );\n\n% create the mesh heirarchy, for a warped mesh\n% in this case we create a h+p heirarchy\n%     grid 4 --> 8x8x8, p=4  (finest)\n%     grid 3 --> 8x8x8, p=2      \n%     grid 2 --> 8x8x8, p=1\n%     grid 1 --> 4x4x4, p=1\n%     grid 0 --> 2x2x2, p=1  (coarsest)\n\ng = create_hexmesh_grids(3, mu, @homg.xform.shell, [1 2 4], [2 4 8]);\n\n% now solve using multigrid as the solver and the choice of smoother\ng.solve (150, 'jacobi', 3,3, g.L, g.get_u0);\ng.solve (150, 'chebyshev', 3,3, g.L, g.get_u0);\ng.solve (150, 'ssor', 2,1, g.L, g.get_u0);\n\n% or solve using CG preconditioned using multigrid\ng.solve_pcg(150, 'jacobi', 3,3, g.L, g.get_u0);\ng.solve_pcg(150, 'chebyshev', 3,3, g.L, g.get_u0);\ng.solve_pcg(150, 'ssor', 2,1, g.L, g.get_u0);\n\n```\n\nUsing low-order preconditioning for high-order operator in CG method\n\n```matlab\n\n% specify the coefficients for a 2D example\nmu = @(x,y)(1 + 10^6*( cos(2*pi*x)^2 + cos(2*pi*y)^2));\n\n% create low-order approximation based on nodes of high-order operator\n% we use a 2D unit square, discretized by 8 x 8 3rd-order elements\n% usually algebraic MG is used to solve the low-order system\n% here we use a direct solver\n\n[it0, it1, it3] = low_order_precon([8 8], @homg.xform.identity, 3);\n\n% Output is number of iterations with 0,1 or 3 Chebyshev smoothing steps\n% on the finest level using the high-order residual\n\n% And now for an example in 3D with warped geometry and 3x3x3 4th order elements\n\nmu = @(x,y,z)(1 + 10^6*( cos(2*pi*x)^2 + cos(2*pi*y)^2 + cos(2*pi*z)^2) );\n[it0, it1, it3] = low_order_precon([3 3 3], @homg.xform.shell, 4);\n\n\n```\n", 
  "id": 16155082
}
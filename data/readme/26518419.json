{
  "read_at": 1462553942, 
  "description": "Prototyping of a replacement for stacklets in Pixie. ", 
  "README.md": "## Effects System for Pixie Prototype\n\n### Motivation\n\nWhile the current Pixie interpreter works well it's pretty much just like any other mutable interpreter. But on the other\nhand we have the PyPy JIT generator that allows us to create interpreters modeled almost any way we want. What would a\ninterpreter look like in a \"perfect world\"?\n\nFor answers to such questions I suggest reading up on the language Eff (http://arxiv.org/pdf/1203.1539v1.pdf). This language\nspecifies an interesting language design, one that makes a distinction between side-effect-free computations, and effects that\nmodify the environment or the system. Having an interpreter that makes this distinction has several benefits:\n\n1) Any computation in the system could be hinted to the JIT as being pure, thus removable if the arguments to the computation\nare constants.\n\n2) Support for Generators, Exceptions, and Lightweight threads (among other things) could be added via this approach.\n\n3) With the ability to \"pause\" a thread and with all blocking IO segregated inside effects, the vm could easily integrate\nasync IO libraries such as libuv, removing the need for a GIL.\n\n4) If foreign functions are considered effects (as they should be) then FFI functions could be called in separate threads,\nallowing for parallel execution of C functions.\n\n5) The upcoming STM solution in PyPy works best for computations that do not perform IO. Once again, this effects system\nseparates code, allowing for better optimizations.\n\n6) If the interpreter is immutable, then really weird things can be done at runtime, including: forking a interpreter, resuming\nexceptions, re-running a step in the interpreter, even saving the interpreter's state to disk may be possible.\n\n### Roadmap\n\nAs of today, this POC is finished. It works, and the JIT produces very promising results (on par with the current JIT).\nThus it is now just a matter of refactoring the guts of Pixie to match the new coding styles. Thankfully not much in the\n `.lisp` files of pixie have to change.\n\n * Collections - Anything that calls into pixie or RT will need to be refactored with `@cps`\n * Reader - Will need to be completely refactored. Calling `rdr.read()` can now be an effect, that change will ripple through\n the rest of the system.\n * Compiler - Completely re-written, the new interpreter is an AST interpreter. This will however drastically simplify the compiler\n   as it will no longer have to track stacks, save constants, etc.\n * Interpreter - The AST nodes will replace the interpreter\n * RT - Completely rewritten, but since it uses vars, it should be simple to perform this\n\n\n### Does this mean we should halt work on Pixie?\n\nNo! Development of pixie can still continue, the changes will be merged in as possible to the new development branch.\n\n### CPS Transform\n\nThis project contains a very 'touchy' code transformer, known as `@cps`. This will take an RPython function or method and\ntransform it into an immutable state-machine via CPS transformation. As is expected with this sort of code mangling there\nare many caveats to using this transformer, but they are mostly simple to remember:\n\n* Calls to functions or methods that end with a single `_` are considered to be effect functions (functions that will either\n return Answer or an Effect). Thus at every call to such a function the transformer will create a continuation.\n* Generators/Iterators should be avoided. A single step of the function may be run many times, thus it is important to clone\n  any mutable state.\n* The call stack is not persisted across continuations, so be sure that the stack position is 0 at every effect function call.\nFor example:\n\n\n    @cps\n    def foo(x):\n      r = invoke_(x)\n      z = invoke_(r)\n      return z\n\n\nIs fine, while the following is not:\n\n\n    @cps\n    def foo(x):\n      return invoke_(invoke_(x))\n\n\nSince the outer `invoke_` will be loaded before the `inner_`.\n\n* Calls to effect functions that immediately return will be turned into tail calls, so prefer this style when possible:\n\n\n    @cps\n    def foo(x):\n      return invoke_(x)\n\n* Currently (until this restriction is removed) effect calls that take anything but locals as arguments are not supported.\n\n\n    @cps\n    def foo(x):\n      # works\n      x = invoke_(something)\n      # doesn't work\n      x = invoke_(something._zing)\n\n* `break` and `continue` require the stack to operate, and as such are not supported\n* Since functions are RPython and internally function locals are converted class fields, locals can only have one type. Unlike\nRPython that supports locals with conflicting types as long as they are redefined between usages.", 
  "id": 26518419
}
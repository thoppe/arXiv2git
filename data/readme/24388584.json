{
  "README": "RSVDPACK: Implementations of fast algorithms for computing the low rank SVD, \ninterpolative and CUR decompositions, using randomized sampling. \nGiven, a real mxn matrix A and a rank parameter \nk<< min(m,n) (or optionally, a tolerance parameter instead of rank) the \nrsvd routines compute  \nU_k, Sigma_k, and V_k\nwhere U_k is mxk, Sigma_k is kxk, and V_k is nxk, such that:\nA \\approx U_k Sigma_k V^T_k\n\nIncluded is a blocked randomized routine which computes a so called QB \ndecompositon of A such that,  \nA \\approx Q_k B_k, from which other decompositions may be efficiently computed.\n\nThe interpolative decomposition routines return a single or double sided ID of a matrix, \nwhile the CUR decomposition can decompose a matrix into the form A \\approx C U R \nwhere C and R contain a selection of the columns and rows, respectively of the \noriginal A.\n\nFor more detailed information on the implemented algorithms see:\nhttp://arxiv.org/abs/1502.05366\nhttp://arxiv.org/abs/1412.8447\nhttp://arxiv.org/abs/1503.07157\n\nThere are three codes: for single processor (with GNU GSL), multiprocessor \n(with Intel MKL) and GPU (with CULA library for NVIDIA CUDA capable cards).\nA simple implementation in Matlab (or Octave) is also provided for \nillustration purposes. The majority of the algorithms are currently implemented with \nthe multi-core Intel MKL version. The GPU version will soon receive updates \nand additional routines as well.\n\nIn addition, experimental Matlab mex-file support for the multi-core and \nGPU C codes is available with illustrating examples of calling some of the \nmulti-core and GPU functions.\n\nWritten by Sergey Voronin, 2014-2016 as part of a collaborative project with Per-Gunnar Martinsson.\nTested with GSL-1.16, icc/mkl 14.03, cuda 6.5, cula r18. Should also work \nwith more recent version of the software. \n\nAlgorithms used based on those originally described in the article: \n\"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions,\" N. Halko, P.G. Martinsson, J. Tropp, SIAM Review, 53(2), 2011\nand in the other mentioned articles, with some modifications. \nSee the arxiv articles for more details.\n\n============ summary of installation and usage ==============\n\nOne must install the GNU GSL development libraries, Intel MKL (and the intel C compiler), \nNVIDIA CUDA libraries and the CULA Dense packages. \nPlease refer to their corresponding documentations.\nhttp://www.gnu.org/software/gsl/\nhttps://software.intel.com/en-us/intel-mkl\nhttps://developer.nvidia.com/cuda-zone\nhttp://www.culatools.com/dense/\n\nNOTE on software: The GSL library is free to download and distributed under a GNU license. A free \nversion of the CULA library is available for download at \nhttp://www.culatools.com/downloads/ , which includes all the functions \nnecessary for RSVDPACK (matrix-matrix and matrix-vector ops, QR, SVD, etc). \nThe Intel MKL library is generally available in commercial form. \nThe free, non-commercial versions of the Intel MKL library and the \nC++ compiler can be obtained from Intel by qualified users. Please \nsee: https://software.intel.com/en-us/qualify-for-free-software .  \n\nFor simple illustration of the randomized SVD algorithms, see the \nMatlab implementation. Each C implementation resides in its own subfolder \nwith a compile.sh file. After \nnecessary paths (PATH variable, LD_LIBRARY_PATH) are set for referencing \ngsl, mkl, and cuda/cula, this file \nshould be modified to reflect any local system changes and executed to yield the \ndriver executable in each case. Paths for mkl are usually set via:\n$ source /opt/intel/bin/compilervars.sh intel64\nFor cuda/cula, source the script nvidia_gpu_cula_code/setup_paths.sh after checking \nthat the paths are correct for your system.  \n\nIn order to make a test matrix, use the provide make_matrix_binary.m script which can be run \nfrom Octave or Matlab. Note that this script writes a binary matrix file.\n\nOnce the matrix is made one can use any of the drivers to compute the low \nrank SVD or the ID and CUR decompositions. Inside the main loop of the programs one \nsets the rank k <= min(nrows,ncols) \nor the tolerance parameter if one of the autorank methods is used.\nAdditional parameters such as the block size apply to the block randomized methods.\n\nOne can call either algorithm I,II,III, or IV for computing the low rank SVD with \neach driver.\nEach of the codes also has three autorank functions based on version II and III \nof the randomized algorithm, for use when a good rank k to use is not known in advance.\nThus, there is a total of 6 functions for computing the low rank SVD. Algorithm IV \nis block based and uses the QB algorithm to construct Q instead of QR.\n\nAdditionally, for the multi-core and GPU architectures the following algorithms \nare also available:\nfull column pivoted QR from lapack (only for multi-core), \npartial column pivoted QR (using householder reflectors), \nsingle vector randQB with power method, and \nblocked randQB with power method.\n\nFor the multi-core architecture, the following routines are also \navailable: ID, double sided ID, CUR in full, randomized, and \nblock randomized form.\n\nSample calling procedure for the rsvd algorithms is as follows \n(similar for all 3 architectures).\n\n=======================\n\n// declare matrices and vectors\nmat *M, *U, *S, *V, *T, *S, *C, *R;\nvec *Icol, *Irow;\n\n// load matrix M from file\nM = matrix_load_from_binary_file(mfile);\nm = M->nrows; n = M->ncols;\n\n// set svd rank (< min(m,n)) if not using the autorank version\n// for autorank, define instead the TOL parameter (i.e. TOL = 0.1)\n// set rank, block size, oversampling, power scheme and orthogonalization parameters\nk = 300;\nkstep = 100;\np = 20;\nq = 2;\ns = 1;\n\n// call random SVD (use one of the six variants)\nrandomized_low_rank_svd1(M, k, &U, &S, &V);\nrandomized_low_rank_svd2(M, k, &U, &S, &V);\nrandomized_low_rank_svd3(M, k, q, s, &U, &S, &V);\nrandomized_low_rank_svd4(M, kblocksize, numblocks, q, &U, &S, &V);\nrandomized_low_rank_svd2_autorank1(M, frac, TOL, &U, &S, &V);\nrandomized_low_rank_svd2_autorank2(M, kblocksize, TOL, &U, &S, &V);\nrandomized_low_rank_svd3_autorank2(M, kblocksize, TOL, q, s, &U, &S, &V);\n\n// call ID, dsID, CUR block randomized routines\nid_decomp_fixed_rank_or_prec(M, k, TOL, &frank, &I, &T);\nid_two_sided_blockrand_decomp_fixed_rank_or_prec(M, k, p, TOL, kstep, q, s, &frank, &Icol, &Irow, &T, &S);\ncur_blockrand_decomp_fixed_rank_or_prec(M, k, p, TOL, kstep, q, s, &frank, &C, &U, &R);\n\n// write results to disk\nmatrix_write_to_binary_file(U, \"data/U.bin\");\nmatrix_write_to_binary_file(S, \"data/S.bin\");\nmatrix_write_to_binary_file(V, \"data/V.bin\");\n\n=======================\n\nNotice that for the multiprocessor OpenMP based code, one can control the number of \nthreads used via an environmental variable. For instance, in bash type:\nexport OMP_NUM_THREADS=6\nto use 6 threads. You should use as many threads as there are physical cores for \nbest results, but the optimal configuration differs for different systems.\n\nExample run with GPU code\n\nFirst, make the matrix using the provided script:\n$ matlab -nodesktop\n> make_matrix_binary2 \n> ls data/A_mat_6kx12k.bin\n$\n\nCheck to make sure nvidia libs are setup ok:\n$ nvidia-smi \n\nSwitch to correct directory\n$ cd nvidia_gpu_cula_code \n\nSource paths to cuda/cula\n$ source setup_paths.sh\n\nCompile\n$./compile.sh\n\nRun:\n$./driver_gpu_nvidia_cula\nInitializing CULA\nculaVersion is 18000\nloading matrix from ../data/A_mat_6kx12k.bin\ninitializing M of size 6000 by 12000\ndone..\nsizes of M are 6000 by 12000\ncalling random SVD version 3 with k = 1000\n.........\nelapsed time: about 13 seconds\nnormM = 180.600893 ; normU = 31.622777 ; normS = 176.342348 ; normV = 31.622777 ; normP = 176.342348\npercent_error between M and U S V^T = 21.587897\n$\n\nExample run with Matlab Mex Interface of GPU code (run C GPU code inside of Matlab)\n\n$ cd matlab_code/mex_code_nvidia_gpu_cula/\n$ source setup_vars.sh\n$ ./compile_mex.sh\n$ matlab -nodesktop\n>> A = randn(2000,5000);\n>> k = 1900;\n>> [U,S,V] = rsvd_cula_mex_interface1(A,k);\n>> norm(A - U*S*V')/norm(A)\n>> k = 2000;\n>> [U,S,V] = rsvd_cula_mex_interface2(A,500,4,2);\n>> norm(A - U*S*V')/norm(A)\n\n", 
  "read_at": 1462558281, 
  "description": "RSVDPACK: Implementations of fast algorithms for computing the low rank SVD,  interpolative and CUR decompositions of a matrix, using randomized sampling. Includes codes for single core (using GNU GSL), multi-core (using Intel MKL) and GPU (using NVIDIA CUDA/CULA) architectures. ", 
  "id": 24388584
}
{
  "read_at": 1462550440, 
  "README.mdpp": "PerfAndPubTools\n===============\n\n!TOC\n\n## What is PerfAndPubTools?\n\n_PerfAndPubTools_ consists of a set of [MATLAB]/[Octave] functions for analyzing\nsoftware performance benchmark results and producing associated publication\nquality materials.\n\n## Benchmark file format\n\nBy default, _PerfAndPubTools_ expects individual benchmarking results to be\navailable as files containing the default output of [GNU time] command, for\nexample:\n\n```\n512.66user 2.17system 8:01.34elapsed 106%CPU (0avgtext+0avgdata 1271884maxresident)k\n0inputs+2136outputs (0major+49345minor)pagefaults 0swaps\n```\n\nThis preset selection can be easily modified as described in the next sections.\n\n## Architecture and functions\n\n_PerfAndPubTools_ is implemented in a layered architecture using a procedural\nprogramming approach, as shown in the following figure:\n\n![arch](https://cloud.githubusercontent.com/assets/3018963/12206544/74c5ac38-b639-11e5-87c2-fc65e6bf8875.png)\n\nPerformance analysis in _PerfAndPubTools_ takes place at two levels:\n*implementation* and *setup*. The *implementation* level is meant to be\nassociated with specific software implementations for performing a given task,\nfor example a particular sorting algorithm or a simulation model realized in\na certain programming language. Within the context of each implementation, the\nsoftware can be executed under different *setups*. These can be different\ncomputational sizes (e.g. vector lengths in a sorting algorithm) or distinct\nexecution parameters (e.g. number of threads used).\n\n_PerfAndPubTools_ is bundled with the following functions, from lowest to\nhighest-level of functionality:\n\n* [get_gtime] - Given a file containing the default output of the [GNU time]\ncommand, this function extracts the user, system and elapsed times in seconds,\nas well as the percentage of CPU usage.\n\n* [gather_times] - Loads execution times from files in a given folder. This\nfunction uses [get_gtime] by default, but can be configured to use another\nfunction to load individual benchmark files with a different format.\n\n* [perfstats] - Determines mean times and respective standard deviations of a\ncomputational experiment using folders of files containing benchmarking results,\noptionally plotting a scalability graph if different setups correspond to\ndifferent computational work sizes.\n\n* [speedup] - Determines the average, maximum and minimum speedups against one\nor more reference *implementations* across a number of *setups*. Can optionally\ngenerate a bar plot displaying the various speedups.\n\n* [times_table] - Returns a matrix with useful contents for using in tables for\npublication, namely times (in seconds), absolute standard deviations (seconds),\nrelative standard deviations, speedups (vs the specified implementations).\n\n* [times_table_f] - Returns a table with performance analysis results formatted\nin plain text or in LaTeX (the latter requires the [siunitx], [multirow] and\n[booktabs] packages).\n\nAlthough the [perfstats] and [speedup] functions optionally create plots, these\nare mainly intended to provide visual feedback on the performance analysis being\nundertaken. Those needing more control over the final figures can customize the\ngenerated plots via the returned figure handles or create custom plots using the\ndata provided by [perfstats] and [speedup]. Either way, [MATLAB]/[Octave] plots\ncan be used directly in publications, or converted to LaTeX using the excellent\n[matlab2tikz] script, as will be shown in some of the examples.\n\n## Examples\n\nExamples are organized into two sections:\n\n1. [Performance analysis of sorting algorithms](#exsortalgs)\n2. [Performance analysis of a simulation model](#exsimmods)\n\nExamples in the first section demonstrate the complete process of benchmarking a\nnumber of sorting algorithms with the [GNU time] command and then analyzing\nresults with _PerfAndPubTools_. Since the [GNU time] command is not available on\nWindows, the data produced by the benchmarks is [included][sort_data] in the\npackage.\n\nExamples in the second section focus on showing how _PerfAndPubTools_ was used\nto analyze performance data of multiple implementations of a\n[simulation model][PPHPC], replicating results presented in a peer-reviewed\narticle [\\[1\\]](#ref1). The initial benchmarking steps are skipped in these\nexamples, but the produced data and the scripts used to generate it are also\nmade [available][pphpc_data].\n\n<a name=\"exsortalgs\"></a>\n\n### Performance analysis of sorting algorithms\n\nIn following examples, we use _PerfAndPubTools_ to analyze the performance of\nseveral sorting algorithms implemented in C. Perform the following steps before\nproceeding:\n\n1. Download and compile the [sorttest.c] program (instructions are available in\nthe linked page).\n2. Confirm that the [GNU time] program is installed (instructions also available\nin [sorttest.c]).\n3. In [MATLAB]/[Octave] create a `sortfolder` variable containing the full path\nof the [sorttest.c] program, for example `sortfolder = '/home/user/sort'`\n(Unix/Linux) or `sortfolder = 'C:\\Users\\UserName\\Documents\\sort'` (Windows).\n\n[GNU time] is usually invoked as `/usr/bin/time`, but this can vary for\ndifferent Linux distributions. On OSX it is invoked as `gtime`. The usual Linux\ninvocation is used for throughout the examples, replace it as appropriate.\n\nSince the [GNU time] program does not seem to be available for Windows, these\nexamples only run unmodified on Linux and OSX. On Windows, benchmark the\n[sorttest.c] program using an [alternative] approach and replace [get_gtime]\nwith a function which parses the produced output. Otherwise, skip the actual\nbenchmarking steps within the examples, and use the benchmarking data bundled\nwith _PerfAndPubTools_ in the [data][sort_data] folder.\n\n#### Extract performance data from a file\n\nFirst, check that the [sorttest.c] program is working by testing the [Quicksort]\nalgorithm with a vector of 1,000,000 random integers:\n\n```\n$ ./sorttest quick 1000000 2362 yes\nSorting Ok!\n```\n\nThe value `2362` is the seed for the random number generator, and the optional\n`yes` parameter asks the program to output a message confirming if the sorting\nwas successful.\n\nNow, create a benchmark file with [GNU time]:\n\n```\n$ /usr/bin/time ./sorttest quick 1000000 2362 2> out.txt \n```\n\nThe `2>` part redirects the output of [GNU time] to a file called `out.txt`.\nThis file can be parsed with the [get_gtime] function from [MATLAB] or [Octave]:\n\n```matlab\np = get_gtime('out.txt')\n```\n\nThe function returns a structure with several fields:\n\n```\np = \n\n       user: 0.2000\n        sys: 0\n    elapsed: 0.2000\n        cpu: 99\n```\n\n#### Extract execution times from files in a folder\n\nThe [gather_times] function extracts execution times from multiple files in a\nfolder. This is useful for analyzing average run times over a number of runs.\nFirst, we need to perform these runs. From a terminal, run the following\ncommand, which performs 10 runs of the [sorttest.c] program:\n\n```\n$ for RUN in {1..10}; do /usr/bin/time ./sorttest quick 1000000 $RUN 2> time_quick_1000000_$RUN.txt; done\n```\n\nNote that each run is performed with a different seed, so that different vectors\nare sorted by [Quicksort] each turn. In [MATLAB] or [Octave], use the\n[gather_times] function to extract execution times:\n\n```matlab\nexec_time = gather_times('Quicksort', sortfolder, 'time_quick_1000000_*.txt');\n```\n\nThe first parameter names the list of gathered times, and is used as metadata by\nother functions. The second parameter specifies the folder where the [GNU time]\noutput files are located. The vector of execution times is in the `elapsed`\nfield of the returned structure:\n\n```matlab\nexec_time.elapsed\n```\n\nThe [gather_times] function uses [get_gtime] internally by default. However, \nother functions can be specified in the first line of the [gather_times]\nfunction body, allowing _PerfAndPubTools_ to support benchmarking formats other\nthan the output of [GNU time]. Alternatives to [get_gtime] are only required to\nreturn a struct with the `elapsed` field, indicating the duration (in seconds)\nof a program execution.\n\n#### Average execution times and standard deviations\n\nIn its most basic usage, the [perfstats] function obtains performance\nstatistics. In this example, average execution times and standard deviations are\nobtained from the runs performed in the previous example:\n\n```matlab\nqs1M = struct('sname', 'Quicksort', 'folder', sortfolder, 'files', 'time_quick_1000000_*.txt');\n[avg_time, std_time] = perfstats(0, 'QuickSort', {qs1M})\n```\n\n```\navg_time =\n\n    0.1340\n\n\nstd_time =\n\n    0.0052\n```\n\nThe `qs1M` variable specifies a *setup*. A setup is defined by the following\nfields: a) `sname`, the name of the setup; b) `folder`, the folder where to load\nbenchmark files from; c) `files`, the specific files to load (using wildcards);\nand, d) `csize`, an optional computational size for plotting purposes. \n\n\n#### Compare multiple setups within the same implementation\n\nA more advanced use case for [perfstats] consists of comparing multiple setups\nassociated with different computational sizes within the same implementation\n(e.g., the same sorting algorithm). A set of multiple setups is designated as an\n*implementation spec*, the basic object type accepted by the [perfstats],\n[speedup] and [times_table] functions. An implementation spec defines one or\nmore *setups* for a single *implementation*.\n\nIn this example we analyze how the performance of the [Bubble sort] algorithm\nvaries for increasing vector sizes. First, perform a number of runs with\n[sorttest.c] using [Bubble sort] for vectors of size 10,000, 20,000 and 30,000:\n\n```\n$ for RUN in {1..10}; do for SIZE in 10000 20000 30000; do /usr/bin/time ./sorttest bubble $SIZE $RUN 2> time_bubble_${SIZE}_${RUN}.txt; done; done\n```\n\nSecond, obtain the average times for the several vector sizes using [perfstats]:\n\n```matlab\n% Specify the setups\nbs10k = struct('sname', 'bs10k', 'folder', sortfolder, 'files', 'time_bubble_10000_*.txt');\nbs20k = struct('sname', 'bs20k', 'folder', sortfolder, 'files', 'time_bubble_20000_*.txt');\nbs30k = struct('sname', 'bs30k', 'folder', sortfolder, 'files', 'time_bubble_30000_*.txt');\n\n% Specify the implementation spec\nbs =  {bs10k, bs20k, bs30k};\n\n% Determine average time for each setup\navg_time = perfstats(0, 'bubble', {bs10k, bs20k, bs30k})\n```\n\n```\navg_time =\n\n    0.3220    1.3370    3.1070\n```\n\n#### Same as previous, with a linear plot\n\nThe [perfstats] function can also generate scalability plots. For this purpose,\nthe computational size, `csize`, must be specified in each setup, and the first\nparameter should be a value between 1 (linear plot) and 4 (log-log plot), as\nshown in the following commands:\n\n```matlab\n% Specify the setups\nbs10k = struct('sname', 'bs10k', 'csize', 1e4, 'folder', sortfolder, 'files', 'time_bubble_10000_*.txt');\nbs20k = struct('sname', 'bs20k', 'csize', 2e4, 'folder', sortfolder, 'files', 'time_bubble_20000_*.txt');\nbs30k = struct('sname', 'bs30k', 'csize', 3e4, 'folder', sortfolder, 'files', 'time_bubble_30000_*.txt');\n\n% Specify the implementation spec\nbs =  {bs10k, bs20k, bs30k};\n\n% The first parameter defines the plot type: 1 is a linear plot\nperfstats(1, 'bubble', bs);\n```\n\n![ex4 1 5_1](https://cloud.githubusercontent.com/assets/3018963/14692286/0d3a86ae-074e-11e6-95c7-270c35ce04de.png)\n\nError bars, showing the standard deviation, can be activated by passing a\nnegative value as the first parameter:\n\n```matlab\n% The first parameter defines the plot type: -1 is a linear plot\n% with error bars showing the standard deviation\nperfstats(-1, 'bubble', bs);\n```\n\n![ex4 1 5_2](https://cloud.githubusercontent.com/assets/3018963/14692287/0d40bbbe-074e-11e6-8d2c-c7d245b7cbd1.png)\n\n#### Compare different implementations\n\nBesides comparing multiple setups within the same implementation, the\n[perfstats] function is also able to compare multiple setups from multiple\nimplementations. The requirement is that, from implementation to implementation,\nthe multiple setups are directly comparable, i.e., corresponding implementation\nspecs should have the same `sname` and `csize` parameters.\n\nFirst, perform a number of runs with [sorttest.c] using [Merge sort] and\n[Quicksort] for vectors of size 1e4, 1e5, 1e6 and 1e7:\n\n```\n$ for RUN in {1..10}; do for IMPL in merge quick; do for SIZE in 100000 1000000 10000000 100000000; do /usr/bin/time ./sorttest $IMPL $SIZE $RUN 2> time_${IMPL}_${SIZE}_${RUN}.txt; done; done; done\n```\n\nSecond, use [perfstats] to plot the respective scalability graph:\n\n```matlab\n% Specify Merge sort implementation specs\nms1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_merge_100000_*.txt');\nms1e6 = struct('sname', '1e6', 'csize', 1e6, 'folder', sortfolder, 'files', 'time_merge_1000000_*.txt');\nms1e7 = struct('sname', '1e7', 'csize', 1e7, 'folder', sortfolder, 'files', 'time_merge_10000000_*.txt');\nms1e8 = struct('sname', '1e8', 'csize', 1e8, 'folder', sortfolder, 'files', 'time_merge_100000000_*.txt');\nms = {ms1e5, ms1e6, ms1e7, ms1e8};\n\n% Specify Quicksort implementation specs\nqs1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_quick_100000_*.txt');\nqs1e6 = struct('sname', '1e6', 'csize', 1e6, 'folder', sortfolder, 'files', 'time_quick_1000000_*.txt');\nqs1e7 = struct('sname', '1e7', 'csize', 1e7, 'folder', sortfolder, 'files', 'time_quick_10000000_*.txt');\nqs1e8 = struct('sname', '1e8', 'csize', 1e8, 'folder', sortfolder, 'files', 'time_quick_100000000_*.txt');\nqs = {qs1e5, qs1e6, qs1e7, qs1e8};\n\n% Plot comparison with a log-log plot\nperfstats(4, 'Merge sort', ms, 'Quicksort', qs);\n```\n\n![ex4 1 6_1](https://cloud.githubusercontent.com/assets/3018963/14692288/0d42faaa-074e-11e6-8eea-94dde29d3e5d.png)\n\nLike in the previous example, error bars are displayed by passing a negative\nvalue as the first parameter to [perfstats]:\n\n```matlab\n% Plot comparison with a log-log plot with error bars\nperfstats(-4, 'Merge sort', ms, 'Quicksort', qs);\n```\n\n![ex4 1 6_2](https://cloud.githubusercontent.com/assets/3018963/14692289/0d47a0c8-074e-11e6-928e-6f5fd8ed6528.png)\n\n#### Speedup\n\nThe [speedup] function is used to obtain relative speedups between different\nimplementations. Using the variables defined in the previous example, the\nfollowing instruction obtains the average, maximum and minimum speedups of\n[Quicksort] versus [Merge sort] for different vector sizes:\n\n```matlab\n[s_avg, s_max, s_min] = speedup(0, 1, 'Merge sort', ms, 'Quicksort', qs);\n```\n\nSpeedups can be obtained by getting the first element of the returned cell, i.e.\nby invoking `s_avg{1}`:\n\n```\nans =\n\n    1.0000    1.0000    1.0000    1.0000\n    2.0000    1.7164    1.7520    1.6314\n```\n\nThe second parameter indicates the reference implementation from which to \ncalculate speedups. In this case, specifying 1 will return speedups against\nMerge sort. The first row of the previous matrix shows the speedup of\n[Merge sort] against itself, thus it is composed of ones. The second row shows\nthe speedup of [Quicksort] versus [Merge sort]. If the second parameter is a\nvector, speedups against more than one implementation are returned.\n\nSetting the first parameter to 1 will yield a bar plot displaying the average\nspeedups:\n\n```matlab\nspeedup(1, 1, 'Merge sort', ms, 'Quicksort', qs);\n```\n\n![ex4 1 7_1](https://cloud.githubusercontent.com/assets/3018963/14688435/6bf1c108-073a-11e6-8cc8-258ea48f04a5.png)\n\nSpeedup bar plots also support error bars, but in this case error bars show the\nmaximum and minimum speedups. Error bars are activated by passing a negative\nnumber as the first argument to [speedup]:\n\n```matlab\nspeedup(-1, 1, 'Merge sort', ms, 'Quicksort', qs);\n```\n\n![ex4 1 7_2](https://cloud.githubusercontent.com/assets/3018963/14715181/cfda758e-07df-11e6-8013-10364091773b.png)\n\n#### Speedup for multiple algorithms and vector sizes\n\nThe [speedup] function is also able to determine relative speedups between\ndifferent implementations for multiple computational sizes. In this example we\nplot the average speedup of several sorting algorithms against [Bubble sort] and\n[Selection sort] for vector sizes 1e5, 2e5, 3e5 and 4e5. \n\nFirst, perform a number of runs using the four sorting algorithms made available\nby [sorttest.c] for the specified vector sizes:\n\n```\n$ for RUN in {1..10}; do for IMPL in bubble selection merge quick; do for SIZE in 100000 200000 300000 400000; do /usr/bin/time ./sorttest $IMPL $SIZE $RUN 2> time_${IMPL}_${SIZE}_${RUN}.txt; done; done; done\n```\n\nThen, in [MATLAB] or [Octave], specify the implementation specs for each sorting\nalgorithm and setup combination, and use the [speedup] function to  plot the\nrespective speedup plot:\n\n```matlab\n% Specify Bubble sort implementation specs\nbs1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_bubble_100000_*.txt');\nbs2e5 = struct('sname', '2e5', 'csize', 2e5, 'folder', sortfolder, 'files', 'time_bubble_200000_*.txt');\nbs3e5 = struct('sname', '3e5', 'csize', 3e5, 'folder', sortfolder, 'files', 'time_bubble_300000_*.txt');\nbs4e5 = struct('sname', '4e5', 'csize', 4e5, 'folder', sortfolder, 'files', 'time_bubble_400000_*.txt');\nbs = {bs1e5, bs2e5, bs3e5, bs4e5};\n\n% Specify Selection sort implementation specs\nss1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_selection_100000_*.txt');\nss2e5 = struct('sname', '2e5', 'csize', 2e5, 'folder', sortfolder, 'files', 'time_selection_200000_*.txt');\nss3e5 = struct('sname', '3e5', 'csize', 3e5, 'folder', sortfolder, 'files', 'time_selection_300000_*.txt');\nss4e5 = struct('sname', '4e5', 'csize', 4e5, 'folder', sortfolder, 'files', 'time_selection_400000_*.txt');\nss = {ss1e5, ss2e5, ss3e5, ss4e5};\n\n% Specify Merge sort implementation specs\nms1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_merge_100000_*.txt');\nms2e5 = struct('sname', '2e5', 'csize', 2e5, 'folder', sortfolder, 'files', 'time_merge_200000_*.txt');\nms3e5 = struct('sname', '3e5', 'csize', 3e5, 'folder', sortfolder, 'files', 'time_merge_300000_*.txt');\nms4e5 = struct('sname', '4e5', 'csize', 4e5, 'folder', sortfolder, 'files', 'time_merge_400000_*.txt');\nms = {ms1e5, ms2e5, ms3e5, ms4e5};\n\n% Specify Quicksort implementation specs\nqs1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_quick_100000_*.txt');\nqs2e5 = struct('sname', '2e5', 'csize', 2e5, 'folder', sortfolder, 'files', 'time_quick_200000_*.txt');\nqs3e5 = struct('sname', '3e5', 'csize', 3e5, 'folder', sortfolder, 'files', 'time_quick_300000_*.txt');\nqs4e5 = struct('sname', '4e5', 'csize', 4e5, 'folder', sortfolder, 'files', 'time_quick_400000_*.txt');\nqs = {qs1e5, qs2e5, qs3e5, qs4e5};\n\n% Plot speedup of multiple sorting algorithms against Bubble sort\n% Setting the first parameter to 2 will yields a log-scale bar plot\nspeedup(2, 1, 'Bubble', bs, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthWest');\n```\n\n![ex4 1 8_1](https://cloud.githubusercontent.com/assets/3018963/14703285/15d2f75c-07a7-11e6-8f0f-bd5d83bb5774.png)\n\n```matlab\n% Plot speedup of multiple sorting algorithms against Selection sort\nspeedup(1, 1, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthWest');\n```\n\n![ex4 1 8_2](https://cloud.githubusercontent.com/assets/3018963/14703318/399654a4-07a7-11e6-8828-a84ce171ff5a.png)\n\n\nIf we require error bars, the first parameter should be a negative value:\n\n```matlab\n% Same plot with error bars\nspeedup(-1, 1, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Place legend in a better position\nl = legend(gca);\nset(l, 'Location', 'NorthWest');\n```\n\n![ex4 1 8_3](https://cloud.githubusercontent.com/assets/3018963/14715383/83ffe3e6-07e0-11e6-8bd0-33898a6c5159.png)\n\nGenerated plots can be customized using the [MATLAB] or [Octave] GUI, or\nprogrammatically. The following commands change some of the default properties\nof the previous plot:\n\n```matlab\n% Get the current axes children objects\nch = get(gca, 'Children');\n\n% Set the color of the '1e5' bars to white\nset(ch(8), 'FaceColor', 'w');\n\n% This is required in Octave for updating the legend\nlegend(gca);\n\n% Change the default labels\nylabel('Average speedup over Selection sort');\nxlabel('Algorithms');\n```\n\n![ex4 1 8_4](https://cloud.githubusercontent.com/assets/3018963/14715384/84054192-07e0-11e6-9da1-88bb990f4588.png)\n\n#### Custom speedup plots\n\nFor more control over the speedup plots, it may preferable to use the data\nprovided by [speedup] and build the plots from the beginning. Continuing from\nthe previous example, the following sequence of instructions generates a\ncustomized plot showing the speedup of the sorting algorithms against\n[Bubble sort]:\n\n```matlab\n% Obtain speedup of multiple sorting algorithms against Bubble sort, no plot\ns = speedup(0, 1, 'Bubble', bs, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Generate basic speedup bar plot (first element of s cell array and rows 2 to 4,\n% to avoid displaying the speedup of Bubble sort against itself)\nh = bar(s{1}(2:4, :), 'basevalue', 1);\n\n% Customize plot\nset(h(1), 'FaceColor', [0 0 0]);\nset(h(2), 'FaceColor', [0.33 0.33 0.33]);\nset(h(3), 'FaceColor', [0.66 0.66 0.66]);\nset(h(4), 'FaceColor', [1 1 1]);\nset(gca, 'YScale', 'log');\ngrid on;\ngrid minor;\nlegend({'1 \\times 10^5', '2 \\times 10^5', '3 \\times 10^5', '4 \\times 10^5'}, 'Location', 'NorthWest');\nset(gca, 'XTickLabel', {'Selection', 'Merge', 'Quick'});\nylabel('Speedup');\n```\n\n![ex4 1 9_1](https://cloud.githubusercontent.com/assets/3018963/14691633/367ade1e-074a-11e6-9935-40f5e9f49763.png)\n\nAlthough the figure seems appropriate for publication purposes, it can be\nconverted to native LaTeX via the [matlab2tikz] script:\n\n```matlab\ncleanfigure();\nmatlab2tikz('standalone', true, 'filename', 'image.tex');\n```\n\nCompiling the `image.tex` file with a LaTeX engine yields the following figure:\n\n![ex4 1 9_2](https://cloud.githubusercontent.com/assets/3018963/14691634/3681a91a-074a-11e6-818c-498c68d2f8f0.png)\n\n#### Scalability of the different sorting algorithms for increasing vector sizes\n\nContinuing from the previous example, we can use [perfstats] to determine and\nplot the scalability of the different sorting algorithms for increasing vector\nsizes:\n\n```matlab\np = perfstats(3, 'Bubble', bs, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n```\n\n![ex4 1 10](https://cloud.githubusercontent.com/assets/3018963/14692331/502d8646-074e-11e6-9cc9-fb7fe8fd9cb5.png)\n\nThe values plotted are returned in variable `p`:\n\n```\np =\n\n   36.0040  144.8210  325.1730  577.8600\n    9.5270   38.0500   88.5130  153.6560\n    0.0200    0.0410    0.0600    0.0850\n    0.0100    0.0200    0.0300    0.0510\n```\n\n#### Custom scalability plots\n\nIn a similar fashion to the speedup plots, finer control over the scalability\nplots is possible by directly using the data provided by [perfstats]. The\nfollowing sequence of instructions customizes the figure in the previous\nexample:\n\n```matlab\n% Plot data from perfstats in y-axis in log-scale\nh = semilogy(p', 'Color', 'k');\n\n% Set different markers for the various lines\nset(h(1), 'Marker', 'd', 'MarkerFaceColor', 'w');\nset(h(2), 'Marker', 'o', 'MarkerFaceColor', 'k');\nset(h(3), 'Marker', '*');\nset(h(4), 'Marker', 's', 'MarkerFaceColor', [0.8 0.8 0.8]);\n\n% Make space for legend and add legend\nylim([1e-2 3e3]);\nlegend({'Bubble', 'Selection', 'Merge', 'Quick'}, 'Location', 'NorthWest');\n\n% Set horizontal ticks\nset(gca, 'XTick', 1:4);\nset(gca, 'XTickLabel', {'1e5', '2e5', '3e5', '4e5'});\n\n% Add a grid\ngrid on;\n\n% Add x and y labels\nxlabel('Vector size');\nylabel('Time (s)');\n```\n\n![ex4 1 11_1](https://cloud.githubusercontent.com/assets/3018963/14691914/c9e8deca-074b-11e6-8386-d15ca2f5f773.png)\n\nWe can further improve the figure, and convert it to LaTeX with [matlab2tikz]:\n\n```matlab\n% Minor grids in LaTeX image are not great, so remove them\ngrid minor;\n\n% Set horizontal ticks, LaTeX-style\nset(gca, 'XTickLabel', {'$1 \\times 10^5$', '$2 \\times 10^5$', '$3 \\times 10^5$', '$4 \\times 10^5$'});\n\n% Export figure to LaTeX\ncleanfigure();\nmatlab2tikz('standalone', true, 'filename', 'image.tex');\n```\n\nCompiling the `image.tex` file with a LaTeX engine yields the following figure:\n\n![ex4 1 11_2](https://cloud.githubusercontent.com/assets/3018963/14691915/ca03003e-074b-11e6-85fd-155e7cf2314a.png)\n\n#### Produce a table instead of a plot\n\nThe [times_table] and [times_table_f] functions can be used to create\nperformance tables formatted in plain text or LaTeX. Using the data defined in\nthe previous examples, the following commands produce a plain text table\ncomparing the performance of the different sorting algorithms:\n\n```matlab\n% Put data in table format\ntdata = times_table(1, 'Bubble', bs, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Print a plain text table\ntimes_table_f(0, 'vs Bubble', tdata)\n```\n\n```\n                  -----------------------------------------------\n                  |                       vs Bubble             |\n-----------------------------------------------------------------\n| Imp.   | Set.   |   t(s)     |   std     |  std%  | x Bubble  |\n-----------------------------------------------------------------\n| Bubble |    1e5 |         36 |     0.887 |   2.46 |         1 |\n|        |    2e5 |        145 |      2.92 |   2.02 |         1 |\n|        |    3e5 |        325 |      6.19 |   1.90 |         1 |\n|        |    4e5 |        578 |      6.38 |   1.10 |         1 |\n-----------------------------------------------------------------\n| Select |    1e5 |       9.53 |     0.069 |   0.72 |      3.78 |\n|        |    2e5 |         38 |     0.283 |   0.74 |      3.81 |\n|        |    3e5 |       88.5 |       3.7 |   4.18 |      3.67 |\n|        |    4e5 |        154 |      3.06 |   1.99 |      3.76 |\n-----------------------------------------------------------------\n|  Merge |    1e5 |       0.02 |  3.66e-18 |   0.00 |   1.8e+03 |\n|        |    2e5 |      0.041 |   0.00316 |   7.71 |  3.53e+03 |\n|        |    3e5 |       0.06 |  1.46e-17 |   0.00 |  5.42e+03 |\n|        |    4e5 |      0.085 |    0.0127 |  14.93 |   6.8e+03 |\n-----------------------------------------------------------------\n|  Quick |    1e5 |       0.01 |  1.83e-18 |   0.00 |   3.6e+03 |\n|        |    2e5 |       0.02 |  3.66e-18 |   0.00 |  7.24e+03 |\n|        |    3e5 |       0.03 |  7.31e-18 |   0.00 |  1.08e+04 |\n|        |    4e5 |      0.051 |   0.00316 |   6.20 |  1.13e+04 |\n-----------------------------------------------------------------\n```\n\nIn order to obtain the equivalent LaTeX table, we set the first parameter to 1\ninstead of 0:\n\n```matlab\n% Print a Latex table\ntimes_table_f(1, 'vs Bubble', tdata)\n```\n\n![ex4 1 12](https://cloud.githubusercontent.com/assets/3018963/14691916/ca160698-074b-11e6-9598-9bd2ce6f6a7e.png)\n\n<a name=\"exsimmods\"></a>\n\n### Performance analysis of a simulation model\n\nThe examples in this section use the following [dataset][pphpc_data]:\n\n* [![DOI](https://zenodo.org/badge/doi/10.5281/zenodo.34049.svg)](http://dx.doi.org/10.5281/zenodo.34049)\n\nUnpack the [dataset][pphpc_data] to any folder and specify the complete path to\nthis folder in variable `datafolder`, e.g.:\n\n```matlab\ndatafolder = 'path/to/dataset';\n```\n\nThis [dataset][pphpc_data] corresponds to the results presented in reference\n[\\[1\\]](#ref1), which compares the performance of several implementations of the\n[PPHPC] agent-based model. Among several aspects of _PerfAndPubTools_, the\nfollowing examples show how to replicate these results.\n\n#### Implementations and setups of the PPHPC agent-based model\n\nWhile most details about [PPHPC] and its various implementations are not\nimportant for this discussion, is convenient to know which implementations and\nsetups were experimented with in reference [\\[1\\]](#ref1). A total of six\nimplementations of the [PPHPC] model were compared:\n\nImplementation | Description\n---------------|------------\nNL             | [NetLogo] implementation (no parallelization).\nST             | Java single-thread implementation (no parallelization).\nEQ             | Java parallel implementation (equal work).\nEX             | Java parallel implementation (equal work, reproducible).\nER             | Java parallel implementation (row-wise synchronization).\nOD             | Java parallel implementation (on-demand work).\n\nA number of setups are directly related with the model itself, namely **model\nsize** and **parameter set**. Concerning model size, [PPHPC] was benchmarked\nwith sizes 100, 200, 400, 800 and 1600. Each size corresponds to the size of the\n*environment* in which the agents act, e.g. size 200 corresponds to a 200 x 200\nenvironment. Besides model size, [PPHPC] was also benchmarked with two parameter\nsets, simply designated as *parameter set 1* and *parameter set 2*. The latter\ntypically yields simulations with more agents.\n\nOther setups are associated with computational aspects of model execution, more\nspecifically **number of threads** (for parallel implementations) and \n**value of the _b_ parameter** (for OD implementation only).\n\nThe [dataset][pphpc_data] contains performance data (in the form of [GNU time]\ndefault output) for 10 runs of all setup combinations (i.e. model size,\nparameter set, number of threads and value of the _b_ parameter, where\napplicable).\n\n#### Extract performance data from a file\n\nThe [get_gtime] function extracts performance data from one file containing the\ndefault output of [GNU time] command. For example:\n\n```matlab\np = get_gtime([datafolder '/times/NL/time100v1r1.txt'])\n```\n\nThe function returns a structure with several fields:\n\n```\np = \n\n       user: 17.6800\n        sys: 0.3200\n    elapsed: 16.5900\n        cpu: 108\n```\n\n#### Extract execution times from files in a folder\n\nThe [gather_times] function extracts execution times from multiple files in a\nfolder, as shown in the following command:\n\n```matlab\nexec_time = gather_times('NetLogo', [datafolder '/times/NL'], 'time100v1*.txt');\n```\n\nThe vector of execution times is in the `elapsed` field of the returned\nstructure:\n\n```matlab\nexec_time.elapsed\n```\n\nThe [gather_times] function uses [get_gtime] internally by default. However, \nother functions can be specified in the first line of the [gather_times]\nfunction body, allowing _PerfAndPubTools_ to support benchmarking formats other\nthan the output of [GNU time]. Alternatives to [get_gtime] are only required to\nreturn a struct with the `elapsed` field, indicating the duration (in seconds)\nof a program execution.\n\n#### Average execution times and standard deviations\n\nIn its most basic usage, the [perfstats] function obtains performance\nstatistics. In this example, average execution times and standard deviations are\nobtained from 10 replications of the Java single-threaded (ST) implementation of\n[PPHPC] for size 800, parameter set 2:\n\n```matlab\nst800v2 = struct('sname', '800v1', 'folder', [datafolder '/times/ST'], 'files', 't*800v2*.txt');\n[avg_time, std_time] = perfstats(0, 'ST', {st800v2})\n```\n\n```\navg_time =\n\n  699.5920\n\n\nstd_time =\n\n    3.6676\n```\n\nThe [perfstats] function uses [gather_times] internally.\n\n#### Compare multiple setups within the same implementation\n\nA more advanced use case for [perfstats] consists of comparing multiple setups,\nassociated with different computational sizes, within the same implementation.\nFor example, considering the Java ST implementation of the [PPHPC] model, the\nfollowing instructions analyze how its performance varies for increasing model\nsizes:\n\n```matlab\n% Specify implementations specs for each model size\nst100v2 = struct('sname', '100v2', 'folder', [datafolder '/times/ST'], 'files', 't*100v2*.txt');\nst200v2 = struct('sname', '200v2', 'folder', [datafolder '/times/ST'], 'files', 't*200v2*.txt');\nst400v2 = struct('sname', '400v2', 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst800v2 = struct('sname', '800v2', 'folder', [datafolder '/times/ST'], 'files', 't*800v2*.txt');\nst1600v2 = struct('sname', '1600v2', 'folder', [datafolder '/times/ST'], 'files', 't*1600v2*.txt');\n\n% Obtain the average time for increasing model sizes\navg_time = perfstats(0, 'ST', {st100v2, st200v2, st400v2, st800v2, st1600v2})\n```\n\n```\navg_time =\n\n   1.0e+03 *\n\n    0.0053    0.0361    0.1589    0.6996    2.9572\n```\n\n#### Same as previous, with a log-log plot\n\nThe [perfstats] function can also be used to generate scalability plots. For\nthis purpose, the computational size, `csize`, must be specified in each\nsetup, and the first parameter of [perfstats] should be a value between 1\n(linear plot) and 4 (log-log plot), as shown in the following code snippet:\n\n```matlab\n% Specify implementations specs for each model size, indicating the csize key\nst100v2 = struct('sname', '100v2', 'csize', 100, 'folder', [datafolder '/times/ST'], 'files', 't*100v2*.txt');\nst200v2 = struct('sname', '200v2', 'csize', 200, 'folder', [datafolder '/times/ST'], 'files', 't*200v2*.txt');\nst400v2 = struct('sname', '400v2', 'csize', 400, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst800v2 = struct('sname', '800v2', 'csize', 800, 'folder', [datafolder '/times/ST'], 'files', 't*800v2*.txt');\nst1600v2 = struct('sname', '1600v2', 'csize', 1600, 'folder', [datafolder '/times/ST'], 'files', 't*1600v2*.txt');\n\n% The first parameter defines the plot type: 4 is a log-log plot\nperfstats(4, 'ST', {st100v2, st200v2, st400v2, st800v2, st1600v2});\n```\n\n![ex4 2 6_1](https://cloud.githubusercontent.com/assets/3018963/14692567/fc5a2004-074f-11e6-91d1-e82b5260f74c.png)\n\nError bars showing the standard deviation can be requested by passing a negative\nvalue as the first parameter to [perfstats]:\n\n```matlab\n% The value -4 indicates a log-log plot with error bars\nperfstats(-4, 'ST', {st100v2, st200v2, st400v2, st800v2, st1600v2});\n```\n\n![ex4 2 6_2](https://cloud.githubusercontent.com/assets/3018963/14692568/fc5e537c-074f-11e6-81df-aecfda2c2618.png)\n\nDue to the run time variability being very low, the error bars are not very\nuseful in this case.\n\n<a name=\"pphpccompdiffimpl\"></a>\n\n#### Compare different implementations\n\nBesides comparing multiple setups within the same implementation, the\n[perfstats] function is also able to compare multiple setups from a number\nimplementations. The requirement is that, from implementation to implementation,\nthe multiple setups are directly comparable, i.e., corresponding implementation\nspecs should have the same `sname` and `csize` parameters, as shown in the\nfollowing commands, where the [NetLogo] \\(NL\\) and Java single-thread (ST)\n[PPHPC] implementations are compared for sizes 100 to 1600, parameter set 1:\n\n```matlab\n% Specify NetLogo implementation specs\nnl100v1 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/NL'], 'files', 't*100v1*.txt');\nnl200v1 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/NL'], 'files', 't*200v1*.txt');\nnl400v1 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/NL'], 'files', 't*400v1*.txt');\nnl800v1 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/NL'], 'files', 't*800v1*.txt');\nnl1600v1 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/NL'], 'files', 't*1600v1*.txt');\nnlv1 = {nl100v1, nl200v1, nl400v1, nl800v1, nl1600v1};\n\n% Specify Java ST implementation specs\nst100v1 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/ST'], 'files', 't*100v1*.txt');\nst200v1 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/ST'], 'files', 't*200v1*.txt');\nst400v1 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/ST'], 'files', 't*400v1*.txt');\nst800v1 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/ST'], 'files', 't*800v1*.txt');\nst1600v1 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/ST'], 'files', 't*1600v1*.txt');\nstv1 = {st100v1, st200v1, st400v1, st800v1, st1600v1};\n\n% Plot comparison\nperfstats(4, 'NL', nlv1, 'ST', stv1);\n```\n\n![ex4 2 7](https://cloud.githubusercontent.com/assets/3018963/14692605/3660f0a2-0750-11e6-9d5d-375a1b5777fe.png)\n\n#### Speedup\n\nThe [speedup] function is used to obtain relative speedups between different\nimplementations. Using the variables defined in the previous example, the\naverage, maximum and minimum speedups of the Java ST version over the [NetLogo]\nimplementation for different model sizes can be obtained with the following\ninstruction:\n\n```matlab\n[s_avg, s_max, s_min] = speedup(0, 1, 'NL', nlv1, 'ST', stv1);\n```\n\nThe first element of the returned cell, i.e. `s_avg{1}`, contains the speedups:\n\n```\nans =\n\n    1.0000    1.0000    1.0000    1.0000    1.0000\n    5.8513    8.2370    5.7070    5.4285    5.4331\n```\n\nThe second parameter of the [speedup] function indicates the reference\nimplementation from which to calculate speedups. In this case, specifying 1 will\nreturn speedups against the [NetLogo] implementation. The first row of the\nmatrix in `s_avg{1}` shows the speedup of the [NetLogo] implementation against\nitself, thus it is composed of ones. The second row shows the speedup of the\nJava ST implementation versus the [NetLogo] implementation. If the second\nparameter of the [speedup] function is a vector, speedups against more than one\nimplementation are returned in `s_avg`, `s_max` and `s_min`.\n\nSetting the first parameter of [speedup] to 1 will yield a bar plot displaying the\nrelative speedups:\n\n```matlab\nspeedup(1, 1, 'NL', nlv1, 'ST', stv1);\n```\n\n![ex4 2 8_1](https://cloud.githubusercontent.com/assets/3018963/14692693/e6b122ce-0750-11e6-973d-1742d81974ed.png)\n\nError bars representing the maximum and minimum speedups can be requested by\npassing a negative value as the first parameter:\n\n```matlab\nspeedup(-1, 1, 'NL', nlv1, 'ST', stv1);\n```\n\n![ex4 2 8_2](https://cloud.githubusercontent.com/assets/3018963/14715792/2214f98a-07e2-11e6-807f-cd37b88533d8.png)\n\n#### Speedup for multiple parallel implementations and sizes\n\nThe [speedup] function is also able to determine speedups between different\nimplementations for multiple computational sizes. In this example we plot the\nspeedup of several [PPHPC] parallel Java implementations against the [NetLogo]\nand Java single-thread implementations for multiple sizes. This example uses the\n`nlv1` and `stv1` variables defined in a [previous example](#pphpccompdiffimpl),\nand the plotted results are equivalent to figures 4a and 4b of reference\n[\\[1\\]](#ref1):\n\n```matlab\n% Specify Java EQ implementation specs (runs with 12 threads)\neq100v1t12 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/EQ'], 'files', 't*100v1*t12r*.txt');\neq200v1t12 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/EQ'], 'files', 't*200v1*t12r*.txt');\neq400v1t12 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/EQ'], 'files', 't*400v1*t12r*.txt');\neq800v1t12 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/EQ'], 'files', 't*800v1*t12r*.txt');\neq1600v1t12 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/EQ'], 'files', 't*1600v1*t12r*.txt');\neqv1t12 = {eq100v1t12, eq200v1t12, eq400v1t12, eq800v1t12, eq1600v1t12};\n\n% Specify Java EX implementation specs (runs with 12 threads)\nex100v1t12 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/EX'], 'files', 't*100v1*t12r*.txt');\nex200v1t12 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/EX'], 'files', 't*200v1*t12r*.txt');\nex400v1t12 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/EX'], 'files', 't*400v1*t12r*.txt');\nex800v1t12 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/EX'], 'files', 't*800v1*t12r*.txt');\nex1600v1t12 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/EX'], 'files', 't*1600v1*t12r*.txt');\nexv1t12 = {ex100v1t12, ex200v1t12, ex400v1t12, ex800v1t12, ex1600v1t12};\n\n% Specify Java ER implementation specs (runs with 12 threads)\ner100v1t12 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/ER'], 'files', 't*100v1*t12r*.txt');\ner200v1t12 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/ER'], 'files', 't*200v1*t12r*.txt');\ner400v1t12 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/ER'], 'files', 't*400v1*t12r*.txt');\ner800v1t12 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/ER'], 'files', 't*800v1*t12r*.txt');\ner1600v1t12 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/ER'], 'files', 't*1600v1*t12r*.txt');\nerv1t12 = {er100v1t12, er200v1t12, er400v1t12, er800v1t12, er1600v1t12};\n\n% Specify Java OD implementation specs (runs with 12 threads, b = 500)\nod100v1t12 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*100v1*b500t12r*.txt');\nod200v1t12 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*200v1*b500t12r*.txt');\nod400v1t12 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/OD'], 'files', 't*400v1*b500t12r*.txt');\nod800v1t12 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/OD'], 'files', 't*800v1*b500t12r*.txt');\nod1600v1t12 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/OD'], 'files', 't*1600v1*b500t12r*.txt');\nodv1t12 = {od100v1t12, od200v1t12, od400v1t12, od800v1t12, od1600v1t12};\n\n% Plot speedup of multiple parallel implementations against NetLogo implementation\n% This plot is figure 4a of reference [1]\nspeedup(1, 1, 'NL', nlv1, 'ST', stv1, 'EQ', eqv1t12, 'EX', exv1t12, 'ER', erv1t12, 'OD', odv1t12);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthWest');\n```\n\n![ex4 2 9_1](https://cloud.githubusercontent.com/assets/3018963/14706004/308d5576-07b4-11e6-8509-506cb4af5733.png)\n\n```matlab\n% Plot speedup of multiple parallel implementations against Java ST implementation\n% This plot is figure 4b of reference [1]\nspeedup(1, 1, 'ST', stv1, 'EQ', eqv1t12, 'EX', exv1t12, 'ER', erv1t12, 'OD', odv1t12);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthOutside', 'Orientation', 'horizontal');\n```\n\n![ex4 2 9_2](https://cloud.githubusercontent.com/assets/3018963/14706005/30a50b30-07b4-11e6-963c-1b20102b1cbb.png)\n\n#### Scalability of the different implementations for increasing model sizes\n\nIn a slightly more complex scenario than the one described in a\n[previous example](#pphpccompdiffimpl), here we use the [perfstats] function to\nplot the scalability of the different [PPHPC] implementations for increasing\nmodel sizes. Using the variables defined in the previous examples, the following\ncommand generates the equivalent to figure 5a of reference [\\[1\\]](#ref1):\n\n```matlab\nperfstats(4, 'NL', nlv1, 'ST', stv1, 'EQ', eqv1t12, 'EX', exv1t12, 'ER', erv1t12, 'OD', odv1t12);\n```\n\n![ex4 2 10](https://cloud.githubusercontent.com/assets/3018963/14692845/fdb21130-0751-11e6-9e75-428f92e3b59b.png)\n\n#### Scalability of parallel implementations for increasing number of threads\n\nThe 'computational size', i.e. the `csize` field, defined in the implementation\nspecs passed to the [perfstats] function can be used in alternative contexts. In\nthis example, we use the `csize` field to specify the number of threads used to\nperform a set of simulation runs or replications. The following commands\nwill plot the scalability of the several [PPHPC] parallel implementations for an\nincreasing number of threads. The plotted results are equivalent to figure 6d of\nreference [\\[1\\]](#ref1):\n\n```matlab\n% Specify ST implementation specs, note that the data is always the same\n% so in practice the scalability will be constant for ST. However, this is a\n% nice trick to have a comparison standard in the plot.\nst400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nstv2 = {st400v2t1, st400v2t2, st400v2t4, st400v2t6, st400v2t8, st400v2t12, st400v2t16, st400v2t24};\n\n% Specify the EQ implementation specs for increasing number of threads\neq400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t1r*.txt');\neq400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t2r*.txt');\neq400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t4r*.txt');\neq400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t6r*.txt');\neq400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t8r*.txt');\neq400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t12r*.txt');\neq400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t16r*.txt');\neq400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t24r*.txt');\neqv2 = {eq400v2t1, eq400v2t2, eq400v2t4, eq400v2t6, eq400v2t8, eq400v2t12, eq400v2t16, eq400v2t24};\n\n% Specify the EX implementation specs for increasing number of threads\nex400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t1r*.txt');\nex400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t2r*.txt');\nex400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t4r*.txt');\nex400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t6r*.txt');\nex400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t8r*.txt');\nex400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t12r*.txt');\nex400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t16r*.txt');\nex400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t24r*.txt');\nexv2 = {ex400v2t1, ex400v2t2, ex400v2t4, ex400v2t6, ex400v2t8, ex400v2t12, ex400v2t16, ex400v2t24};\n\n% Specify the ER implementation specs for increasing number of threads\ner400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t1r*.txt');\ner400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t2r*.txt');\ner400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t4r*.txt');\ner400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t6r*.txt');\ner400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t8r*.txt');\ner400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t12r*.txt');\ner400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t16r*.txt');\ner400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t24r*.txt');\nerv2 = {er400v2t1, er400v2t2, er400v2t4, er400v2t6, er400v2t8, er400v2t12, er400v2t16, er400v2t24};\n\n% Specify the OD implementation specs for increasing number of threads (b = 500)\nod400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t1r*.txt');\nod400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t2r*.txt');\nod400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t4r*.txt');\nod400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t6r*.txt');\nod400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t8r*.txt');\nod400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t12r*.txt');\nod400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t16r*.txt');\nod400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t24r*.txt');\nodv2 = {od400v2t1, od400v2t2, od400v2t4, od400v2t6, od400v2t8, od400v2t12, od400v2t16, od400v2t24};\n\n% Use a linear plot (first parameter = 1)\nperfstats(1, 'ST', stv2, 'EQ', eqv2, 'EX', exv2, 'ER', erv2, 'OD', odv2);\n\n% Move legend to a better position\nlegend(gca, 'Location', 'northeast');\n```\n\n![ex4 2 11](https://cloud.githubusercontent.com/assets/3018963/14692932/aba1f486-0752-11e6-8dd9-b5d673dc50ce.png)\n\n#### Performance of OD strategy for different values of _b_\n\nFor this example, in yet another possible use of the [perfstats] function,  we\nuse the `csize` field to specify the value of the _b_ parameter of the [PPHPC]\nmodel Java OD variant. This allows us to analyze the performance of the OD\nparallelization strategy for different values of _b_. The plot created by the\nfollowing commands is equivalent to figure 7b of reference [\\[1\\]](#ref1):\n\n```matlab\n% Specify the OD implementation specs for size 100 and increasing values of b\nod100v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b20t12r*.txt');\nod100v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b50t12r*.txt');\nod100v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b100t12r*.txt');\nod100v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b200t12r*.txt');\nod100v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b500t12r*.txt');\nod100v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b1000t12r*.txt');\nod100v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b2000t12r*.txt');\nod100v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b5000t12r*.txt');\nod100v2 = {od100v2b20, od100v2b50, od100v2b100, od100v2b200, od100v2b500, od100v2b1000, od100v2b2000, od100v2b5000};\n\n% Specify the OD implementation specs for size 200 and increasing values of b\nod200v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b20t12r*.txt');\nod200v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b50t12r*.txt');\nod200v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b100t12r*.txt');\nod200v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b200t12r*.txt');\nod200v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b500t12r*.txt');\nod200v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b1000t12r*.txt');\nod200v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b2000t12r*.txt');\nod200v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b5000t12r*.txt');\nod200v2 = {od200v2b20, od200v2b50, od200v2b100, od200v2b200, od200v2b500, od200v2b1000, od200v2b2000, od200v2b5000};\n\n% Specify the OD implementation specs for size 400 and increasing values of b\nod400v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b20t12r*.txt');\nod400v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b50t12r*.txt');\nod400v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b100t12r*.txt');\nod400v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b200t12r*.txt');\nod400v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t12r*.txt');\nod400v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b1000t12r*.txt');\nod400v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b2000t12r*.txt');\nod400v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b5000t12r*.txt');\nod400v2 = {od400v2b20, od400v2b50, od400v2b100, od400v2b200, od400v2b500, od400v2b1000, od400v2b2000, od400v2b5000};\n\n% Specify the OD implementation specs for size 800 and increasing values of b\nod800v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b20t12r*.txt');\nod800v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b50t12r*.txt');\nod800v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b100t12r*.txt');\nod800v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b200t12r*.txt');\nod800v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b500t12r*.txt');\nod800v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b1000t12r*.txt');\nod800v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b2000t12r*.txt');\nod800v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b5000t12r*.txt');\nod800v2 = {od800v2b20, od800v2b50, od800v2b100, od800v2b200, od800v2b500, od800v2b1000, od800v2b2000, od800v2b5000};\n\n% Specify the OD implementation specs for size 1600 and increasing values of b\nod1600v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b20t12r*.txt');\nod1600v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b50t12r*.txt');\nod1600v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b100t12r*.txt');\nod1600v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b200t12r*.txt');\nod1600v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b500t12r*.txt');\nod1600v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b1000t12r*.txt');\nod1600v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b2000t12r*.txt');\nod1600v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b5000t12r*.txt');\nod1600v2 = {od1600v2b20, od1600v2b50, od1600v2b100, od1600v2b200, od1600v2b500, od1600v2b1000, od1600v2b2000, od1600v2b5000};\n\n% Show plot\nperfstats(4, '100', od100v2, '200', od200v2, '400', od400v2, '800', od800v2, '1600', od1600v2);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthOutside', 'Orientation', 'horizontal')\n```\n\n![ex4 2 12](https://cloud.githubusercontent.com/assets/3018963/14693011/49f6088e-0753-11e6-974b-f920b8bb4167.png)\n\n#### Custom performance plot\n\nAs previously discussed, it is possible to generate custom plots using the data\nreturned by [perfstats] and [speedup]. The following code snippet produces a\ncustomized version of the plot generated in the previous example. The resulting\nimage is a publication quality equivalent of figure 7b in reference\n[\\[1\\]](#ref1):\n\n```matlab\n% Get data from perfstats function\np = perfstats(0, '100', od100v2, '200', od200v2, '400', od400v2, '800', od800v2, '1600', od1600v2);\n\n% Values of the b parameter\nbvals = [20 50 100 200 500 1000 2000 5000];\n\n% Generate basic plot with black lines\nh = loglog(bvals, p', 'k');\nset(gca, 'XTick', bvals);\n\n% Set marker styles\nset(h(1), 'Marker', 'o', 'MarkerFaceColor', [0.7 0.7 0.7]);\nset(h(2), 'Marker', 's', 'MarkerFaceColor', [0.7 0.7 0.7]);\nset(h(3), 'Marker', 'o', 'MarkerFaceColor', 'w');\nset(h(4), 'Marker', '^', 'MarkerFaceColor', 'k');\nset(h(5), 'Marker', 'd', 'MarkerFaceColor', [0.7 0.7 0.7]);\n\n% Draw bold circles indicating best times for each size/b combination\ngrid on;\nhold on;\n[my, mi] = min(p, [], 2);\nplot(bvals(mi), my, 'ok', 'MarkerSize', 10, 'LineWidth', 2);\n\n% Set limits and add labels\nxlim([min(bvals) max(bvals)]);\nxlabel('Block size, {\\itb}');\nylabel('Time ({\\its})');\n\n% Set legend\nlegend({'100', '200', '400', '800', '1600'}, 'Location', 'NorthOutside', 'Orientation', 'horizontal');\n```\n\n![ex4 2 13_1](https://cloud.githubusercontent.com/assets/3018963/14706270/8e7c0e9c-07b5-11e6-8fe8-cbd24c184cec.png)\n\nAlthough the figure looks appropriate for publication purposes, it can still be\nimproved by converting it to native LaTeX via the [matlab2tikz] script:\n\n```matlab\n% Small adjustments so that figure looks better when converted\ngrid minor;\nset(gca, 'XTickLabel', bvals);\n\n% Convert figure to LaTeX\ncleanfigure();\nmatlab2tikz('standalone', true, 'filename', 'image.tex');\n```\n\nCompiling the `image.tex` file with a LaTeX engine yields the following figure:\n\n![ex4 2 13_2](https://cloud.githubusercontent.com/assets/3018963/14706271/8e7c4fce-07b5-11e6-8ed5-09853541b4a4.png)\n\n#### Show a table instead of a plot\n\nThe [times_table] and [times_table_f] functions can be used to create\nperformance tables formatted in plain text or LaTeX. Using the data defined in a\n[previous example](#pphpccompdiffimpl), the following commands produce a plain\ntext table comparing the [NetLogo] \\(NL\\) and Java single-thread (ST) [PPHPC]\nimplementations for sizes 100 to 1600, parameter set 1:\n\n```matlab\n% Put data in table format\ntdata = times_table(1, 'NL', nlv1, 'ST', stv1);\n\n% Print a plain text table\ntimes_table_f(0, 'NL vs ST', tdata)\n```\n\n```\n                  -----------------------------------------------\n                  |                        NL vs ST             |\n-----------------------------------------------------------------\n| Imp.   | Set.   |   t(s)     |   std     |  std%  | x     NL  |\n-----------------------------------------------------------------\n|     NL |  100v1 |       15.9 |     0.359 |   2.26 |         1 |\n|        |  200v1 |        100 |      1.25 |   1.25 |         1 |\n|        |  400v1 |        481 |      6.02 |   1.25 |         1 |\n|        |  800v1 |   2.08e+03 |      9.75 |   0.47 |         1 |\n|        | 1600v1 |   9.12e+03 |      94.1 |   1.03 |         1 |\n-----------------------------------------------------------------\n|     ST |  100v1 |       2.71 |    0.0223 |   0.82 |      5.85 |\n|        |  200v1 |       12.2 |     0.219 |   1.80 |      8.24 |\n|        |  400v1 |       84.4 |      2.83 |   3.35 |      5.71 |\n|        |  800v1 |        383 |      5.04 |   1.32 |      5.43 |\n|        | 1600v1 |   1.68e+03 |      78.4 |   4.67 |      5.43 |\n-----------------------------------------------------------------\n```\n\nIn order to produce the equivalent LaTeX table, we set the first parameter to 1\ninstead of 0:\n\n```matlab\n% Print a Latex table\ntimes_table_f(1, 'NL vs ST', tdata)\n```\n\n![ex4 2 14](https://cloud.githubusercontent.com/assets/3018963/14706361/f6f1c8cc-07b5-11e6-9c7d-87af968ac115.png)\n\n#### Complex tables\n\nThe [times_table] and [times_table_f] functions are capable of producing more\ncomplex tables. In this example, we show how to reproduce table 7 of reference\n[\\[1\\]](#ref1), containing times and speedups for multiple model\nimplementations, different sizes and both parameter sets, showing speedups of\nall implementations versus the [NetLogo] and Java ST versions.\n\nThe first step consists of defining the implementation specs:\n\n```matlab\n% %%%%%%%%%%%%%%%%%%%%%%%%% %\n% Specs for parameter set 1 %\n% %%%%%%%%%%%%%%%%%%%%%%%%% %\n\n% Define NetLogo implementation specs, parameter set 1\nnl100v1 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/NL'], 'files', 't*100v1*.txt');\nnl200v1 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/NL'], 'files', 't*200v1*.txt');\nnl400v1 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/NL'], 'files', 't*400v1*.txt');\nnl800v1 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/NL'], 'files', 't*800v1*.txt');\nnl1600v1 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/NL'], 'files', 't*1600v1*.txt');\nnlv1 = {nl100v1, nl200v1, nl400v1, nl800v1, nl1600v1};\n\n% Define Java ST implementation specs, parameter set 1\nst100v1 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/ST'], 'files', 't*100v1*.txt');\nst200v1 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/ST'], 'files', 't*200v1*.txt');\nst400v1 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/ST'], 'files', 't*400v1*.txt');\nst800v1 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/ST'], 'files', 't*800v1*.txt');\nst1600v1 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/ST'], 'files', 't*1600v1*.txt');\nstv1 = {st100v1, st200v1, st400v1, st800v1, st1600v1};\n\n% Define Java EQ implementation specs (runs with 12 threads), parameter set 1\neq100v1t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/EQ'], 'files', 't*100v1*t12r*.txt');\neq200v1t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/EQ'], 'files', 't*200v1*t12r*.txt');\neq400v1t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/EQ'], 'files', 't*400v1*t12r*.txt');\neq800v1t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/EQ'], 'files', 't*800v1*t12r*.txt');\neq1600v1t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/EQ'], 'files', 't*1600v1*t12r*.txt');\neqv1t12 = {eq100v1t12, eq200v1t12, eq400v1t12, eq800v1t12, eq1600v1t12};\n\n% Define Java EX implementation specs (runs with 12 threads), parameter set 1\nex100v1t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/EX'], 'files', 't*100v1*t12r*.txt');\nex200v1t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/EX'], 'files', 't*200v1*t12r*.txt');\nex400v1t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/EX'], 'files', 't*400v1*t12r*.txt');\nex800v1t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/EX'], 'files', 't*800v1*t12r*.txt');\nex1600v1t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/EX'], 'files', 't*1600v1*t12r*.txt');\nexv1t12 = {ex100v1t12, ex200v1t12, ex400v1t12, ex800v1t12, ex1600v1t12};\n\n% Define Java ER implementation specs (runs with 12 threads), parameter set 1\ner100v1t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/ER'], 'files', 't*100v1*t12r*.txt');\ner200v1t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/ER'], 'files', 't*200v1*t12r*.txt');\ner400v1t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/ER'], 'files', 't*400v1*t12r*.txt');\ner800v1t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/ER'], 'files', 't*800v1*t12r*.txt');\ner1600v1t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/ER'], 'files', 't*1600v1*t12r*.txt');\nerv1t12 = {er100v1t12, er200v1t12, er400v1t12, er800v1t12, er1600v1t12};\n\n% Define Java OD implementation specs (runs with 12 threads, b = 500), parameter set 1\nod100v1t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*100v1*b500t12r*.txt');\nod200v1t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*200v1*b500t12r*.txt');\nod400v1t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/OD'], 'files', 't*400v1*b500t12r*.txt');\nod800v1t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/OD'], 'files', 't*800v1*b500t12r*.txt');\nod1600v1t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/OD'], 'files', 't*1600v1*b500t12r*.txt');\nodv1t12 = {od100v1t12, od200v1t12, od400v1t12, od800v1t12, od1600v1t12};\n\n% %%%%%%%%%%%%%%%%%%%%%%%%% %\n% Specs for parameter set 2 %\n% %%%%%%%%%%%%%%%%%%%%%%%%% %\n\n% Define NetLogo implementation specs, parameter set 2\nnl100v2 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/NL'], 'files', 't*100v2*.txt');\nnl200v2 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/NL'], 'files', 't*200v2*.txt');\nnl400v2 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/NL'], 'files', 't*400v2*.txt');\nnl800v2 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/NL'], 'files', 't*800v2*.txt');\nnl1600v2 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/NL'], 'files', 't*1600v2*.txt');\nnlv2 = {nl100v2, nl200v2, nl400v2, nl800v2, nl1600v2};\n\n% Define Java ST implementation specs, parameter set 2\nst100v2 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/ST'], 'files', 't*100v2*.txt');\nst200v2 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/ST'], 'files', 't*200v2*.txt');\nst400v2 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst800v2 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/ST'], 'files', 't*800v2*.txt');\nst1600v2 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/ST'], 'files', 't*1600v2*.txt');\nstv2 = {st100v2, st200v2, st400v2, st800v2, st1600v2};\n\n% Define Java EQ implementation specs (runs with 12 threads), parameter set 2\neq100v2t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/EQ'], 'files', 't*100v2*t12r*.txt');\neq200v2t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/EQ'], 'files', 't*200v2*t12r*.txt');\neq400v2t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t12r*.txt');\neq800v2t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/EQ'], 'files', 't*800v2*t12r*.txt');\neq1600v2t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/EQ'], 'files', 't*1600v2*t12r*.txt');\neqv2t12 = {eq100v2t12, eq200v2t12, eq400v2t12, eq800v2t12, eq1600v2t12};\n\n% Define Java EX implementation specs (runs with 12 threads), parameter set 2\nex100v2t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/EX'], 'files', 't*100v2*t12r*.txt');\nex200v2t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/EX'], 'files', 't*200v2*t12r*.txt');\nex400v2t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t12r*.txt');\nex800v2t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/EX'], 'files', 't*800v2*t12r*.txt');\nex1600v2t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/EX'], 'files', 't*1600v2*t12r*.txt');\nexv2t12 = {ex100v2t12, ex200v2t12, ex400v2t12, ex800v2t12, ex1600v2t12};\n\n% Define Java ER implementation specs (runs with 12 threads), parameter set 2\ner100v2t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/ER'], 'files', 't*100v2*t12r*.txt');\ner200v2t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/ER'], 'files', 't*200v2*t12r*.txt');\ner400v2t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t12r*.txt');\ner800v2t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/ER'], 'files', 't*800v2*t12r*.txt');\ner1600v2t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/ER'], 'files', 't*1600v2*t12r*.txt');\nerv2t12 = {er100v2t12, er200v2t12, er400v2t12, er800v2t12, er1600v2t12};\n\n% Define Java OD implementation specs (runs with 12 threads, b = 500), parameter set 2\nod100v2t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b500t12r*.txt');\nod200v2t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b500t12r*.txt');\nod400v2t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t12r*.txt');\nod800v2t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b500t12r*.txt');\nod1600v2t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b500t12r*.txt');\nodv2t12 = {od100v2t12, od200v2t12, od400v2t12, od800v2t12, od1600v2t12};\n```\n\nAfter the implementation specs are defined, we create two intermediate tables:\n\n```matlab\n% %%%%%%%%%%%%%%%%%%% %\n% Intermediate tables %\n% %%%%%%%%%%%%%%%%%%% %\n\n% Parameter set 1\ndata_v1 = times_table([1 2], 'NL', nlv1, 'ST', stv1, 'EQ', eqv1t12, 'EX', exv1t12, 'ER', erv1t12, 'OD', odv1t12);\n\n% Parameter set 2\ndata_v2 = times_table([1 2], 'NL', nlv2, 'ST', stv2, 'EQ', eqv2t12, 'EX', exv2t12, 'ER', erv2t12, 'OD', odv2t12);\n```\n\nWe first print a plain text table, to check how the information is organized:\n\n```matlab\n% %%%%%%%%%%%% %\n% Print tables %\n% %%%%%%%%%%%% %\n\n% Plain text table\ntimes_table_f(0, 'Param. set 1', data_v1, 'Param. set 2', data_v2)\n```\n\n```\n                  ---------------------------------------------------------------------------------------------------------------------\n                  |                    Param. set 1                         |                    Param. set 2                         |\n---------------------------------------------------------------------------------------------------------------------------------------\n| Imp.   | Set.   |   t(s)     |   std     |  std%  | x     NL  | x     ST  |   t(s)     |   std     |  std%  | x     NL  | x     ST  |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     NL |    100 |       15.9 |     0.359 |   2.26 |         1 |     0.171 |       32.2 |     0.686 |   2.13 |         1 |     0.166 |\n|        |    200 |        100 |      1.25 |   1.25 |         1 |     0.121 |        245 |       1.5 |   0.61 |         1 |     0.147 |\n|        |    400 |        481 |      6.02 |   1.25 |         1 |     0.175 |   1.07e+03 |      3.63 |   0.34 |         1 |     0.148 |\n|        |    800 |   2.08e+03 |      9.75 |   0.47 |         1 |     0.184 |   4.54e+03 |      23.2 |   0.51 |         1 |     0.154 |\n|        |   1600 |   9.12e+03 |      94.1 |   1.03 |         1 |     0.184 |   1.96e+04 |      90.9 |   0.46 |         1 |     0.151 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     ST |    100 |       2.71 |    0.0223 |   0.82 |      5.85 |         1 |       5.34 |     0.051 |   0.96 |      6.03 |         1 |\n|        |    200 |       12.2 |     0.219 |   1.80 |      8.24 |         1 |       36.1 |     0.178 |   0.49 |      6.79 |         1 |\n|        |    400 |       84.4 |      2.83 |   3.35 |      5.71 |         1 |        159 |     0.474 |   0.30 |      6.76 |         1 |\n|        |    800 |        383 |      5.04 |   1.32 |      5.43 |         1 |        700 |      3.67 |   0.52 |      6.49 |         1 |\n|        |   1600 |   1.68e+03 |      78.4 |   4.67 |      5.43 |         1 |   2.96e+03 |       123 |   4.15 |      6.61 |         1 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     EQ |    100 |       1.55 |    0.0251 |   1.62 |      10.2 |      1.75 |       1.87 |    0.0287 |   1.53 |      17.2 |      2.85 |\n|        |    200 |       2.81 |     0.113 |   4.01 |      35.6 |      4.32 |       7.08 |     0.126 |   1.78 |      34.6 |       5.1 |\n|        |    400 |       19.5 |     0.214 |   1.10 |      24.7 |      4.34 |       31.2 |     0.207 |   0.66 |      34.5 |       5.1 |\n|        |    800 |       86.1 |      4.26 |   4.95 |      24.1 |      4.45 |        125 |      4.15 |   3.32 |      36.2 |      5.58 |\n|        |   1600 |        279 |      4.04 |   1.45 |      32.6 |      6.01 |        487 |      8.48 |   1.74 |      40.1 |      6.07 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     EX |    100 |       1.53 |    0.0291 |   1.90 |      10.4 |      1.78 |       2.14 |    0.0587 |   2.75 |      15.1 |       2.5 |\n|        |    200 |       2.91 |     0.107 |   3.69 |      34.4 |      4.18 |       8.08 |     0.141 |   1.74 |      30.4 |      4.47 |\n|        |    400 |       19.6 |     0.302 |   1.54 |      24.6 |      4.31 |       34.2 |     0.527 |   1.54 |      31.4 |      4.65 |\n|        |    800 |       86.5 |      5.46 |   6.31 |        24 |      4.42 |        139 |      5.96 |   4.29 |      32.6 |      5.03 |\n|        |   1600 |        282 |      5.49 |   1.95 |      32.4 |      5.96 |        532 |      5.24 |   0.99 |      36.8 |      5.56 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     ER |    100 |       7.29 |     0.325 |   4.46 |      2.18 |     0.372 |       8.39 |     0.148 |   1.76 |      3.83 |     0.636 |\n|        |    200 |       16.4 |      0.77 |   4.68 |       6.1 |      0.74 |       17.9 |     0.252 |   1.41 |      13.7 |      2.02 |\n|        |    400 |       37.2 |     0.204 |   0.55 |        13 |      2.27 |       45.9 |     0.285 |   0.62 |      23.4 |      3.46 |\n|        |    800 |        111 |      3.37 |   3.02 |      18.6 |      3.43 |        159 |      3.21 |   2.02 |      28.5 |      4.39 |\n|        |   1600 |        332 |       3.5 |   1.06 |      27.5 |      5.06 |        553 |      8.03 |   1.45 |      35.3 |      5.34 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     OD |    100 |       1.36 |    0.0158 |   1.16 |      11.7 |         2 |          2 |    0.0331 |   1.66 |      16.1 |      2.68 |\n|        |    200 |       2.68 |      0.07 |   2.61 |      37.4 |      4.54 |       6.64 |     0.109 |   1.64 |        37 |      5.44 |\n|        |    400 |       19.2 |     0.199 |   1.04 |      25.1 |       4.4 |       29.1 |     0.122 |   0.42 |      36.9 |      5.46 |\n|        |    800 |       82.9 |      2.27 |   2.73 |        25 |      4.61 |        118 |         3 |   2.55 |      38.6 |      5.95 |\n|        |   1600 |        292 |      8.51 |   2.91 |      31.2 |      5.74 |        479 |      9.32 |   1.95 |      40.8 |      6.18 |\n---------------------------------------------------------------------------------------------------------------------------------------\n```\n\nFinally, we produce a LaTeX table, as shown in reference [\\[1\\]](#ref1):\n\n```matlab\n% LaTex table\ntimes_table_f(1, 'Param. set 1', data_v1, 'Param. set 2', data_v2)\n```\n\n![ex4 2 15](https://cloud.githubusercontent.com/assets/3018963/14706360/f6f17d18-07b5-11e6-926f-2314f9d59206.png)\n\n## License\n\n[MIT License](LICENSE)\n\n## References\n\n<a name=\"ref1\"></a>\n\n[\\[1\\]](#ref1) Fachada N, Lopes VV, Martins RC, Rosa AC. (2016) Parallelization\nStrategies for Spatial Agent-Based Models. *International Journal of Parallel\nProgramming*. https://doi.org/10.1007/s10766-015-0399-9 (arXiv version available\nat http://arxiv.org/abs/1507.04047)\n\n[Matlab]: http://www.mathworks.com/products/matlab/\n[Octave]: https://gnu.org/software/octave/\n[NetLogo]: https://ccl.northwestern.edu/netlogo/\n[sorttest.c]: https://github.com/fakenmc/sorttest_c\n[alternative]: http://stackoverflow.com/questions/673523/how-to-measure-execution-time-of-command-in-windows-command-line\n[sort_data]: data\n[pphpc_data]: http://dx.doi.org/10.5281/zenodo.34049\n[matlab2tikz]: http://www.mathworks.com/matlabcentral/fileexchange/22022-matlab2tikz-matlab2tikz\n[Bubble sort]: https://en.wikipedia.org/wiki/Bubble_sort\n[Selection sort]: https://en.wikipedia.org/wiki/Selection_sort\n[Merge sort]: https://en.wikipedia.org/wiki/Merge_sort\n[Quicksort]: https://en.wikipedia.org/wiki/Quicksort\n[PPHPC]: https://github.com/fakenmc/pphpc\n[GNU time]: https://www.gnu.org/software/time/\n[siunitx]: https://www.ctan.org/pkg/siunitx\n[multirow]: https://www.ctan.org/pkg/multirow\n[booktabs]: https://www.ctan.org/pkg/booktabs\n[get_gtime]: get_gtime.m\n[gather_times]: gather_times.m\n[perfstats]: perfstats.m\n[speedup]: speedup.m\n[times_table]: times_table.m\n[times_table_f]: times_table_f.m\n\n", 
  "description": "Performance analysis and publishing tools", 
  "README.md": "PerfAndPubTools\n===============\n\n1\\.  [What is PerfAndPubTools?](#whatisperfandpubtools?)  \n2\\.  [Benchmark file format](#benchmarkfileformat)  \n3\\.  [Architecture and functions](#architectureandfunctions)  \n4\\.  [Examples](#examples)  \n4.1\\.  [Performance analysis of sorting algorithms](#performanceanalysisofsortingalgorithms)  \n4.1.1\\.  [Extract performance data from a file](#extractperformancedatafromafile)  \n4.1.2\\.  [Extract execution times from files in a folder](#extractexecutiontimesfromfilesinafolder)  \n4.1.3\\.  [Average execution times and standard deviations](#averageexecutiontimesandstandarddeviations)  \n4.1.4\\.  [Compare multiple setups within the same implementation](#comparemultiplesetupswithinthesameimplementation)  \n4.1.5\\.  [Same as previous, with a linear plot](#sameaspreviouswithalinearplot)  \n4.1.6\\.  [Compare different implementations](#comparedifferentimplementations)  \n4.1.7\\.  [Speedup](#speedup)  \n4.1.8\\.  [Speedup for multiple algorithms and vector sizes](#speedupformultiplealgorithmsandvectorsizes)  \n4.1.9\\.  [Custom speedup plots](#customspeedupplots)  \n4.1.10\\.  [Scalability of the different sorting algorithms for increasing vector sizes](#scalabilityofthedifferentsortingalgorithmsforincreasingvectorsizes)  \n4.1.11\\.  [Custom scalability plots](#customscalabilityplots)  \n4.1.12\\.  [Produce a table instead of a plot](#produceatableinsteadofaplot)  \n4.2\\.  [Performance analysis of a simulation model](#performanceanalysisofasimulationmodel)  \n4.2.1\\.  [Implementations and setups of the PPHPC agent-based model](#implementationsandsetupsofthepphpcagent-basedmodel)  \n4.2.2\\.  [Extract performance data from a file](#extractperformancedatafromafile-1)  \n4.2.3\\.  [Extract execution times from files in a folder](#extractexecutiontimesfromfilesinafolder-1)  \n4.2.4\\.  [Average execution times and standard deviations](#averageexecutiontimesandstandarddeviations-1)  \n4.2.5\\.  [Compare multiple setups within the same implementation](#comparemultiplesetupswithinthesameimplementation-1)  \n4.2.6\\.  [Same as previous, with a log-log plot](#sameaspreviouswithalog-logplot)  \n4.2.7\\.  [Compare different implementations](#comparedifferentimplementations-1)  \n4.2.8\\.  [Speedup](#speedup-1)  \n4.2.9\\.  [Speedup for multiple parallel implementations and sizes](#speedupformultipleparallelimplementationsandsizes)  \n4.2.10\\.  [Scalability of the different implementations for increasing model sizes](#scalabilityofthedifferentimplementationsforincreasingmodelsizes)  \n4.2.11\\.  [Scalability of parallel implementations for increasing number of threads](#scalabilityofparallelimplementationsforincreasingnumberofthreads)  \n4.2.12\\.  [Performance of OD strategy for different values of _b_](#performanceofodstrategyfordifferentvaluesof_b_)  \n4.2.13\\.  [Custom performance plot](#customperformanceplot)  \n4.2.14\\.  [Show a table instead of a plot](#showatableinsteadofaplot)  \n4.2.15\\.  [Complex tables](#complextables)  \n5\\.  [License](#license)  \n6\\.  [References](#references)  \n\n<a name=\"whatisperfandpubtools?\"></a>\n\n## 1\\. What is PerfAndPubTools?\n\n_PerfAndPubTools_ consists of a set of [MATLAB]/[Octave] functions for analyzing\nsoftware performance benchmark results and producing associated publication\nquality materials.\n\n<a name=\"benchmarkfileformat\"></a>\n\n## 2\\. Benchmark file format\n\nBy default, _PerfAndPubTools_ expects individual benchmarking results to be\navailable as files containing the default output of [GNU time] command, for\nexample:\n\n```\n512.66user 2.17system 8:01.34elapsed 106%CPU (0avgtext+0avgdata 1271884maxresident)k\n0inputs+2136outputs (0major+49345minor)pagefaults 0swaps\n```\n\nThis preset selection can be easily modified as described in the next sections.\n\n<a name=\"architectureandfunctions\"></a>\n\n## 3\\. Architecture and functions\n\n_PerfAndPubTools_ is implemented in a layered architecture using a procedural\nprogramming approach, as shown in the following figure:\n\n![arch](https://cloud.githubusercontent.com/assets/3018963/12206544/74c5ac38-b639-11e5-87c2-fc65e6bf8875.png)\n\nPerformance analysis in _PerfAndPubTools_ takes place at two levels:\n*implementation* and *setup*. The *implementation* level is meant to be\nassociated with specific software implementations for performing a given task,\nfor example a particular sorting algorithm or a simulation model realized in\na certain programming language. Within the context of each implementation, the\nsoftware can be executed under different *setups*. These can be different\ncomputational sizes (e.g. vector lengths in a sorting algorithm) or distinct\nexecution parameters (e.g. number of threads used).\n\n_PerfAndPubTools_ is bundled with the following functions, from lowest to\nhighest-level of functionality:\n\n* [get_gtime] - Given a file containing the default output of the [GNU time]\ncommand, this function extracts the user, system and elapsed times in seconds,\nas well as the percentage of CPU usage.\n\n* [gather_times] - Loads execution times from files in a given folder. This\nfunction uses [get_gtime] by default, but can be configured to use another\nfunction to load individual benchmark files with a different format.\n\n* [perfstats] - Determines mean times and respective standard deviations of a\ncomputational experiment using folders of files containing benchmarking results,\noptionally plotting a scalability graph if different setups correspond to\ndifferent computational work sizes.\n\n* [speedup] - Determines the average, maximum and minimum speedups against one\nor more reference *implementations* across a number of *setups*. Can optionally\ngenerate a bar plot displaying the various speedups.\n\n* [times_table] - Returns a matrix with useful contents for using in tables for\npublication, namely times (in seconds), absolute standard deviations (seconds),\nrelative standard deviations, speedups (vs the specified implementations).\n\n* [times_table_f] - Returns a table with performance analysis results formatted\nin plain text or in LaTeX (the latter requires the [siunitx], [multirow] and\n[booktabs] packages).\n\nAlthough the [perfstats] and [speedup] functions optionally create plots, these\nare mainly intended to provide visual feedback on the performance analysis being\nundertaken. Those needing more control over the final figures can customize the\ngenerated plots via the returned figure handles or create custom plots using the\ndata provided by [perfstats] and [speedup]. Either way, [MATLAB]/[Octave] plots\ncan be used directly in publications, or converted to LaTeX using the excellent\n[matlab2tikz] script, as will be shown in some of the examples.\n\n<a name=\"examples\"></a>\n\n## 4\\. Examples\n\nExamples are organized into two sections:\n\n1. [Performance analysis of sorting algorithms](#exsortalgs)\n2. [Performance analysis of a simulation model](#exsimmods)\n\nExamples in the first section demonstrate the complete process of benchmarking a\nnumber of sorting algorithms with the [GNU time] command and then analyzing\nresults with _PerfAndPubTools_. Since the [GNU time] command is not available on\nWindows, the data produced by the benchmarks is [included][sort_data] in the\npackage.\n\nExamples in the second section focus on showing how _PerfAndPubTools_ was used\nto analyze performance data of multiple implementations of a\n[simulation model][PPHPC], replicating results presented in a peer-reviewed\narticle [\\[1\\]](#ref1). The initial benchmarking steps are skipped in these\nexamples, but the produced data and the scripts used to generate it are also\nmade [available][pphpc_data].\n\n<a name=\"exsortalgs\"></a>\n\n<a name=\"performanceanalysisofsortingalgorithms\"></a>\n\n### 4.1\\. Performance analysis of sorting algorithms\n\nIn following examples, we use _PerfAndPubTools_ to analyze the performance of\nseveral sorting algorithms implemented in C. Perform the following steps before\nproceeding:\n\n1. Download and compile the [sorttest.c] program (instructions are available in\nthe linked page).\n2. Confirm that the [GNU time] program is installed (instructions also available\nin [sorttest.c]).\n3. In [MATLAB]/[Octave] create a `sortfolder` variable containing the full path\nof the [sorttest.c] program, for example `sortfolder = '/home/user/sort'`\n(Unix/Linux) or `sortfolder = 'C:\\Users\\UserName\\Documents\\sort'` (Windows).\n\n[GNU time] is usually invoked as `/usr/bin/time`, but this can vary for\ndifferent Linux distributions. On OSX it is invoked as `gtime`. The usual Linux\ninvocation is used for throughout the examples, replace it as appropriate.\n\nSince the [GNU time] program does not seem to be available for Windows, these\nexamples only run unmodified on Linux and OSX. On Windows, benchmark the\n[sorttest.c] program using an [alternative] approach and replace [get_gtime]\nwith a function which parses the produced output. Otherwise, skip the actual\nbenchmarking steps within the examples, and use the benchmarking data bundled\nwith _PerfAndPubTools_ in the [data][sort_data] folder.\n\n<a name=\"extractperformancedatafromafile\"></a>\n\n#### 4.1.1\\. Extract performance data from a file\n\nFirst, check that the [sorttest.c] program is working by testing the [Quicksort]\nalgorithm with a vector of 1,000,000 random integers:\n\n```\n$ ./sorttest quick 1000000 2362 yes\nSorting Ok!\n```\n\nThe value `2362` is the seed for the random number generator, and the optional\n`yes` parameter asks the program to output a message confirming if the sorting\nwas successful.\n\nNow, create a benchmark file with [GNU time]:\n\n```\n$ /usr/bin/time ./sorttest quick 1000000 2362 2> out.txt \n```\n\nThe `2>` part redirects the output of [GNU time] to a file called `out.txt`.\nThis file can be parsed with the [get_gtime] function from [MATLAB] or [Octave]:\n\n```matlab\np = get_gtime('out.txt')\n```\n\nThe function returns a structure with several fields:\n\n```\np = \n\n       user: 0.2000\n        sys: 0\n    elapsed: 0.2000\n        cpu: 99\n```\n\n<a name=\"extractexecutiontimesfromfilesinafolder\"></a>\n\n#### 4.1.2\\. Extract execution times from files in a folder\n\nThe [gather_times] function extracts execution times from multiple files in a\nfolder. This is useful for analyzing average run times over a number of runs.\nFirst, we need to perform these runs. From a terminal, run the following\ncommand, which performs 10 runs of the [sorttest.c] program:\n\n```\n$ for RUN in {1..10}; do /usr/bin/time ./sorttest quick 1000000 $RUN 2> time_quick_1000000_$RUN.txt; done\n```\n\nNote that each run is performed with a different seed, so that different vectors\nare sorted by [Quicksort] each turn. In [MATLAB] or [Octave], use the\n[gather_times] function to extract execution times:\n\n```matlab\nexec_time = gather_times('Quicksort', sortfolder, 'time_quick_1000000_*.txt');\n```\n\nThe first parameter names the list of gathered times, and is used as metadata by\nother functions. The second parameter specifies the folder where the [GNU time]\noutput files are located. The vector of execution times is in the `elapsed`\nfield of the returned structure:\n\n```matlab\nexec_time.elapsed\n```\n\nThe [gather_times] function uses [get_gtime] internally by default. However, \nother functions can be specified in the first line of the [gather_times]\nfunction body, allowing _PerfAndPubTools_ to support benchmarking formats other\nthan the output of [GNU time]. Alternatives to [get_gtime] are only required to\nreturn a struct with the `elapsed` field, indicating the duration (in seconds)\nof a program execution.\n\n<a name=\"averageexecutiontimesandstandarddeviations\"></a>\n\n#### 4.1.3\\. Average execution times and standard deviations\n\nIn its most basic usage, the [perfstats] function obtains performance\nstatistics. In this example, average execution times and standard deviations are\nobtained from the runs performed in the previous example:\n\n```matlab\nqs1M = struct('sname', 'Quicksort', 'folder', sortfolder, 'files', 'time_quick_1000000_*.txt');\n[avg_time, std_time] = perfstats(0, 'QuickSort', {qs1M})\n```\n\n```\navg_time =\n\n    0.1340\n\n\nstd_time =\n\n    0.0052\n```\n\nThe `qs1M` variable specifies a *setup*. A setup is defined by the following\nfields: a) `sname`, the name of the setup; b) `folder`, the folder where to load\nbenchmark files from; c) `files`, the specific files to load (using wildcards);\nand, d) `csize`, an optional computational size for plotting purposes. \n\n\n<a name=\"comparemultiplesetupswithinthesameimplementation\"></a>\n\n#### 4.1.4\\. Compare multiple setups within the same implementation\n\nA more advanced use case for [perfstats] consists of comparing multiple setups\nassociated with different computational sizes within the same implementation\n(e.g., the same sorting algorithm). A set of multiple setups is designated as an\n*implementation spec*, the basic object type accepted by the [perfstats],\n[speedup] and [times_table] functions. An implementation spec defines one or\nmore *setups* for a single *implementation*.\n\nIn this example we analyze how the performance of the [Bubble sort] algorithm\nvaries for increasing vector sizes. First, perform a number of runs with\n[sorttest.c] using [Bubble sort] for vectors of size 10,000, 20,000 and 30,000:\n\n```\n$ for RUN in {1..10}; do for SIZE in 10000 20000 30000; do /usr/bin/time ./sorttest bubble $SIZE $RUN 2> time_bubble_${SIZE}_${RUN}.txt; done; done\n```\n\nSecond, obtain the average times for the several vector sizes using [perfstats]:\n\n```matlab\n% Specify the setups\nbs10k = struct('sname', 'bs10k', 'folder', sortfolder, 'files', 'time_bubble_10000_*.txt');\nbs20k = struct('sname', 'bs20k', 'folder', sortfolder, 'files', 'time_bubble_20000_*.txt');\nbs30k = struct('sname', 'bs30k', 'folder', sortfolder, 'files', 'time_bubble_30000_*.txt');\n\n% Specify the implementation spec\nbs =  {bs10k, bs20k, bs30k};\n\n% Determine average time for each setup\navg_time = perfstats(0, 'bubble', {bs10k, bs20k, bs30k})\n```\n\n```\navg_time =\n\n    0.3220    1.3370    3.1070\n```\n\n<a name=\"sameaspreviouswithalinearplot\"></a>\n\n#### 4.1.5\\. Same as previous, with a linear plot\n\nThe [perfstats] function can also generate scalability plots. For this purpose,\nthe computational size, `csize`, must be specified in each setup, and the first\nparameter should be a value between 1 (linear plot) and 4 (log-log plot), as\nshown in the following commands:\n\n```matlab\n% Specify the setups\nbs10k = struct('sname', 'bs10k', 'csize', 1e4, 'folder', sortfolder, 'files', 'time_bubble_10000_*.txt');\nbs20k = struct('sname', 'bs20k', 'csize', 2e4, 'folder', sortfolder, 'files', 'time_bubble_20000_*.txt');\nbs30k = struct('sname', 'bs30k', 'csize', 3e4, 'folder', sortfolder, 'files', 'time_bubble_30000_*.txt');\n\n% Specify the implementation spec\nbs =  {bs10k, bs20k, bs30k};\n\n% The first parameter defines the plot type: 1 is a linear plot\nperfstats(1, 'bubble', bs);\n```\n\n![ex4 1 5_1](https://cloud.githubusercontent.com/assets/3018963/14692286/0d3a86ae-074e-11e6-95c7-270c35ce04de.png)\n\nError bars, showing the standard deviation, can be activated by passing a\nnegative value as the first parameter:\n\n```matlab\n% The first parameter defines the plot type: -1 is a linear plot\n% with error bars showing the standard deviation\nperfstats(-1, 'bubble', bs);\n```\n\n![ex4 1 5_2](https://cloud.githubusercontent.com/assets/3018963/14692287/0d40bbbe-074e-11e6-8d2c-c7d245b7cbd1.png)\n\n<a name=\"comparedifferentimplementations\"></a>\n\n#### 4.1.6\\. Compare different implementations\n\nBesides comparing multiple setups within the same implementation, the\n[perfstats] function is also able to compare multiple setups from multiple\nimplementations. The requirement is that, from implementation to implementation,\nthe multiple setups are directly comparable, i.e., corresponding implementation\nspecs should have the same `sname` and `csize` parameters.\n\nFirst, perform a number of runs with [sorttest.c] using [Merge sort] and\n[Quicksort] for vectors of size 1e4, 1e5, 1e6 and 1e7:\n\n```\n$ for RUN in {1..10}; do for IMPL in merge quick; do for SIZE in 100000 1000000 10000000 100000000; do /usr/bin/time ./sorttest $IMPL $SIZE $RUN 2> time_${IMPL}_${SIZE}_${RUN}.txt; done; done; done\n```\n\nSecond, use [perfstats] to plot the respective scalability graph:\n\n```matlab\n% Specify Merge sort implementation specs\nms1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_merge_100000_*.txt');\nms1e6 = struct('sname', '1e6', 'csize', 1e6, 'folder', sortfolder, 'files', 'time_merge_1000000_*.txt');\nms1e7 = struct('sname', '1e7', 'csize', 1e7, 'folder', sortfolder, 'files', 'time_merge_10000000_*.txt');\nms1e8 = struct('sname', '1e8', 'csize', 1e8, 'folder', sortfolder, 'files', 'time_merge_100000000_*.txt');\nms = {ms1e5, ms1e6, ms1e7, ms1e8};\n\n% Specify Quicksort implementation specs\nqs1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_quick_100000_*.txt');\nqs1e6 = struct('sname', '1e6', 'csize', 1e6, 'folder', sortfolder, 'files', 'time_quick_1000000_*.txt');\nqs1e7 = struct('sname', '1e7', 'csize', 1e7, 'folder', sortfolder, 'files', 'time_quick_10000000_*.txt');\nqs1e8 = struct('sname', '1e8', 'csize', 1e8, 'folder', sortfolder, 'files', 'time_quick_100000000_*.txt');\nqs = {qs1e5, qs1e6, qs1e7, qs1e8};\n\n% Plot comparison with a log-log plot\nperfstats(4, 'Merge sort', ms, 'Quicksort', qs);\n```\n\n![ex4 1 6_1](https://cloud.githubusercontent.com/assets/3018963/14692288/0d42faaa-074e-11e6-8eea-94dde29d3e5d.png)\n\nLike in the previous example, error bars are displayed by passing a negative\nvalue as the first parameter to [perfstats]:\n\n```matlab\n% Plot comparison with a log-log plot with error bars\nperfstats(-4, 'Merge sort', ms, 'Quicksort', qs);\n```\n\n![ex4 1 6_2](https://cloud.githubusercontent.com/assets/3018963/14692289/0d47a0c8-074e-11e6-928e-6f5fd8ed6528.png)\n\n<a name=\"speedup\"></a>\n\n#### 4.1.7\\. Speedup\n\nThe [speedup] function is used to obtain relative speedups between different\nimplementations. Using the variables defined in the previous example, the\nfollowing instruction obtains the average, maximum and minimum speedups of\n[Quicksort] versus [Merge sort] for different vector sizes:\n\n```matlab\n[s_avg, s_max, s_min] = speedup(0, 1, 'Merge sort', ms, 'Quicksort', qs);\n```\n\nSpeedups can be obtained by getting the first element of the returned cell, i.e.\nby invoking `s_avg{1}`:\n\n```\nans =\n\n    1.0000    1.0000    1.0000    1.0000\n    2.0000    1.7164    1.7520    1.6314\n```\n\nThe second parameter indicates the reference implementation from which to \ncalculate speedups. In this case, specifying 1 will return speedups against\nMerge sort. The first row of the previous matrix shows the speedup of\n[Merge sort] against itself, thus it is composed of ones. The second row shows\nthe speedup of [Quicksort] versus [Merge sort]. If the second parameter is a\nvector, speedups against more than one implementation are returned.\n\nSetting the first parameter to 1 will yield a bar plot displaying the average\nspeedups:\n\n```matlab\nspeedup(1, 1, 'Merge sort', ms, 'Quicksort', qs);\n```\n\n![ex4 1 7_1](https://cloud.githubusercontent.com/assets/3018963/14688435/6bf1c108-073a-11e6-8cc8-258ea48f04a5.png)\n\nSpeedup bar plots also support error bars, but in this case error bars show the\nmaximum and minimum speedups. Error bars are activated by passing a negative\nnumber as the first argument to [speedup]:\n\n```matlab\nspeedup(-1, 1, 'Merge sort', ms, 'Quicksort', qs);\n```\n\n![ex4 1 7_2](https://cloud.githubusercontent.com/assets/3018963/14715181/cfda758e-07df-11e6-8013-10364091773b.png)\n\n<a name=\"speedupformultiplealgorithmsandvectorsizes\"></a>\n\n#### 4.1.8\\. Speedup for multiple algorithms and vector sizes\n\nThe [speedup] function is also able to determine relative speedups between\ndifferent implementations for multiple computational sizes. In this example we\nplot the average speedup of several sorting algorithms against [Bubble sort] and\n[Selection sort] for vector sizes 1e5, 2e5, 3e5 and 4e5. \n\nFirst, perform a number of runs using the four sorting algorithms made available\nby [sorttest.c] for the specified vector sizes:\n\n```\n$ for RUN in {1..10}; do for IMPL in bubble selection merge quick; do for SIZE in 100000 200000 300000 400000; do /usr/bin/time ./sorttest $IMPL $SIZE $RUN 2> time_${IMPL}_${SIZE}_${RUN}.txt; done; done; done\n```\n\nThen, in [MATLAB] or [Octave], specify the implementation specs for each sorting\nalgorithm and setup combination, and use the [speedup] function to  plot the\nrespective speedup plot:\n\n```matlab\n% Specify Bubble sort implementation specs\nbs1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_bubble_100000_*.txt');\nbs2e5 = struct('sname', '2e5', 'csize', 2e5, 'folder', sortfolder, 'files', 'time_bubble_200000_*.txt');\nbs3e5 = struct('sname', '3e5', 'csize', 3e5, 'folder', sortfolder, 'files', 'time_bubble_300000_*.txt');\nbs4e5 = struct('sname', '4e5', 'csize', 4e5, 'folder', sortfolder, 'files', 'time_bubble_400000_*.txt');\nbs = {bs1e5, bs2e5, bs3e5, bs4e5};\n\n% Specify Selection sort implementation specs\nss1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_selection_100000_*.txt');\nss2e5 = struct('sname', '2e5', 'csize', 2e5, 'folder', sortfolder, 'files', 'time_selection_200000_*.txt');\nss3e5 = struct('sname', '3e5', 'csize', 3e5, 'folder', sortfolder, 'files', 'time_selection_300000_*.txt');\nss4e5 = struct('sname', '4e5', 'csize', 4e5, 'folder', sortfolder, 'files', 'time_selection_400000_*.txt');\nss = {ss1e5, ss2e5, ss3e5, ss4e5};\n\n% Specify Merge sort implementation specs\nms1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_merge_100000_*.txt');\nms2e5 = struct('sname', '2e5', 'csize', 2e5, 'folder', sortfolder, 'files', 'time_merge_200000_*.txt');\nms3e5 = struct('sname', '3e5', 'csize', 3e5, 'folder', sortfolder, 'files', 'time_merge_300000_*.txt');\nms4e5 = struct('sname', '4e5', 'csize', 4e5, 'folder', sortfolder, 'files', 'time_merge_400000_*.txt');\nms = {ms1e5, ms2e5, ms3e5, ms4e5};\n\n% Specify Quicksort implementation specs\nqs1e5 = struct('sname', '1e5', 'csize', 1e5, 'folder', sortfolder, 'files', 'time_quick_100000_*.txt');\nqs2e5 = struct('sname', '2e5', 'csize', 2e5, 'folder', sortfolder, 'files', 'time_quick_200000_*.txt');\nqs3e5 = struct('sname', '3e5', 'csize', 3e5, 'folder', sortfolder, 'files', 'time_quick_300000_*.txt');\nqs4e5 = struct('sname', '4e5', 'csize', 4e5, 'folder', sortfolder, 'files', 'time_quick_400000_*.txt');\nqs = {qs1e5, qs2e5, qs3e5, qs4e5};\n\n% Plot speedup of multiple sorting algorithms against Bubble sort\n% Setting the first parameter to 2 will yields a log-scale bar plot\nspeedup(2, 1, 'Bubble', bs, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthWest');\n```\n\n![ex4 1 8_1](https://cloud.githubusercontent.com/assets/3018963/14703285/15d2f75c-07a7-11e6-8f0f-bd5d83bb5774.png)\n\n```matlab\n% Plot speedup of multiple sorting algorithms against Selection sort\nspeedup(1, 1, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthWest');\n```\n\n![ex4 1 8_2](https://cloud.githubusercontent.com/assets/3018963/14703318/399654a4-07a7-11e6-8828-a84ce171ff5a.png)\n\n\nIf we require error bars, the first parameter should be a negative value:\n\n```matlab\n% Same plot with error bars\nspeedup(-1, 1, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Place legend in a better position\nl = legend(gca);\nset(l, 'Location', 'NorthWest');\n```\n\n![ex4 1 8_3](https://cloud.githubusercontent.com/assets/3018963/14715383/83ffe3e6-07e0-11e6-8bd0-33898a6c5159.png)\n\nGenerated plots can be customized using the [MATLAB] or [Octave] GUI, or\nprogrammatically. The following commands change some of the default properties\nof the previous plot:\n\n```matlab\n% Get the current axes children objects\nch = get(gca, 'Children');\n\n% Set the color of the '1e5' bars to white\nset(ch(8), 'FaceColor', 'w');\n\n% This is required in Octave for updating the legend\nlegend(gca);\n\n% Change the default labels\nylabel('Average speedup over Selection sort');\nxlabel('Algorithms');\n```\n\n![ex4 1 8_4](https://cloud.githubusercontent.com/assets/3018963/14715384/84054192-07e0-11e6-9da1-88bb990f4588.png)\n\n<a name=\"customspeedupplots\"></a>\n\n#### 4.1.9\\. Custom speedup plots\n\nFor more control over the speedup plots, it may preferable to use the data\nprovided by [speedup] and build the plots from the beginning. Continuing from\nthe previous example, the following sequence of instructions generates a\ncustomized plot showing the speedup of the sorting algorithms against\n[Bubble sort]:\n\n```matlab\n% Obtain speedup of multiple sorting algorithms against Bubble sort, no plot\ns = speedup(0, 1, 'Bubble', bs, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Generate basic speedup bar plot (first element of s cell array and rows 2 to 4,\n% to avoid displaying the speedup of Bubble sort against itself)\nh = bar(s{1}(2:4, :), 'basevalue', 1);\n\n% Customize plot\nset(h(1), 'FaceColor', [0 0 0]);\nset(h(2), 'FaceColor', [0.33 0.33 0.33]);\nset(h(3), 'FaceColor', [0.66 0.66 0.66]);\nset(h(4), 'FaceColor', [1 1 1]);\nset(gca, 'YScale', 'log');\ngrid on;\ngrid minor;\nlegend({'1 \\times 10^5', '2 \\times 10^5', '3 \\times 10^5', '4 \\times 10^5'}, 'Location', 'NorthWest');\nset(gca, 'XTickLabel', {'Selection', 'Merge', 'Quick'});\nylabel('Speedup');\n```\n\n![ex4 1 9_1](https://cloud.githubusercontent.com/assets/3018963/14691633/367ade1e-074a-11e6-9935-40f5e9f49763.png)\n\nAlthough the figure seems appropriate for publication purposes, it can be\nconverted to native LaTeX via the [matlab2tikz] script:\n\n```matlab\ncleanfigure();\nmatlab2tikz('standalone', true, 'filename', 'image.tex');\n```\n\nCompiling the `image.tex` file with a LaTeX engine yields the following figure:\n\n![ex4 1 9_2](https://cloud.githubusercontent.com/assets/3018963/14691634/3681a91a-074a-11e6-818c-498c68d2f8f0.png)\n\n<a name=\"scalabilityofthedifferentsortingalgorithmsforincreasingvectorsizes\"></a>\n\n#### 4.1.10\\. Scalability of the different sorting algorithms for increasing vector sizes\n\nContinuing from the previous example, we can use [perfstats] to determine and\nplot the scalability of the different sorting algorithms for increasing vector\nsizes:\n\n```matlab\np = perfstats(3, 'Bubble', bs, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n```\n\n![ex4 1 10](https://cloud.githubusercontent.com/assets/3018963/14692331/502d8646-074e-11e6-9cc9-fb7fe8fd9cb5.png)\n\nThe values plotted are returned in variable `p`:\n\n```\np =\n\n   36.0040  144.8210  325.1730  577.8600\n    9.5270   38.0500   88.5130  153.6560\n    0.0200    0.0410    0.0600    0.0850\n    0.0100    0.0200    0.0300    0.0510\n```\n\n<a name=\"customscalabilityplots\"></a>\n\n#### 4.1.11\\. Custom scalability plots\n\nIn a similar fashion to the speedup plots, finer control over the scalability\nplots is possible by directly using the data provided by [perfstats]. The\nfollowing sequence of instructions customizes the figure in the previous\nexample:\n\n```matlab\n% Plot data from perfstats in y-axis in log-scale\nh = semilogy(p', 'Color', 'k');\n\n% Set different markers for the various lines\nset(h(1), 'Marker', 'd', 'MarkerFaceColor', 'w');\nset(h(2), 'Marker', 'o', 'MarkerFaceColor', 'k');\nset(h(3), 'Marker', '*');\nset(h(4), 'Marker', 's', 'MarkerFaceColor', [0.8 0.8 0.8]);\n\n% Make space for legend and add legend\nylim([1e-2 3e3]);\nlegend({'Bubble', 'Selection', 'Merge', 'Quick'}, 'Location', 'NorthWest');\n\n% Set horizontal ticks\nset(gca, 'XTick', 1:4);\nset(gca, 'XTickLabel', {'1e5', '2e5', '3e5', '4e5'});\n\n% Add a grid\ngrid on;\n\n% Add x and y labels\nxlabel('Vector size');\nylabel('Time (s)');\n```\n\n![ex4 1 11_1](https://cloud.githubusercontent.com/assets/3018963/14691914/c9e8deca-074b-11e6-8386-d15ca2f5f773.png)\n\nWe can further improve the figure, and convert it to LaTeX with [matlab2tikz]:\n\n```matlab\n% Minor grids in LaTeX image are not great, so remove them\ngrid minor;\n\n% Set horizontal ticks, LaTeX-style\nset(gca, 'XTickLabel', {'$1 \\times 10^5$', '$2 \\times 10^5$', '$3 \\times 10^5$', '$4 \\times 10^5$'});\n\n% Export figure to LaTeX\ncleanfigure();\nmatlab2tikz('standalone', true, 'filename', 'image.tex');\n```\n\nCompiling the `image.tex` file with a LaTeX engine yields the following figure:\n\n![ex4 1 11_2](https://cloud.githubusercontent.com/assets/3018963/14691915/ca03003e-074b-11e6-85fd-155e7cf2314a.png)\n\n<a name=\"produceatableinsteadofaplot\"></a>\n\n#### 4.1.12\\. Produce a table instead of a plot\n\nThe [times_table] and [times_table_f] functions can be used to create\nperformance tables formatted in plain text or LaTeX. Using the data defined in\nthe previous examples, the following commands produce a plain text table\ncomparing the performance of the different sorting algorithms:\n\n```matlab\n% Put data in table format\ntdata = times_table(1, 'Bubble', bs, 'Selection', ss, 'Merge', ms, 'Quick', qs);\n\n% Print a plain text table\ntimes_table_f(0, 'vs Bubble', tdata)\n```\n\n```\n                  -----------------------------------------------\n                  |                       vs Bubble             |\n-----------------------------------------------------------------\n| Imp.   | Set.   |   t(s)     |   std     |  std%  | x Bubble  |\n-----------------------------------------------------------------\n| Bubble |    1e5 |         36 |     0.887 |   2.46 |         1 |\n|        |    2e5 |        145 |      2.92 |   2.02 |         1 |\n|        |    3e5 |        325 |      6.19 |   1.90 |         1 |\n|        |    4e5 |        578 |      6.38 |   1.10 |         1 |\n-----------------------------------------------------------------\n| Select |    1e5 |       9.53 |     0.069 |   0.72 |      3.78 |\n|        |    2e5 |         38 |     0.283 |   0.74 |      3.81 |\n|        |    3e5 |       88.5 |       3.7 |   4.18 |      3.67 |\n|        |    4e5 |        154 |      3.06 |   1.99 |      3.76 |\n-----------------------------------------------------------------\n|  Merge |    1e5 |       0.02 |  3.66e-18 |   0.00 |   1.8e+03 |\n|        |    2e5 |      0.041 |   0.00316 |   7.71 |  3.53e+03 |\n|        |    3e5 |       0.06 |  1.46e-17 |   0.00 |  5.42e+03 |\n|        |    4e5 |      0.085 |    0.0127 |  14.93 |   6.8e+03 |\n-----------------------------------------------------------------\n|  Quick |    1e5 |       0.01 |  1.83e-18 |   0.00 |   3.6e+03 |\n|        |    2e5 |       0.02 |  3.66e-18 |   0.00 |  7.24e+03 |\n|        |    3e5 |       0.03 |  7.31e-18 |   0.00 |  1.08e+04 |\n|        |    4e5 |      0.051 |   0.00316 |   6.20 |  1.13e+04 |\n-----------------------------------------------------------------\n```\n\nIn order to obtain the equivalent LaTeX table, we set the first parameter to 1\ninstead of 0:\n\n```matlab\n% Print a Latex table\ntimes_table_f(1, 'vs Bubble', tdata)\n```\n\n![ex4 1 12](https://cloud.githubusercontent.com/assets/3018963/14691916/ca160698-074b-11e6-9598-9bd2ce6f6a7e.png)\n\n<a name=\"exsimmods\"></a>\n\n<a name=\"performanceanalysisofasimulationmodel\"></a>\n\n### 4.2\\. Performance analysis of a simulation model\n\nThe examples in this section use the following [dataset][pphpc_data]:\n\n* [![DOI](https://zenodo.org/badge/doi/10.5281/zenodo.34049.svg)](http://dx.doi.org/10.5281/zenodo.34049)\n\nUnpack the [dataset][pphpc_data] to any folder and specify the complete path to\nthis folder in variable `datafolder`, e.g.:\n\n```matlab\ndatafolder = 'path/to/dataset';\n```\n\nThis [dataset][pphpc_data] corresponds to the results presented in reference\n[\\[1\\]](#ref1), which compares the performance of several implementations of the\n[PPHPC] agent-based model. Among several aspects of _PerfAndPubTools_, the\nfollowing examples show how to replicate these results.\n\n<a name=\"implementationsandsetupsofthepphpcagent-basedmodel\"></a>\n\n#### 4.2.1\\. Implementations and setups of the PPHPC agent-based model\n\nWhile most details about [PPHPC] and its various implementations are not\nimportant for this discussion, is convenient to know which implementations and\nsetups were experimented with in reference [\\[1\\]](#ref1). A total of six\nimplementations of the [PPHPC] model were compared:\n\nImplementation | Description\n---------------|------------\nNL             | [NetLogo] implementation (no parallelization).\nST             | Java single-thread implementation (no parallelization).\nEQ             | Java parallel implementation (equal work).\nEX             | Java parallel implementation (equal work, reproducible).\nER             | Java parallel implementation (row-wise synchronization).\nOD             | Java parallel implementation (on-demand work).\n\nA number of setups are directly related with the model itself, namely **model\nsize** and **parameter set**. Concerning model size, [PPHPC] was benchmarked\nwith sizes 100, 200, 400, 800 and 1600. Each size corresponds to the size of the\n*environment* in which the agents act, e.g. size 200 corresponds to a 200 x 200\nenvironment. Besides model size, [PPHPC] was also benchmarked with two parameter\nsets, simply designated as *parameter set 1* and *parameter set 2*. The latter\ntypically yields simulations with more agents.\n\nOther setups are associated with computational aspects of model execution, more\nspecifically **number of threads** (for parallel implementations) and \n**value of the _b_ parameter** (for OD implementation only).\n\nThe [dataset][pphpc_data] contains performance data (in the form of [GNU time]\ndefault output) for 10 runs of all setup combinations (i.e. model size,\nparameter set, number of threads and value of the _b_ parameter, where\napplicable).\n\n<a name=\"extractperformancedatafromafile-1\"></a>\n\n#### 4.2.2\\. Extract performance data from a file\n\nThe [get_gtime] function extracts performance data from one file containing the\ndefault output of [GNU time] command. For example:\n\n```matlab\np = get_gtime([datafolder '/times/NL/time100v1r1.txt'])\n```\n\nThe function returns a structure with several fields:\n\n```\np = \n\n       user: 17.6800\n        sys: 0.3200\n    elapsed: 16.5900\n        cpu: 108\n```\n\n<a name=\"extractexecutiontimesfromfilesinafolder-1\"></a>\n\n#### 4.2.3\\. Extract execution times from files in a folder\n\nThe [gather_times] function extracts execution times from multiple files in a\nfolder, as shown in the following command:\n\n```matlab\nexec_time = gather_times('NetLogo', [datafolder '/times/NL'], 'time100v1*.txt');\n```\n\nThe vector of execution times is in the `elapsed` field of the returned\nstructure:\n\n```matlab\nexec_time.elapsed\n```\n\nThe [gather_times] function uses [get_gtime] internally by default. However, \nother functions can be specified in the first line of the [gather_times]\nfunction body, allowing _PerfAndPubTools_ to support benchmarking formats other\nthan the output of [GNU time]. Alternatives to [get_gtime] are only required to\nreturn a struct with the `elapsed` field, indicating the duration (in seconds)\nof a program execution.\n\n<a name=\"averageexecutiontimesandstandarddeviations-1\"></a>\n\n#### 4.2.4\\. Average execution times and standard deviations\n\nIn its most basic usage, the [perfstats] function obtains performance\nstatistics. In this example, average execution times and standard deviations are\nobtained from 10 replications of the Java single-threaded (ST) implementation of\n[PPHPC] for size 800, parameter set 2:\n\n```matlab\nst800v2 = struct('sname', '800v1', 'folder', [datafolder '/times/ST'], 'files', 't*800v2*.txt');\n[avg_time, std_time] = perfstats(0, 'ST', {st800v2})\n```\n\n```\navg_time =\n\n  699.5920\n\n\nstd_time =\n\n    3.6676\n```\n\nThe [perfstats] function uses [gather_times] internally.\n\n<a name=\"comparemultiplesetupswithinthesameimplementation-1\"></a>\n\n#### 4.2.5\\. Compare multiple setups within the same implementation\n\nA more advanced use case for [perfstats] consists of comparing multiple setups,\nassociated with different computational sizes, within the same implementation.\nFor example, considering the Java ST implementation of the [PPHPC] model, the\nfollowing instructions analyze how its performance varies for increasing model\nsizes:\n\n```matlab\n% Specify implementations specs for each model size\nst100v2 = struct('sname', '100v2', 'folder', [datafolder '/times/ST'], 'files', 't*100v2*.txt');\nst200v2 = struct('sname', '200v2', 'folder', [datafolder '/times/ST'], 'files', 't*200v2*.txt');\nst400v2 = struct('sname', '400v2', 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst800v2 = struct('sname', '800v2', 'folder', [datafolder '/times/ST'], 'files', 't*800v2*.txt');\nst1600v2 = struct('sname', '1600v2', 'folder', [datafolder '/times/ST'], 'files', 't*1600v2*.txt');\n\n% Obtain the average time for increasing model sizes\navg_time = perfstats(0, 'ST', {st100v2, st200v2, st400v2, st800v2, st1600v2})\n```\n\n```\navg_time =\n\n   1.0e+03 *\n\n    0.0053    0.0361    0.1589    0.6996    2.9572\n```\n\n<a name=\"sameaspreviouswithalog-logplot\"></a>\n\n#### 4.2.6\\. Same as previous, with a log-log plot\n\nThe [perfstats] function can also be used to generate scalability plots. For\nthis purpose, the computational size, `csize`, must be specified in each\nsetup, and the first parameter of [perfstats] should be a value between 1\n(linear plot) and 4 (log-log plot), as shown in the following code snippet:\n\n```matlab\n% Specify implementations specs for each model size, indicating the csize key\nst100v2 = struct('sname', '100v2', 'csize', 100, 'folder', [datafolder '/times/ST'], 'files', 't*100v2*.txt');\nst200v2 = struct('sname', '200v2', 'csize', 200, 'folder', [datafolder '/times/ST'], 'files', 't*200v2*.txt');\nst400v2 = struct('sname', '400v2', 'csize', 400, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst800v2 = struct('sname', '800v2', 'csize', 800, 'folder', [datafolder '/times/ST'], 'files', 't*800v2*.txt');\nst1600v2 = struct('sname', '1600v2', 'csize', 1600, 'folder', [datafolder '/times/ST'], 'files', 't*1600v2*.txt');\n\n% The first parameter defines the plot type: 4 is a log-log plot\nperfstats(4, 'ST', {st100v2, st200v2, st400v2, st800v2, st1600v2});\n```\n\n![ex4 2 6_1](https://cloud.githubusercontent.com/assets/3018963/14692567/fc5a2004-074f-11e6-91d1-e82b5260f74c.png)\n\nError bars showing the standard deviation can be requested by passing a negative\nvalue as the first parameter to [perfstats]:\n\n```matlab\n% The value -4 indicates a log-log plot with error bars\nperfstats(-4, 'ST', {st100v2, st200v2, st400v2, st800v2, st1600v2});\n```\n\n![ex4 2 6_2](https://cloud.githubusercontent.com/assets/3018963/14692568/fc5e537c-074f-11e6-81df-aecfda2c2618.png)\n\nDue to the run time variability being very low, the error bars are not very\nuseful in this case.\n\n<a name=\"pphpccompdiffimpl\"></a>\n\n<a name=\"comparedifferentimplementations-1\"></a>\n\n#### 4.2.7\\. Compare different implementations\n\nBesides comparing multiple setups within the same implementation, the\n[perfstats] function is also able to compare multiple setups from a number\nimplementations. The requirement is that, from implementation to implementation,\nthe multiple setups are directly comparable, i.e., corresponding implementation\nspecs should have the same `sname` and `csize` parameters, as shown in the\nfollowing commands, where the [NetLogo] \\(NL\\) and Java single-thread (ST)\n[PPHPC] implementations are compared for sizes 100 to 1600, parameter set 1:\n\n```matlab\n% Specify NetLogo implementation specs\nnl100v1 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/NL'], 'files', 't*100v1*.txt');\nnl200v1 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/NL'], 'files', 't*200v1*.txt');\nnl400v1 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/NL'], 'files', 't*400v1*.txt');\nnl800v1 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/NL'], 'files', 't*800v1*.txt');\nnl1600v1 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/NL'], 'files', 't*1600v1*.txt');\nnlv1 = {nl100v1, nl200v1, nl400v1, nl800v1, nl1600v1};\n\n% Specify Java ST implementation specs\nst100v1 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/ST'], 'files', 't*100v1*.txt');\nst200v1 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/ST'], 'files', 't*200v1*.txt');\nst400v1 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/ST'], 'files', 't*400v1*.txt');\nst800v1 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/ST'], 'files', 't*800v1*.txt');\nst1600v1 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/ST'], 'files', 't*1600v1*.txt');\nstv1 = {st100v1, st200v1, st400v1, st800v1, st1600v1};\n\n% Plot comparison\nperfstats(4, 'NL', nlv1, 'ST', stv1);\n```\n\n![ex4 2 7](https://cloud.githubusercontent.com/assets/3018963/14692605/3660f0a2-0750-11e6-9d5d-375a1b5777fe.png)\n\n<a name=\"speedup-1\"></a>\n\n#### 4.2.8\\. Speedup\n\nThe [speedup] function is used to obtain relative speedups between different\nimplementations. Using the variables defined in the previous example, the\naverage, maximum and minimum speedups of the Java ST version over the [NetLogo]\nimplementation for different model sizes can be obtained with the following\ninstruction:\n\n```matlab\n[s_avg, s_max, s_min] = speedup(0, 1, 'NL', nlv1, 'ST', stv1);\n```\n\nThe first element of the returned cell, i.e. `s_avg{1}`, contains the speedups:\n\n```\nans =\n\n    1.0000    1.0000    1.0000    1.0000    1.0000\n    5.8513    8.2370    5.7070    5.4285    5.4331\n```\n\nThe second parameter of the [speedup] function indicates the reference\nimplementation from which to calculate speedups. In this case, specifying 1 will\nreturn speedups against the [NetLogo] implementation. The first row of the\nmatrix in `s_avg{1}` shows the speedup of the [NetLogo] implementation against\nitself, thus it is composed of ones. The second row shows the speedup of the\nJava ST implementation versus the [NetLogo] implementation. If the second\nparameter of the [speedup] function is a vector, speedups against more than one\nimplementation are returned in `s_avg`, `s_max` and `s_min`.\n\nSetting the first parameter of [speedup] to 1 will yield a bar plot displaying the\nrelative speedups:\n\n```matlab\nspeedup(1, 1, 'NL', nlv1, 'ST', stv1);\n```\n\n![ex4 2 8_1](https://cloud.githubusercontent.com/assets/3018963/14692693/e6b122ce-0750-11e6-973d-1742d81974ed.png)\n\nError bars representing the maximum and minimum speedups can be requested by\npassing a negative value as the first parameter:\n\n```matlab\nspeedup(-1, 1, 'NL', nlv1, 'ST', stv1);\n```\n\n![ex4 2 8_2](https://cloud.githubusercontent.com/assets/3018963/14715792/2214f98a-07e2-11e6-807f-cd37b88533d8.png)\n\n<a name=\"speedupformultipleparallelimplementationsandsizes\"></a>\n\n#### 4.2.9\\. Speedup for multiple parallel implementations and sizes\n\nThe [speedup] function is also able to determine speedups between different\nimplementations for multiple computational sizes. In this example we plot the\nspeedup of several [PPHPC] parallel Java implementations against the [NetLogo]\nand Java single-thread implementations for multiple sizes. This example uses the\n`nlv1` and `stv1` variables defined in a [previous example](#pphpccompdiffimpl),\nand the plotted results are equivalent to figures 4a and 4b of reference\n[\\[1\\]](#ref1):\n\n```matlab\n% Specify Java EQ implementation specs (runs with 12 threads)\neq100v1t12 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/EQ'], 'files', 't*100v1*t12r*.txt');\neq200v1t12 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/EQ'], 'files', 't*200v1*t12r*.txt');\neq400v1t12 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/EQ'], 'files', 't*400v1*t12r*.txt');\neq800v1t12 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/EQ'], 'files', 't*800v1*t12r*.txt');\neq1600v1t12 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/EQ'], 'files', 't*1600v1*t12r*.txt');\neqv1t12 = {eq100v1t12, eq200v1t12, eq400v1t12, eq800v1t12, eq1600v1t12};\n\n% Specify Java EX implementation specs (runs with 12 threads)\nex100v1t12 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/EX'], 'files', 't*100v1*t12r*.txt');\nex200v1t12 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/EX'], 'files', 't*200v1*t12r*.txt');\nex400v1t12 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/EX'], 'files', 't*400v1*t12r*.txt');\nex800v1t12 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/EX'], 'files', 't*800v1*t12r*.txt');\nex1600v1t12 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/EX'], 'files', 't*1600v1*t12r*.txt');\nexv1t12 = {ex100v1t12, ex200v1t12, ex400v1t12, ex800v1t12, ex1600v1t12};\n\n% Specify Java ER implementation specs (runs with 12 threads)\ner100v1t12 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/ER'], 'files', 't*100v1*t12r*.txt');\ner200v1t12 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/ER'], 'files', 't*200v1*t12r*.txt');\ner400v1t12 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/ER'], 'files', 't*400v1*t12r*.txt');\ner800v1t12 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/ER'], 'files', 't*800v1*t12r*.txt');\ner1600v1t12 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/ER'], 'files', 't*1600v1*t12r*.txt');\nerv1t12 = {er100v1t12, er200v1t12, er400v1t12, er800v1t12, er1600v1t12};\n\n% Specify Java OD implementation specs (runs with 12 threads, b = 500)\nod100v1t12 = struct('sname', '100v1', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*100v1*b500t12r*.txt');\nod200v1t12 = struct('sname', '200v1', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*200v1*b500t12r*.txt');\nod400v1t12 = struct('sname', '400v1', 'csize', 400, 'folder', [datafolder '/times/OD'], 'files', 't*400v1*b500t12r*.txt');\nod800v1t12 = struct('sname', '800v1', 'csize', 800, 'folder', [datafolder '/times/OD'], 'files', 't*800v1*b500t12r*.txt');\nod1600v1t12 = struct('sname', '1600v1', 'csize', 1600, 'folder', [datafolder '/times/OD'], 'files', 't*1600v1*b500t12r*.txt');\nodv1t12 = {od100v1t12, od200v1t12, od400v1t12, od800v1t12, od1600v1t12};\n\n% Plot speedup of multiple parallel implementations against NetLogo implementation\n% This plot is figure 4a of reference [1]\nspeedup(1, 1, 'NL', nlv1, 'ST', stv1, 'EQ', eqv1t12, 'EX', exv1t12, 'ER', erv1t12, 'OD', odv1t12);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthWest');\n```\n\n![ex4 2 9_1](https://cloud.githubusercontent.com/assets/3018963/14706004/308d5576-07b4-11e6-8509-506cb4af5733.png)\n\n```matlab\n% Plot speedup of multiple parallel implementations against Java ST implementation\n% This plot is figure 4b of reference [1]\nspeedup(1, 1, 'ST', stv1, 'EQ', eqv1t12, 'EX', exv1t12, 'ER', erv1t12, 'OD', odv1t12);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthOutside', 'Orientation', 'horizontal');\n```\n\n![ex4 2 9_2](https://cloud.githubusercontent.com/assets/3018963/14706005/30a50b30-07b4-11e6-963c-1b20102b1cbb.png)\n\n<a name=\"scalabilityofthedifferentimplementationsforincreasingmodelsizes\"></a>\n\n#### 4.2.10\\. Scalability of the different implementations for increasing model sizes\n\nIn a slightly more complex scenario than the one described in a\n[previous example](#pphpccompdiffimpl), here we use the [perfstats] function to\nplot the scalability of the different [PPHPC] implementations for increasing\nmodel sizes. Using the variables defined in the previous examples, the following\ncommand generates the equivalent to figure 5a of reference [\\[1\\]](#ref1):\n\n```matlab\nperfstats(4, 'NL', nlv1, 'ST', stv1, 'EQ', eqv1t12, 'EX', exv1t12, 'ER', erv1t12, 'OD', odv1t12);\n```\n\n![ex4 2 10](https://cloud.githubusercontent.com/assets/3018963/14692845/fdb21130-0751-11e6-9e75-428f92e3b59b.png)\n\n<a name=\"scalabilityofparallelimplementationsforincreasingnumberofthreads\"></a>\n\n#### 4.2.11\\. Scalability of parallel implementations for increasing number of threads\n\nThe 'computational size', i.e. the `csize` field, defined in the implementation\nspecs passed to the [perfstats] function can be used in alternative contexts. In\nthis example, we use the `csize` field to specify the number of threads used to\nperform a set of simulation runs or replications. The following commands\nwill plot the scalability of the several [PPHPC] parallel implementations for an\nincreasing number of threads. The plotted results are equivalent to figure 6d of\nreference [\\[1\\]](#ref1):\n\n```matlab\n% Specify ST implementation specs, note that the data is always the same\n% so in practice the scalability will be constant for ST. However, this is a\n% nice trick to have a comparison standard in the plot.\nst400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nstv2 = {st400v2t1, st400v2t2, st400v2t4, st400v2t6, st400v2t8, st400v2t12, st400v2t16, st400v2t24};\n\n% Specify the EQ implementation specs for increasing number of threads\neq400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t1r*.txt');\neq400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t2r*.txt');\neq400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t4r*.txt');\neq400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t6r*.txt');\neq400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t8r*.txt');\neq400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t12r*.txt');\neq400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t16r*.txt');\neq400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t24r*.txt');\neqv2 = {eq400v2t1, eq400v2t2, eq400v2t4, eq400v2t6, eq400v2t8, eq400v2t12, eq400v2t16, eq400v2t24};\n\n% Specify the EX implementation specs for increasing number of threads\nex400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t1r*.txt');\nex400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t2r*.txt');\nex400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t4r*.txt');\nex400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t6r*.txt');\nex400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t8r*.txt');\nex400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t12r*.txt');\nex400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t16r*.txt');\nex400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t24r*.txt');\nexv2 = {ex400v2t1, ex400v2t2, ex400v2t4, ex400v2t6, ex400v2t8, ex400v2t12, ex400v2t16, ex400v2t24};\n\n% Specify the ER implementation specs for increasing number of threads\ner400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t1r*.txt');\ner400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t2r*.txt');\ner400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t4r*.txt');\ner400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t6r*.txt');\ner400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t8r*.txt');\ner400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t12r*.txt');\ner400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t16r*.txt');\ner400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t24r*.txt');\nerv2 = {er400v2t1, er400v2t2, er400v2t4, er400v2t6, er400v2t8, er400v2t12, er400v2t16, er400v2t24};\n\n% Specify the OD implementation specs for increasing number of threads (b = 500)\nod400v2t1 = struct('sname', '400v2', 'csize', 1, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t1r*.txt');\nod400v2t2 = struct('sname', '400v2', 'csize', 2, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t2r*.txt');\nod400v2t4 = struct('sname', '400v2', 'csize', 4, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t4r*.txt');\nod400v2t6 = struct('sname', '400v2', 'csize', 6, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t6r*.txt');\nod400v2t8 = struct('sname', '400v2', 'csize', 8, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t8r*.txt');\nod400v2t12 = struct('sname', '400v2', 'csize', 12, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t12r*.txt');\nod400v2t16 = struct('sname', '400v2', 'csize', 16, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t16r*.txt');\nod400v2t24 = struct('sname', '400v2', 'csize', 24, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t24r*.txt');\nodv2 = {od400v2t1, od400v2t2, od400v2t4, od400v2t6, od400v2t8, od400v2t12, od400v2t16, od400v2t24};\n\n% Use a linear plot (first parameter = 1)\nperfstats(1, 'ST', stv2, 'EQ', eqv2, 'EX', exv2, 'ER', erv2, 'OD', odv2);\n\n% Move legend to a better position\nlegend(gca, 'Location', 'northeast');\n```\n\n![ex4 2 11](https://cloud.githubusercontent.com/assets/3018963/14692932/aba1f486-0752-11e6-8dd9-b5d673dc50ce.png)\n\n<a name=\"performanceofodstrategyfordifferentvaluesof_b_\"></a>\n\n#### 4.2.12\\. Performance of OD strategy for different values of _b_\n\nFor this example, in yet another possible use of the [perfstats] function,  we\nuse the `csize` field to specify the value of the _b_ parameter of the [PPHPC]\nmodel Java OD variant. This allows us to analyze the performance of the OD\nparallelization strategy for different values of _b_. The plot created by the\nfollowing commands is equivalent to figure 7b of reference [\\[1\\]](#ref1):\n\n```matlab\n% Specify the OD implementation specs for size 100 and increasing values of b\nod100v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b20t12r*.txt');\nod100v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b50t12r*.txt');\nod100v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b100t12r*.txt');\nod100v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b200t12r*.txt');\nod100v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b500t12r*.txt');\nod100v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b1000t12r*.txt');\nod100v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b2000t12r*.txt');\nod100v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b5000t12r*.txt');\nod100v2 = {od100v2b20, od100v2b50, od100v2b100, od100v2b200, od100v2b500, od100v2b1000, od100v2b2000, od100v2b5000};\n\n% Specify the OD implementation specs for size 200 and increasing values of b\nod200v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b20t12r*.txt');\nod200v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b50t12r*.txt');\nod200v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b100t12r*.txt');\nod200v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b200t12r*.txt');\nod200v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b500t12r*.txt');\nod200v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b1000t12r*.txt');\nod200v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b2000t12r*.txt');\nod200v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b5000t12r*.txt');\nod200v2 = {od200v2b20, od200v2b50, od200v2b100, od200v2b200, od200v2b500, od200v2b1000, od200v2b2000, od200v2b5000};\n\n% Specify the OD implementation specs for size 400 and increasing values of b\nod400v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b20t12r*.txt');\nod400v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b50t12r*.txt');\nod400v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b100t12r*.txt');\nod400v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b200t12r*.txt');\nod400v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t12r*.txt');\nod400v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b1000t12r*.txt');\nod400v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b2000t12r*.txt');\nod400v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b5000t12r*.txt');\nod400v2 = {od400v2b20, od400v2b50, od400v2b100, od400v2b200, od400v2b500, od400v2b1000, od400v2b2000, od400v2b5000};\n\n% Specify the OD implementation specs for size 800 and increasing values of b\nod800v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b20t12r*.txt');\nod800v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b50t12r*.txt');\nod800v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b100t12r*.txt');\nod800v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b200t12r*.txt');\nod800v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b500t12r*.txt');\nod800v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b1000t12r*.txt');\nod800v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b2000t12r*.txt');\nod800v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b5000t12r*.txt');\nod800v2 = {od800v2b20, od800v2b50, od800v2b100, od800v2b200, od800v2b500, od800v2b1000, od800v2b2000, od800v2b5000};\n\n% Specify the OD implementation specs for size 1600 and increasing values of b\nod1600v2b20 = struct('sname', 'b=20', 'csize', 20, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b20t12r*.txt');\nod1600v2b50 = struct('sname', 'b=50', 'csize', 50, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b50t12r*.txt');\nod1600v2b100 = struct('sname', 'b=100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b100t12r*.txt');\nod1600v2b200 = struct('sname', 'b=200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b200t12r*.txt');\nod1600v2b500 = struct('sname', 'b=500', 'csize', 500, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b500t12r*.txt');\nod1600v2b1000 = struct('sname', 'b=1000', 'csize', 1000, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b1000t12r*.txt');\nod1600v2b2000 = struct('sname', 'b=2000', 'csize', 2000, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b2000t12r*.txt');\nod1600v2b5000 = struct('sname', 'b=5000', 'csize', 5000, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b5000t12r*.txt');\nod1600v2 = {od1600v2b20, od1600v2b50, od1600v2b100, od1600v2b200, od1600v2b500, od1600v2b1000, od1600v2b2000, od1600v2b5000};\n\n% Show plot\nperfstats(4, '100', od100v2, '200', od200v2, '400', od400v2, '800', od800v2, '1600', od1600v2);\n\n% Place legend in a better position\nlegend(gca, 'Location', 'NorthOutside', 'Orientation', 'horizontal')\n```\n\n![ex4 2 12](https://cloud.githubusercontent.com/assets/3018963/14693011/49f6088e-0753-11e6-974b-f920b8bb4167.png)\n\n<a name=\"customperformanceplot\"></a>\n\n#### 4.2.13\\. Custom performance plot\n\nAs previously discussed, it is possible to generate custom plots using the data\nreturned by [perfstats] and [speedup]. The following code snippet produces a\ncustomized version of the plot generated in the previous example. The resulting\nimage is a publication quality equivalent of figure 7b in reference\n[\\[1\\]](#ref1):\n\n```matlab\n% Get data from perfstats function\np = perfstats(0, '100', od100v2, '200', od200v2, '400', od400v2, '800', od800v2, '1600', od1600v2);\n\n% Values of the b parameter\nbvals = [20 50 100 200 500 1000 2000 5000];\n\n% Generate basic plot with black lines\nh = loglog(bvals, p', 'k');\nset(gca, 'XTick', bvals);\n\n% Set marker styles\nset(h(1), 'Marker', 'o', 'MarkerFaceColor', [0.7 0.7 0.7]);\nset(h(2), 'Marker', 's', 'MarkerFaceColor', [0.7 0.7 0.7]);\nset(h(3), 'Marker', 'o', 'MarkerFaceColor', 'w');\nset(h(4), 'Marker', '^', 'MarkerFaceColor', 'k');\nset(h(5), 'Marker', 'd', 'MarkerFaceColor', [0.7 0.7 0.7]);\n\n% Draw bold circles indicating best times for each size/b combination\ngrid on;\nhold on;\n[my, mi] = min(p, [], 2);\nplot(bvals(mi), my, 'ok', 'MarkerSize', 10, 'LineWidth', 2);\n\n% Set limits and add labels\nxlim([min(bvals) max(bvals)]);\nxlabel('Block size, {\\itb}');\nylabel('Time ({\\its})');\n\n% Set legend\nlegend({'100', '200', '400', '800', '1600'}, 'Location', 'NorthOutside', 'Orientation', 'horizontal');\n```\n\n![ex4 2 13_1](https://cloud.githubusercontent.com/assets/3018963/14706270/8e7c0e9c-07b5-11e6-8fe8-cbd24c184cec.png)\n\nAlthough the figure looks appropriate for publication purposes, it can still be\nimproved by converting it to native LaTeX via the [matlab2tikz] script:\n\n```matlab\n% Small adjustments so that figure looks better when converted\ngrid minor;\nset(gca, 'XTickLabel', bvals);\n\n% Convert figure to LaTeX\ncleanfigure();\nmatlab2tikz('standalone', true, 'filename', 'image.tex');\n```\n\nCompiling the `image.tex` file with a LaTeX engine yields the following figure:\n\n![ex4 2 13_2](https://cloud.githubusercontent.com/assets/3018963/14706271/8e7c4fce-07b5-11e6-8ed5-09853541b4a4.png)\n\n<a name=\"showatableinsteadofaplot\"></a>\n\n#### 4.2.14\\. Show a table instead of a plot\n\nThe [times_table] and [times_table_f] functions can be used to create\nperformance tables formatted in plain text or LaTeX. Using the data defined in a\n[previous example](#pphpccompdiffimpl), the following commands produce a plain\ntext table comparing the [NetLogo] \\(NL\\) and Java single-thread (ST) [PPHPC]\nimplementations for sizes 100 to 1600, parameter set 1:\n\n```matlab\n% Put data in table format\ntdata = times_table(1, 'NL', nlv1, 'ST', stv1);\n\n% Print a plain text table\ntimes_table_f(0, 'NL vs ST', tdata)\n```\n\n```\n                  -----------------------------------------------\n                  |                        NL vs ST             |\n-----------------------------------------------------------------\n| Imp.   | Set.   |   t(s)     |   std     |  std%  | x     NL  |\n-----------------------------------------------------------------\n|     NL |  100v1 |       15.9 |     0.359 |   2.26 |         1 |\n|        |  200v1 |        100 |      1.25 |   1.25 |         1 |\n|        |  400v1 |        481 |      6.02 |   1.25 |         1 |\n|        |  800v1 |   2.08e+03 |      9.75 |   0.47 |         1 |\n|        | 1600v1 |   9.12e+03 |      94.1 |   1.03 |         1 |\n-----------------------------------------------------------------\n|     ST |  100v1 |       2.71 |    0.0223 |   0.82 |      5.85 |\n|        |  200v1 |       12.2 |     0.219 |   1.80 |      8.24 |\n|        |  400v1 |       84.4 |      2.83 |   3.35 |      5.71 |\n|        |  800v1 |        383 |      5.04 |   1.32 |      5.43 |\n|        | 1600v1 |   1.68e+03 |      78.4 |   4.67 |      5.43 |\n-----------------------------------------------------------------\n```\n\nIn order to produce the equivalent LaTeX table, we set the first parameter to 1\ninstead of 0:\n\n```matlab\n% Print a Latex table\ntimes_table_f(1, 'NL vs ST', tdata)\n```\n\n![ex4 2 14](https://cloud.githubusercontent.com/assets/3018963/14706361/f6f1c8cc-07b5-11e6-9c7d-87af968ac115.png)\n\n<a name=\"complextables\"></a>\n\n#### 4.2.15\\. Complex tables\n\nThe [times_table] and [times_table_f] functions are capable of producing more\ncomplex tables. In this example, we show how to reproduce table 7 of reference\n[\\[1\\]](#ref1), containing times and speedups for multiple model\nimplementations, different sizes and both parameter sets, showing speedups of\nall implementations versus the [NetLogo] and Java ST versions.\n\nThe first step consists of defining the implementation specs:\n\n```matlab\n% %%%%%%%%%%%%%%%%%%%%%%%%% %\n% Specs for parameter set 1 %\n% %%%%%%%%%%%%%%%%%%%%%%%%% %\n\n% Define NetLogo implementation specs, parameter set 1\nnl100v1 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/NL'], 'files', 't*100v1*.txt');\nnl200v1 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/NL'], 'files', 't*200v1*.txt');\nnl400v1 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/NL'], 'files', 't*400v1*.txt');\nnl800v1 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/NL'], 'files', 't*800v1*.txt');\nnl1600v1 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/NL'], 'files', 't*1600v1*.txt');\nnlv1 = {nl100v1, nl200v1, nl400v1, nl800v1, nl1600v1};\n\n% Define Java ST implementation specs, parameter set 1\nst100v1 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/ST'], 'files', 't*100v1*.txt');\nst200v1 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/ST'], 'files', 't*200v1*.txt');\nst400v1 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/ST'], 'files', 't*400v1*.txt');\nst800v1 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/ST'], 'files', 't*800v1*.txt');\nst1600v1 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/ST'], 'files', 't*1600v1*.txt');\nstv1 = {st100v1, st200v1, st400v1, st800v1, st1600v1};\n\n% Define Java EQ implementation specs (runs with 12 threads), parameter set 1\neq100v1t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/EQ'], 'files', 't*100v1*t12r*.txt');\neq200v1t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/EQ'], 'files', 't*200v1*t12r*.txt');\neq400v1t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/EQ'], 'files', 't*400v1*t12r*.txt');\neq800v1t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/EQ'], 'files', 't*800v1*t12r*.txt');\neq1600v1t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/EQ'], 'files', 't*1600v1*t12r*.txt');\neqv1t12 = {eq100v1t12, eq200v1t12, eq400v1t12, eq800v1t12, eq1600v1t12};\n\n% Define Java EX implementation specs (runs with 12 threads), parameter set 1\nex100v1t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/EX'], 'files', 't*100v1*t12r*.txt');\nex200v1t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/EX'], 'files', 't*200v1*t12r*.txt');\nex400v1t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/EX'], 'files', 't*400v1*t12r*.txt');\nex800v1t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/EX'], 'files', 't*800v1*t12r*.txt');\nex1600v1t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/EX'], 'files', 't*1600v1*t12r*.txt');\nexv1t12 = {ex100v1t12, ex200v1t12, ex400v1t12, ex800v1t12, ex1600v1t12};\n\n% Define Java ER implementation specs (runs with 12 threads), parameter set 1\ner100v1t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/ER'], 'files', 't*100v1*t12r*.txt');\ner200v1t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/ER'], 'files', 't*200v1*t12r*.txt');\ner400v1t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/ER'], 'files', 't*400v1*t12r*.txt');\ner800v1t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/ER'], 'files', 't*800v1*t12r*.txt');\ner1600v1t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/ER'], 'files', 't*1600v1*t12r*.txt');\nerv1t12 = {er100v1t12, er200v1t12, er400v1t12, er800v1t12, er1600v1t12};\n\n% Define Java OD implementation specs (runs with 12 threads, b = 500), parameter set 1\nod100v1t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*100v1*b500t12r*.txt');\nod200v1t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*200v1*b500t12r*.txt');\nod400v1t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/OD'], 'files', 't*400v1*b500t12r*.txt');\nod800v1t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/OD'], 'files', 't*800v1*b500t12r*.txt');\nod1600v1t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/OD'], 'files', 't*1600v1*b500t12r*.txt');\nodv1t12 = {od100v1t12, od200v1t12, od400v1t12, od800v1t12, od1600v1t12};\n\n% %%%%%%%%%%%%%%%%%%%%%%%%% %\n% Specs for parameter set 2 %\n% %%%%%%%%%%%%%%%%%%%%%%%%% %\n\n% Define NetLogo implementation specs, parameter set 2\nnl100v2 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/NL'], 'files', 't*100v2*.txt');\nnl200v2 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/NL'], 'files', 't*200v2*.txt');\nnl400v2 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/NL'], 'files', 't*400v2*.txt');\nnl800v2 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/NL'], 'files', 't*800v2*.txt');\nnl1600v2 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/NL'], 'files', 't*1600v2*.txt');\nnlv2 = {nl100v2, nl200v2, nl400v2, nl800v2, nl1600v2};\n\n% Define Java ST implementation specs, parameter set 2\nst100v2 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/ST'], 'files', 't*100v2*.txt');\nst200v2 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/ST'], 'files', 't*200v2*.txt');\nst400v2 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/ST'], 'files', 't*400v2*.txt');\nst800v2 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/ST'], 'files', 't*800v2*.txt');\nst1600v2 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/ST'], 'files', 't*1600v2*.txt');\nstv2 = {st100v2, st200v2, st400v2, st800v2, st1600v2};\n\n% Define Java EQ implementation specs (runs with 12 threads), parameter set 2\neq100v2t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/EQ'], 'files', 't*100v2*t12r*.txt');\neq200v2t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/EQ'], 'files', 't*200v2*t12r*.txt');\neq400v2t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/EQ'], 'files', 't*400v2*t12r*.txt');\neq800v2t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/EQ'], 'files', 't*800v2*t12r*.txt');\neq1600v2t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/EQ'], 'files', 't*1600v2*t12r*.txt');\neqv2t12 = {eq100v2t12, eq200v2t12, eq400v2t12, eq800v2t12, eq1600v2t12};\n\n% Define Java EX implementation specs (runs with 12 threads), parameter set 2\nex100v2t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/EX'], 'files', 't*100v2*t12r*.txt');\nex200v2t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/EX'], 'files', 't*200v2*t12r*.txt');\nex400v2t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/EX'], 'files', 't*400v2*t12r*.txt');\nex800v2t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/EX'], 'files', 't*800v2*t12r*.txt');\nex1600v2t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/EX'], 'files', 't*1600v2*t12r*.txt');\nexv2t12 = {ex100v2t12, ex200v2t12, ex400v2t12, ex800v2t12, ex1600v2t12};\n\n% Define Java ER implementation specs (runs with 12 threads), parameter set 2\ner100v2t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/ER'], 'files', 't*100v2*t12r*.txt');\ner200v2t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/ER'], 'files', 't*200v2*t12r*.txt');\ner400v2t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/ER'], 'files', 't*400v2*t12r*.txt');\ner800v2t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/ER'], 'files', 't*800v2*t12r*.txt');\ner1600v2t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/ER'], 'files', 't*1600v2*t12r*.txt');\nerv2t12 = {er100v2t12, er200v2t12, er400v2t12, er800v2t12, er1600v2t12};\n\n% Define Java OD implementation specs (runs with 12 threads, b = 500), parameter set 2\nod100v2t12 = struct('sname', '100', 'csize', 100, 'folder', [datafolder '/times/OD'], 'files', 't*100v2*b500t12r*.txt');\nod200v2t12 = struct('sname', '200', 'csize', 200, 'folder', [datafolder '/times/OD'], 'files', 't*200v2*b500t12r*.txt');\nod400v2t12 = struct('sname', '400', 'csize', 400, 'folder', [datafolder '/times/OD'], 'files', 't*400v2*b500t12r*.txt');\nod800v2t12 = struct('sname', '800', 'csize', 800, 'folder', [datafolder '/times/OD'], 'files', 't*800v2*b500t12r*.txt');\nod1600v2t12 = struct('sname', '1600', 'csize', 1600, 'folder', [datafolder '/times/OD'], 'files', 't*1600v2*b500t12r*.txt');\nodv2t12 = {od100v2t12, od200v2t12, od400v2t12, od800v2t12, od1600v2t12};\n```\n\nAfter the implementation specs are defined, we create two intermediate tables:\n\n```matlab\n% %%%%%%%%%%%%%%%%%%% %\n% Intermediate tables %\n% %%%%%%%%%%%%%%%%%%% %\n\n% Parameter set 1\ndata_v1 = times_table([1 2], 'NL', nlv1, 'ST', stv1, 'EQ', eqv1t12, 'EX', exv1t12, 'ER', erv1t12, 'OD', odv1t12);\n\n% Parameter set 2\ndata_v2 = times_table([1 2], 'NL', nlv2, 'ST', stv2, 'EQ', eqv2t12, 'EX', exv2t12, 'ER', erv2t12, 'OD', odv2t12);\n```\n\nWe first print a plain text table, to check how the information is organized:\n\n```matlab\n% %%%%%%%%%%%% %\n% Print tables %\n% %%%%%%%%%%%% %\n\n% Plain text table\ntimes_table_f(0, 'Param. set 1', data_v1, 'Param. set 2', data_v2)\n```\n\n```\n                  ---------------------------------------------------------------------------------------------------------------------\n                  |                    Param. set 1                         |                    Param. set 2                         |\n---------------------------------------------------------------------------------------------------------------------------------------\n| Imp.   | Set.   |   t(s)     |   std     |  std%  | x     NL  | x     ST  |   t(s)     |   std     |  std%  | x     NL  | x     ST  |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     NL |    100 |       15.9 |     0.359 |   2.26 |         1 |     0.171 |       32.2 |     0.686 |   2.13 |         1 |     0.166 |\n|        |    200 |        100 |      1.25 |   1.25 |         1 |     0.121 |        245 |       1.5 |   0.61 |         1 |     0.147 |\n|        |    400 |        481 |      6.02 |   1.25 |         1 |     0.175 |   1.07e+03 |      3.63 |   0.34 |         1 |     0.148 |\n|        |    800 |   2.08e+03 |      9.75 |   0.47 |         1 |     0.184 |   4.54e+03 |      23.2 |   0.51 |         1 |     0.154 |\n|        |   1600 |   9.12e+03 |      94.1 |   1.03 |         1 |     0.184 |   1.96e+04 |      90.9 |   0.46 |         1 |     0.151 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     ST |    100 |       2.71 |    0.0223 |   0.82 |      5.85 |         1 |       5.34 |     0.051 |   0.96 |      6.03 |         1 |\n|        |    200 |       12.2 |     0.219 |   1.80 |      8.24 |         1 |       36.1 |     0.178 |   0.49 |      6.79 |         1 |\n|        |    400 |       84.4 |      2.83 |   3.35 |      5.71 |         1 |        159 |     0.474 |   0.30 |      6.76 |         1 |\n|        |    800 |        383 |      5.04 |   1.32 |      5.43 |         1 |        700 |      3.67 |   0.52 |      6.49 |         1 |\n|        |   1600 |   1.68e+03 |      78.4 |   4.67 |      5.43 |         1 |   2.96e+03 |       123 |   4.15 |      6.61 |         1 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     EQ |    100 |       1.55 |    0.0251 |   1.62 |      10.2 |      1.75 |       1.87 |    0.0287 |   1.53 |      17.2 |      2.85 |\n|        |    200 |       2.81 |     0.113 |   4.01 |      35.6 |      4.32 |       7.08 |     0.126 |   1.78 |      34.6 |       5.1 |\n|        |    400 |       19.5 |     0.214 |   1.10 |      24.7 |      4.34 |       31.2 |     0.207 |   0.66 |      34.5 |       5.1 |\n|        |    800 |       86.1 |      4.26 |   4.95 |      24.1 |      4.45 |        125 |      4.15 |   3.32 |      36.2 |      5.58 |\n|        |   1600 |        279 |      4.04 |   1.45 |      32.6 |      6.01 |        487 |      8.48 |   1.74 |      40.1 |      6.07 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     EX |    100 |       1.53 |    0.0291 |   1.90 |      10.4 |      1.78 |       2.14 |    0.0587 |   2.75 |      15.1 |       2.5 |\n|        |    200 |       2.91 |     0.107 |   3.69 |      34.4 |      4.18 |       8.08 |     0.141 |   1.74 |      30.4 |      4.47 |\n|        |    400 |       19.6 |     0.302 |   1.54 |      24.6 |      4.31 |       34.2 |     0.527 |   1.54 |      31.4 |      4.65 |\n|        |    800 |       86.5 |      5.46 |   6.31 |        24 |      4.42 |        139 |      5.96 |   4.29 |      32.6 |      5.03 |\n|        |   1600 |        282 |      5.49 |   1.95 |      32.4 |      5.96 |        532 |      5.24 |   0.99 |      36.8 |      5.56 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     ER |    100 |       7.29 |     0.325 |   4.46 |      2.18 |     0.372 |       8.39 |     0.148 |   1.76 |      3.83 |     0.636 |\n|        |    200 |       16.4 |      0.77 |   4.68 |       6.1 |      0.74 |       17.9 |     0.252 |   1.41 |      13.7 |      2.02 |\n|        |    400 |       37.2 |     0.204 |   0.55 |        13 |      2.27 |       45.9 |     0.285 |   0.62 |      23.4 |      3.46 |\n|        |    800 |        111 |      3.37 |   3.02 |      18.6 |      3.43 |        159 |      3.21 |   2.02 |      28.5 |      4.39 |\n|        |   1600 |        332 |       3.5 |   1.06 |      27.5 |      5.06 |        553 |      8.03 |   1.45 |      35.3 |      5.34 |\n---------------------------------------------------------------------------------------------------------------------------------------\n|     OD |    100 |       1.36 |    0.0158 |   1.16 |      11.7 |         2 |          2 |    0.0331 |   1.66 |      16.1 |      2.68 |\n|        |    200 |       2.68 |      0.07 |   2.61 |      37.4 |      4.54 |       6.64 |     0.109 |   1.64 |        37 |      5.44 |\n|        |    400 |       19.2 |     0.199 |   1.04 |      25.1 |       4.4 |       29.1 |     0.122 |   0.42 |      36.9 |      5.46 |\n|        |    800 |       82.9 |      2.27 |   2.73 |        25 |      4.61 |        118 |         3 |   2.55 |      38.6 |      5.95 |\n|        |   1600 |        292 |      8.51 |   2.91 |      31.2 |      5.74 |        479 |      9.32 |   1.95 |      40.8 |      6.18 |\n---------------------------------------------------------------------------------------------------------------------------------------\n```\n\nFinally, we produce a LaTeX table, as shown in reference [\\[1\\]](#ref1):\n\n```matlab\n% LaTex table\ntimes_table_f(1, 'Param. set 1', data_v1, 'Param. set 2', data_v2)\n```\n\n![ex4 2 15](https://cloud.githubusercontent.com/assets/3018963/14706360/f6f17d18-07b5-11e6-926f-2314f9d59206.png)\n\n<a name=\"license\"></a>\n\n## 5\\. License\n\n[MIT License](LICENSE)\n\n<a name=\"references\"></a>\n\n## 6\\. References\n\n<a name=\"ref1\"></a>\n\n[\\[1\\]](#ref1) Fachada N, Lopes VV, Martins RC, Rosa AC. (2016) Parallelization\nStrategies for Spatial Agent-Based Models. *International Journal of Parallel\nProgramming*. https://doi.org/10.1007/s10766-015-0399-9 (arXiv version available\nat http://arxiv.org/abs/1507.04047)\n\n[Matlab]: http://www.mathworks.com/products/matlab/\n[Octave]: https://gnu.org/software/octave/\n[NetLogo]: https://ccl.northwestern.edu/netlogo/\n[sorttest.c]: https://github.com/fakenmc/sorttest_c\n[alternative]: http://stackoverflow.com/questions/673523/how-to-measure-execution-time-of-command-in-windows-command-line\n[sort_data]: data\n[pphpc_data]: http://dx.doi.org/10.5281/zenodo.34049\n[matlab2tikz]: http://www.mathworks.com/matlabcentral/fileexchange/22022-matlab2tikz-matlab2tikz\n[Bubble sort]: https://en.wikipedia.org/wiki/Bubble_sort\n[Selection sort]: https://en.wikipedia.org/wiki/Selection_sort\n[Merge sort]: https://en.wikipedia.org/wiki/Merge_sort\n[Quicksort]: https://en.wikipedia.org/wiki/Quicksort\n[PPHPC]: https://github.com/fakenmc/pphpc\n[GNU time]: https://www.gnu.org/software/time/\n[siunitx]: https://www.ctan.org/pkg/siunitx\n[multirow]: https://www.ctan.org/pkg/multirow\n[booktabs]: https://www.ctan.org/pkg/booktabs\n[get_gtime]: get_gtime.m\n[gather_times]: gather_times.m\n[perfstats]: perfstats.m\n[speedup]: speedup.m\n[times_table]: times_table.m\n[times_table_f]: times_table_f.m\n\n", 
  "id": 48292896
}
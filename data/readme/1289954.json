{
  "README": "Nutcracker version 0.1\n======================\n\nNutcracker is a quantum simulation program that uses the variational\nmatrix product state method to compute the ground and lowest lying\nexcited states of a system.  If you have been given the sources, then\nplease first read the INSTALL file for information on how to build\nNutcracker.\n\n(This README file assumes that you have already built Nutcracker and\nhave changed to the directory where you unpacked and built the\nsource.)\n\nTo get a complete list of the options to Nutcracker, run it with the\n--help option:\n\n    programs/nutcracker --help\n\nIf you want to see Nutcracker in action, type\n\n    python examples/generate/external-field.py 5\n\nto see an example of the input format, and then\n\n    python examples/generate/external-field.py 5 | programs/nutcracker -n 4\n\nto see Nutcracker find the first four levels of the system.\n\nIf you are feeling more adventurous, you can have fun solving the\ntransverse Ising model:\n\n    python examples/generate/transverse-ising-model.py 0.1 6 | programs/nutcracker -n 3\n\nTo use Nutcracker, you will need to have first decomposed your\nHamiltonian into matrix product operator form.  Describing how to do\nthis is outside the scope of this README at this time, but you can\nread an introduction to this idea at\n\n    http://arxiv.org/abs/0708.1221\n\nSince matrix product operators typically have repeated sites, the\ninput to Nutcracker takes the form of a list of site tensors and then\na list of indices to specify the order of the tensors in the operator.\nCurrently the only input format supported is YAML.  For example, the\nfollowing is the output of \"python examples/generate/external-field.py\n5\", which specifies a simple Hamiltonian with an external field for a\nsystem with 5 sites:\n\nsites:\n  - physical dimension: 2\n    left dimension:     1\n    right dimension:    2\n    matrices:\n       - from: 1\n         to:   1\n         data: [1,0,0,1]\n       - from: 1\n         to:   2\n         data: [1,0,0,-1]\n  - physical dimension: 2\n    left dimension:     2\n    right dimension:    2\n    matrices:\n       - from: 1\n         to:   1\n         data: [1,0,0,1]\n       - from: 1\n         to:   2\n         data: [1,0,0,-1]\n       - from: 2\n         to:   2\n         data: [1,0,0,1]\n  - physical dimension: 2\n    left dimension:     2\n    right dimension:    1\n    matrices:\n       - from: 1\n         to:   1\n         data: [1,0,0,-1]\n       - from: 2\n         to:   1\n         data: [1,0,0,1]\nsequence: [1, 2, 2, 2, 3]\n\nFirst, some background.  In YAML, there are two kinds of sections:\nkey/value sections and lists.  Key/value sections are specified by\nentries of the form \"key: value\".  Whitespace is significant, so all\nof the keys in a key/value section need to be aligned;  the values\ndon't have to be aligned, but I often added whitespace to line them up\nanyway.\n\nLists take either the form\n - A\n - B\n - C\n(that is, aligned entries beginning with a dash) or\n [A,B,C]\n(that is, something that looks like an array in JavaScript or Python).\n\nValues can themselves be lists or key/value sections, so that in the\nHamiltonian I listed above the keys \"sites\" and \"sequence\" specify\nvalues which are themselves lists;  in the case of \"sites\", each list\nentry contains a key/value pair.\n\nNow to explain how to interpret the above.  Note that this document\nhas two parts: a \"sites\" section which lists the site tensors and a\n\"sequence\" section that specifies how they are ordered.  In this case,\nthe sequence is [1,2,2,2,3], which says that the Hamiltonian contains\nfive sites and the matrix product representation consists of first\ntensor 1 (the first tensor in the list), then three copies of tensor\n2, and finally tensor 3.\n\nEach tensor has metadata providing its physical dimension (which\ncorresponds to the dimension of the particle at that chain site) and\nthe left and right \"bandwidth\" dimensions that connect it to its\nrespective left and right neighbors.  The first tensor must have left\ndimension 1, the last tensor must have right dimension 1, and the\ninterior tensors must agree with their neighbors on the size of the\nconnecting dimension (i.e. the left tensor's right dimension must\nmatch the right tensor's left dimension).\n\nMatrix product operator tensors are typically very sparse in the\nbandwidth dimension indices, and so the input format specifies the\ncontents of each tensor by way of a list of \"matrices\" where each\ndense submatrix is selected within the tensor by specifying the left\nbandwidth index (\"from\") and right bandwidth index (\"to\"), and the\ndata contained in the submatrix (of size physical dimension by\nphysical dimension) is specified using a flat array in row-major\norder.\n\nThe reason why I use the labels \"from\" and \"to\" rather than \"left\" and\n\"right\" is because this list corresponds to a list of transitions in a\nstate machine generating the Hamiltonian.  So for example in the\nsecond tensor above we see that there is a transition from the 1 state\nto the 1 state that produces an identity ([1,0,0,1] = [[1,0],[0,1]] =\nI), a transition from the 1 state to the 2 state that produces a Pauli\nZ operator ([1,0,0,-1]=[[1,0],[0,-1]]=Z), and finally a transition\nfrom the 2 state to the 2 state that also produces an identity.  This\nsite was engineered this way because it guarantees that only a single\nZ operator will be generated, as it is impossible to generate a second\none after the 2 state has been entered.\n\nAn alternative way of specifying the system above is as follows\n(generated by \"python examples/generate/external-field-using-anchors.py 5\"):\n\npaulis:\n  - &I [1,0,0,1]\n  - &Z [1,0,0,-1]\nsites:\n  - physical dimension: 2\n    left dimension:     1\n    right dimension:    2\n    matrices:\n       - from: 1\n         to:   1\n         data: *I\n       - from: 1\n         to:   2\n         data: *Z\n  - physical dimension: 2\n    left dimension:     2\n    right dimension:    2\n    matrices:\n       - from: 1\n         to:   1\n         data: *I\n       - from: 1\n         to:   2\n         data: *Z\n       - from: 2\n         to:   2\n         data: *I\n  - physical dimension: 2\n    left dimension:     2\n    right dimension:    1\n    matrices:\n       - from: 1\n         to:   1\n         data: *Z\n       - from: 2\n         to:   1\n         data: *I\nsequence: [1, 2, 2, 2, 3]\n\nThis example contains a \"paulis\" section.  When reading in the\nHamiltonian, Nutcracker ignores sections that it does not recognize,\nso it won't complain that this section is present.  However, within\nthis section there are values that have been tagged with the \"anchors\"\n&I and &Z.  These values can now be referenced using respectively *I\nand *Z, which substitutes the tagged value in the place of the\nreference.  This allows me to specify the matrix data once and then\nrefer to it using descriptive aliases.  (Note that this is a generic\nfeature of YAML and is not specific to my program or restricted in\nwhich values you tag and reference using anchors.)", 
  "read_at": 1462546897, 
  "description": "An efficient 1D quantum physics simulation system using matrix product states.", 
  "id": 1289954
}
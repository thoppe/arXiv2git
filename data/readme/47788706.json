{
  "read_at": 1462550394, 
  "description": "Plotting Basins of Univariate Rational Functions for Julia v0.3 (PBURF03.jl) takes the coordinates of a rational function and it returns a plot of the basins of the fixed points of the function (keywords: rational function,  complex dynamics, fractal geometry,  Julia set)", 
  "README.md": "\n#Global Visualization of Basins of Univariate Rational Functions with Julia\n##(User manual of the package GVBURF03.jl)\n\n\n\n\n\n\n##Abstract\n    \nThe goal of this\nmanual is to present a new package ``Global Visualization of Basins of Univariate Rational Functions'' \n    (GVBURF03.jl) written in (Julia v0.3) which allows us to visualize the attraction\n    basins associated to the end points of a discrete semi-flow induced\nby a rational function on the Riemann sphere by using its geometry and complex structure.\n\n\nThe main advantage of the algorithm used by this package is that avoids the problem\nof overflows caused by denominators close to zero and the problem of indetermination\nwhich appears when simultaneously the numerator and denominator are equal to zero. \nThis is solved by working with homogeneous coordinates and the iteration of a homogeneous \npair on the augmented complex projective line (Riemann sphere plus an additional superzero point). \nAnother good point of this package is that  Julia language provides a system having  simultaneously \nproductivity and high performance.\n\nThis can be applied to any numerical method which constructs a rational map to solve\nan univariate polynomial equation and verifying  that the roots of the equation are\nfixed points of the associated rational map.\n\nOne interesting novelty brought by the developed program\nis that it is able to plot fractals not only in a determined rectangular area of the complex plane,\nbut also on the whole surface of the Riemann sphere.\n\n\n\n\n##Introduction\n\n\n\nThe Julia programming language is announced to have  the following  nice properties:\nIt has automatic translation of formulas into efficient\nexecutable code.  It allows programmers to write clear, high-level,\ngeneric and abstract code that closely resembles mathematical\nformulas, as they have grown accustomed to in dynamic systems, yet\nproduces fast, low-level machine code that has traditionally only been\ngenerated by static languages.\n\n\nAlthough a sophisticated type system is made available to the\nprogrammer, it  is never\nrequired to specify types, nor  type annotations are necessary for\nperformance.  Type information flows naturally through the program due to dataflow type inference.\nFor a more complete information about Julia language we refer the reader to list of References in the botton.\n\n\nIn the this manual, we present a collection of algorithms and implementations based on the canonical bijection\nof the complex projective line and \n$\\hat {\\mathbb{C}}=\\mathbb{C}\\cup \\{\\infty\\}$ \n                which give us the following advantages:\n\n   * (i)  the use of homogeneous coordinates permits us to work at the point at infinity;\n                \n   * (ii)  the representation of a rational function by a pair of homogeneous  polynomials of two variables and with the same degree allows us to compute the numerical value of the function at any pole point and at the point at infinity;\n                        \n   * (iii) the use of normalized homogeneous coordinates  avoids overflow and underflow errors in our algorithms.\n\n                        \nOne of the main contributions of our algorithms is that mathematical model denominated complex projective line $\\bf{P}^{1}(\\mathbb{C})$ is improved with the addition of a new element: *the super-zero point* \n $ \\bar 0$.  In this way, we get the *augmented projective line* $\\bf{P}^{1+}(\\mathbb{C})=\\bf{P}^{1}(\\mathbb{C})\\cup \\{\\bar 0\\}$ and the corresponding *augmented 2-sphere* $S^{2+}=S^2\\cup \\{(0,0,0)\\}$. \n\n* (v) This permits us to solve indetermination problems which appear when simultaneously the values of the numerator and denominator of a rational function are equal to zero. In these cases, the super-zero is taken as the image of the indetermination point.\n\n\n\n\n# Instalation of the package GVBURF03  and usage of the main function:  `plottingBasinsUnivariateRationalFunctions`\n\n##Instalation of the package GVBURF03 \n\nThis software can be installed  by giving the following command in the julia command line \n(or in some \n[IJulia](href{https://github.com/JuliaLang/IJulia.jl}) notebook):\n\n```Pkg.clone(\"https://github.com/luisjavierhernandez/GVBURF03.jl\")```\n\nIn this way, all dependencies will be satisfied automatically.\n\nThe code will be upgraded every time the \n`Pkg.update()` command is used.\n\nAlternatively, you can manually copy the whole directory structure \nto your julia package directory (use `Pkg.dir()` to locate it), \nand then run `Pkg.update()` to download the dependencies.\n\n\nYou will need to have the Python \n[Matplotlib] (\\href{http://matplotlib.org/)\nlibrary installed on your machine in order to use PyPlot.  You can either\ndo inline plotting with \n[IJulia](\\href{https://github.com/JuliaLang/IJulia.jl) ,\nwhich doesn't require a GUI backend, or use the Qt, wx, or GTK+ backends\nof Matplotlib.\n\n    \n##Dependencies\n\nThe software GVBURF03 requires the previous packages: \n`Polynomials.jl` (Keno Fischer and 12 Contributors),\n   `Pyplot.jl\"`  (Steven G. Johnson and 18 Contributors) and \n   `Colors.jl` (29 Contributors).\n\n\n\n##Usage \n\n\n\nTo load the code just type:\n\n```using GVBURF03```\n\n\nThe main function of package is  \n\n``plottingBasinsUnivariateRationalFunctions(coefficientlistnum,coefficientlistden,...)``\n \n  This  function takes two lists of complex numbers that correspond to the coefficients of the numerator and denominator of a rational function and returns the list of fixed points of the function, a rectangular plot of the basins of this fixed points  and a color palette with colors which correspond to the different fixed points.\n                \nThe program function `plottingBasinsUnivariateRationalFunctions` uses the following arguments:\n\n * `coefficientlistnum`: It is the list of the complex coefficients of the numerator of a univariate rational fucntion.\n  \n * `coefficientlistden` :]Is  is the list of the complex coefficients of the denominator of a univariate rational function.\n                    \n\n                    \n                   \n                    \nThis function has the following optional arguments:\n\n * `expresolution`:  It is a nonnegative integer. The function gives a plot such that the sides are divided into $2^{ expresolution}$ subintervals. It default value is `expresolution=8`.\n\n * `iterationmax` : It is a nonnegative integer. This is the maximun of possible iterations of the rational function permitted when one runs this function. It default value is `iterationmax=25`.\n  \n  \n* `tolerances` : Is a triple of non negative intergers: (`minprecision, iterprecision, aproxprecision`)\n     \n\t* `minprecision`: It is a non negative integer. In order to modify the machine precision of the computing environment, this algorithm  takes $10^{-minprecision}$ equal to  $0.0$  for some arithmetric calculus.    \n\t* `iterprecision`: It is a nonnegative integer. The stopping criterium is that chordal distance between two the last consecutive iterates is less than $1/10^{\\, iterationmax}$. It default value is `iterationmax=3`.\n\t* `aproxprecision` : It is a nonnegative integer. When the chordal distance between the last iterate and a point of the list of fixed points is less than $1/10^{\\, aproxprecision}$ the function assigns the starting point to the basin of the fixed point. It default value is `aproxprecision=3`.\n      \n\n\nThis function also uses the following keyword arguments:\n\n\n * `colorstrategy`: It is an AbstractString. It possible values are  `\"positionplusiteration\", \"iteration\"` , and `\"positionfixedpoints\"`. The default value is  `\"colorstrategy=\"positionplusiteration\"`. The program provides three different strategies for assigning colors to the different points of a plot.\n\n * `model` : It is an AbstractString. The default value is    `model=\"localrectangle\"`. The other possible value is `model=\"invertedlocalrectangle\"`. It is importnat to remark that if the local retangle contains the unit disk, then the plots obtained by these two options give a global despcription of all the projective complex line. \n\n\n    * `rectanglesides`  It is a 4-dimensional tuple of real numbers (a,b,c,d)  which corresponds to rectangle obtined as the product of  the intervarls  [a,b] and [c,d]. The defaut value is  `rectanglesides=(-1.5,1.5,-1.5,1.5)`.\n                        \n\n#Example\n\nIf we type:\n\n```  \ncoefficientlistnumcompila=complex([1.,0.,0.,2.])\ncoefficientlistdencompila=complex([0.,0.,3.,0.])\nresult1=plottingBasinsUnivariateRationalFunctions(coefficientlistnumcompila,\ncoefficientlistdencompila; colorstrategy=\"iteration\")   \n```\n\nwe obtain the following return: \n\n\n![png](output_4_0.png)\n\n\n\n\n\n![svg](output_4_1.svg)\n\n#References\n\n  \n  \n * Jeff Bezanson, Alan Edelman,Stefan Karpinski and\n               Viral B. Shah (2014).\n[Julia: A Fresh Approach to Numerical Computing]\n  (http://arxiv.org/abs/1411.1607)\n\n\n\n\n\n## Author\n\nThis module was written by [Luis Javier Hernandez Paricio](http://www.unirioja.es/cu/luhernan/).\n\n\n    \n", 
  "id": 47788706
}
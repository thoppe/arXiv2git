{
  "read_at": 1462555833, 
  "description": "Calculates the Busy Beaver sigma function", 
  "README.md": "Busy Beaver\n===========\n\nApproximates the [Busy Beaver S-function][busybeaver], naively.\n\nS(n) is the largest number of 1s a non-halting, n-state Turing machine will\nprint on its tape. They don't have to be consecutive, but the machine *must*\nhalt.\n\nMore interestingly, the S-function is non-computable. Let me explain.\n\nTo calculate S(n), enumerate all n-state Turing machines and run them. When a\nmachine halts, count the number of 1s on its tape, and remember the machine\nwith the most ones so far --- the champion.\n\nBut soon you will encounter a machine that doesn't seem to halt. If you can\nconclusively *prove* that it will never halt, you ignore it --- Busy beaver\nmachines are, by definition, non-halting machines. But by the halting theorem,\nyou *cannot* prove that it will halt or not. You can create some clever\nheuristics that will identify large classes of machines that are provably in a\nloop. That is completely fine, and absolutely workable. But, you will *never*\ncover all cases. So at that point, you have to bring in human operators to\ninvestigate whether a given machine halts or not. That's also fine, but is\nreally just another version of the same problem. Are there machines that humans\nwon't be able to prove halts or not? Absolutely. I haven't seen one yet, but we\nknow from mathematics that there are statements that cannot be proven or\ndisproven. Statements that are true, but cannot be proven so.\n\nThat's why I made this program: I want to find some cool, but simple Turing\nmachines that I myself can't figure out will ever halt or not.\n\nStatus\n------\n\nThe program currently only handles 2-state, 2-symbol Turing machines: So it can\nonly find S(2). Furthermore, I side-step the halting problem by cheating: I\nstop programs after running more than S(2) operations.\n\nHow to run\n----------\n\nJust type `python busybeaver.py`. It supports Python 2 and 3. Protip: Use pypy.\n\nPlots\n-----\n![Plot of 2-state Busy Beavers](bb.png \"2-state Busy Beavers\")\n\nAbove I plot the number of ones and steps for all 2-state, binary Turing\nMachines starting with a blank tape. Each pixel is a machine, and its color is\nblue if the machine did not halt. The order stems from the way I enumerate the\ntransition functions, and is a bit arbitrary here (more below).\n\nEven so, we can clearly see clusters of machines with many ones. This shows\nthat some *general* configurations lead to clusters of well performing Busy\nBeavers, which is what you'd expect, but not necessarily so.\n\nTo run the plot, call `plot_bbs` or run `python busybeaver.py -p`. It requires\n`matplotlib`.\n\nAbout the ordering, it's defined by the function `enum_instructions`. For the\nabove plot, it enumerates:\n\n    for symbol in [0, 1]:\n        for move in [-1, 1]:\n            for state in [\"Z\"] + list(range(states)):\n                yield (symbol, move, state)\n\nHowever, it would be nice to get larger clusters of hits. Here's one where I\nhave the state at the top (for state, for move, for symbol ...):\n\n![Plot of 2-state Busy Beavers](bb-state-move-symb.png \"2-state Busy Beavers\")\n\nThen we have state-symbol-move:\n\n![Plot of 2-state Busy Beavers](bb-state-symb-move.png \"2-state Busy Beavers\")\n\nBut looking at the plots, we'd like to encounter the true Busy Beavers first,\nso let's reverse the enumeration of the states:\n\n![Plot of 2-state Busy Beavers](bb-rstate-symb-move.png \"2-state Busy Beavers\")\n\nI don't know if this clustering translates to larger number of states, but\nsince all of the 2-state machines will become embedded as sub-machines in the\n3-state machines, if we do the enumeration right, we should see higher number\nof ones earlier in the run there as well.\n\nUpdate: I tested it, and *do* get earlier hits for 3-state macines.\n\nA final thing, if you take a Turing Machine and reverse all directions, it\nshould be the exact same machine. Therefore, a true plot should show some kind\nof symmetry. I haven't figured out how to do that on a two-dimensional plot\nyet. But there should be no doubt that if you do this hyperdimensionally and in\na smart way, you should be able to perform some clustering.\n\nA 3-state Busy Beaver plot would be a 4k by 4k image, and we know that\nS(3)=107, so it's absolutely doable. Here's one rudimentary without any regard\nto clustering:\n\n![Plot of 3-state Busy Beavers](bb-3state-ones.png \"3-state Busy Beavers\")\n\nRemember, the reason we can easily plot stuff like this is because we cheat by\nknowing the values of S(2) and S(3). It's still a non-computable function, but\nby taking into account clustering, we can probably be able to find classes of\nmachines that never terminate.\n\nTodo\n----\n\n  * Run all machines at once, one step at a time (at least in batches).\n  * Multiplex batches onto processes with multiprocessing\n  * Find a cheap way to suspend and resume machines (e.g., make unique\n    numerical ID for each machine, save tape + ID, instead of dicts).\n  * With all above, have a queue, the ones that halt are removed from queue,\n    keep chugging on the ones that don't seem to finish.\n  * Finally, add some heuristics for detecting non-halting machines. Try to\n    cover all cases for Sigma(0..2) at least.\n\nPointers\n--------\n\n  * Visualization of Turing Machines, including Busy Beavers\n    http://www.mathrix.org/liquid/archives/visualizing-the-computational-universe-or-turings-deep-field\n\n  * The above on arxiv.org\n    http://arxiv.org/pdf/1201.0825v1.pdf\n\nAuthor and license\n------------------\n\nCopyright (C) 2016 Christian Stigen Larsen  \nDistributed under the GPL v3 or later.\n\n[busybeaver]: https://en.wikipedia.org/wiki/Busy_beaver\n", 
  "id": 53270554
}
{
  "read_at": 1462548303, 
  "description": "Fast differential coding functions (using SIMD instructions)", 
  "README.md": "# FastDifferentialCoding\n[![Build Status](https://travis-ci.org/lemire/FastDifferentialCoding.png)](https://travis-ci.org/lemire/FastDifferentialCoding)\n\nThese functions compute fast successive differences, and recover the original\nvalues from the fast successive differences (i.e., they compute a prefix sum)\nusing fast SIMD instructions.\n\nThey can be useful as part of compressed index.\n\n Rationale \n-----------\n\nArray of sorted integers, such as 1, 50, 100, 110, 120... are more often compressible \nwhen we first compute the successive differences (49, 50, 10, 10,....). The downside\nof this improved compressibility is the need to recover the original integers by\ncomputing the prefix sum. \n\nProgrammers are often tempted to computer a prefix sum in the straight-forward manner:\n\n```C\nfor (size_t i=1;i<size;i++) {\n  data[i] += data[i-1];\n}\n```\n\nUnfortunately, this approach can be slow. Thus we prefer to use SIMD instructions available\non recent Intel processors (SSE, available since the Pentium 4).\n\nThis library provide such fast functions.\n\nUsage\n-------\n\n```C\ncompute_deltas_inplace(datain, length, 0);// compute the deltas in-place\ncompute_prefix_sum_inplace(datain, length, 0);// under the delta computations (datain is back)\n```\nSee example.c for a complete example.\n\n Reference \n-----------\n\n Daniel Lemire, Nathan Kurz, Leonid Boytsov, SIMD Compression and the Intersection of Sorted\n Integers, Software: Practice and Experience 46 (6), 2016.\n http://arxiv.org/abs/1401.6399\n\n", 
  "id": 56268793
}
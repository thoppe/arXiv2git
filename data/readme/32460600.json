{
  "read_at": 1462544737, 
  "description": "Optimized implementation of the Louvain Method", 
  "README.md": "# The Louvain method for community detection in large networks\n\nImplementation of [Louvain method](https://perso.uclouvain.be/vincent.blondel/research/louvain.html) in C++.\n\n# How to\n\nCopy louvain.h to your project. \n\nHere is the sample code:\n\n```cpp\n// sample.\n// This program creates the dummy friendship graph\n// and then, clustering by this library.\n\n#include \"louvain.h\"\n#include <vector>\n#include <iostream>\n\n// Data structure that stick to each node.\nstruct Person {\n\tint id;\n};\n\nstruct Merger {\n\t// It is called when the algorithm merge the nodes into the cluster.\n\tPerson operator()(std::vector<louvain::Node<Person> > const& nodes, std::vector<int> idxs) const{\n\t\t// Select the most popular person\n\t\tlouvain::Node<Person> const* most_popular = &nodes[idxs.front()];\n\t\tfor(int idx : idxs){\n\t\t\tauto next = &nodes[idx];\n\t\t\tif(most_popular->degree() < next->degree()){\n\t\t\t\tmost_popular = &*next;\n\t\t\t}\n\t\t}\n\t\treturn Person{most_popular->payload().id};\n\t}\n};\n\nint main(int argc, char** argv){\n\tstd::mt19937 mt((std::random_device()()));\n\t// make 100 persons\n\tstd::vector<louvain::Node<Person>> persons(100);\n\tint totalLinks = 0;\n\t// connect the friends\n\tfor(int i=0;i<100;++i){\n\t\tpersons[i].payload().id = i+1;\n\t\tint from = mt() % persons.size();\n\t\tint to = mt() % persons.size();\n\t\tint weight = mt() % 100;\n\t\tif(from == to){\n\t\t\tpersons[from].selfLoops(persons[from].selfLoops()+weight);\n\t\t}else{\n\t\t\tpersons[from].neighbors().push_back(std::pair<int,int>(to,weight));\n\t\t}\n\t\ttotalLinks += weight;\n\t}\n\t// clustering hierarchically\n\tlouvain::Graph<Person, Merger> graph(totalLinks, std::move(persons));\n\tfor(int i=0;i<10;++i){\n\t\tconst size_t nedges = graph.edges();\n\t\tconst size_t nnodes = graph.nodes().size();\n\t\tstd::cout << \"[Iter \"<< i <<\"] Edges: \" << nedges << \" / Nodes: \" << nnodes << std::endl;\n\t\tsize_t n = 0;\n\t\tfor(auto node : graph.nodes()){\n\t\t\tstd::cout << \"  Cluster@\"<< n << \" / Leader: \" << node.payload().id<<\"\" << std::endl;\n\t\t\t++n;\n\t\t}\n\t\tgraph = graph.nextLevel();\n\t\t// exit if it converged\n\t\tif( graph.edges() == nedges && graph.nodes().size() == nnodes ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tstd::cout << \"Done\" << std::endl;\n\treturn 0;\n}\n```\n\n# Reference\n\nFast unfolding of communities in large networks,   \nVincent D Blondel, Jean-Loup Guillaume, Renaud Lambiotte, Etienne Lefebvre,   \nJournal of Statistical Mechanics: Theory and Experiment 2008 (10), P10008 (12pp)  \ndoi: [10.1088/1742-5468/2008/10/P10008](http://dx.doi.org/10.1088%2F1742-5468%2F2008%2F10%2FP10008). ArXiv: [http://arxiv.org/abs/0803.0476](http://arxiv.org/abs/0803.0476)", 
  "id": 32460600
}
{
  "id": 21660174, 
  "read_at": 1462551009, 
  "README.rst": "transp_to_gs2\n=============\n\nReads a TRANSP output file and outputs parameters relevant to a GS2 simulation\n\nInput:\n------\n\n* Function takes in three command line parameters with an optional fourth:\n   * Path to TRANSP file\n   * Radial location (will interpolate): value of the square root of the \n     normalized toroidal flux in range [0,1].\n   * Time (will determine nearest time index, i.e. won't interpolate).\n   * (optional) Template GS2 input file (relevant parameters will be replaced)\n   * Input command therefore looks like:\n\n.. code:: bash\n        \n   $ python main.py </path/to/transp/file> <radius> <time> (<gs2 input file>)\n     \nCaveats\n-------\n\n* **The sign of the flow shear may not be correct!** This program simply outputs \n  the gradient of the flow without changing sign. The real sign of the flow \n  shear will depend on the sign convention used in the experiment.\n\nOutput:\n-------\n* Produces a file called ``gs2_rho_<radius>_time_<time>.in``\n* Equilibrium parameters, e.g. temperatures, densities, gradients (see note\n  below), flows, shears\n* Geometric Miller parameters (with appropriate corrections for GS2, see\n  http://arxiv.org/abs/1403.3293)\n* Miscellaneous parameters which need to be set when using Miller parameters\n  (only option for this code so far).\n* Various useful reference parameters.\n\nRequirements:\n-------------\n\n* Python (at least 2.7)\n* NetCDF4\n* HDF5\n* Python NetCDF4 Interface: https://pypi.python.org/pypi/netCDF4\n* Python packages are listed in the ``requirements.txt`` file\n\nRadial Grids and Gradients\n--------------------------\n\n* TRANSP uses rho = psi_tor = sqrt(psi_tor / psi_tor,LCFS) where psi_tor is the\n  toroidal flux and psi_tor,LCFS is the toroidal flux of the last closed flux \n  surface.\n* Miller uses rho = a_n = diameter/diameter of LCFS where diameter refers to \n  the diameter of the flux surface at the height of the magnetic axis.\n* Can calculate a geometric coefficient which relates gradients on these two radial grids as follows:\n   * Essentially want to calculate dpsi_n / da_n.\n   * TRANSP file contains psi_t(rmaj) = TRFMP(RMAJM, TIME) which can be used to\n     calculate psi_n at output_radius as well as either side\n   * Can use variable RMAJM(RMAJM, TIME) to calculate the a_n at output_time.\n   * Use finite difference equation to calculate required differential coefficient.\n* Once coefficient has been obtained, can multiply all gradient variables by \n  this number to find what the gradient on a_n grid.\n* Simple variables such as temperature, density, etc. don't require any changes\n  since they are the same in both grids however gradients are defined on the \n  a_n grid when used with Miller.\n\nCollisions\n----------\n\n* The collision frequencies are calculated using the equation from the GS2 wiki\n  (http://gyrokinetics.sourceforge.net/wiki/index.php/Gs2_Input_Parameters).\n* More convenient equations (calculated by M. Barnes, where densities are in 1e19, temperatures are in keV, mi is the ion mass in multiples of the proton mass, zi is the ion charge which depends on the ionization):\n   * log(lambda) = 24 - log(1e4 * sqrt(n_ref/10) / t_e)\n   * vnewk_i = 9.21e-5 * amin * zi^4 * loglam * n_ref / (sqrt(2) * t_ref^2)\n   * vnewk_e = 3.95e-3 * amin * sqrt(0.5 * mi) * loglam * n_ref / (sqrt(t_ref) *\n     t_e^1.5)\n* For the purposes of collision frequency calculations, ni = ne = n to satisfy\n  quasineutrality.\n\nPlotting Routine\n----------------\nA rudimentarty plotting routine is also included and works in the following way:\n\n* It can be called as: \n\n.. code:: bash\n\n   python plot.py </path/to/transp/file> <independent variable> <dependent variable> <index of other dimension>\n\n* Independent variables are e.g. TIME, TIME3, X, XB, RMAJM\n* Dependent variable are a function of one or two of these variables.\n* Most variables are a function of two independent variables so the standard \n  behaviour requires specifying the index of the other independent variable. \n  For example, if you wanted to plot Q(TIME, XB) as a function of time at the \n  radial location idx = 50: ``python plot.py (filename) TIME Q 50``. However if \n  you wanted to plot Q as a function of radius for a given time index (= 98): \n  ``python plot.py (filename) XB Q 98``\n", 
  "description": "Reads a TRANSP output file and outputs parameters relevant to a GS2 simulation"
}
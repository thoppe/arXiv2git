{
  "read_at": 1462547057, 
  "description": "An extension to Torch7's nn package.", 
  "README.md": "# nnx: experimental 'nn' components\n\nThe original neural network from Torch7, [nn](https://github.com/torch/nn), contains stable and widely\nused modules. 'nnx' contains more experimental, unproven modules, and\noptimizations. Modules that become stable and which are proven useful make \ntheir way into 'nn' (some already have).\n\n## Library Documentation ##\nThis section includes documentation for the following objects:\n\n  * [SoftMaxTree](#nnx.SoftMaxTree) : a hierarchical log-softmax Module;\n  * [TreeNLLCriterion](#nnx.TreeNLLCriterion) : a negative log-likelihood Criterion for the SoftMaxTree;\n  * [CTCCriterion](#nnx.CTCCriterion) : a Connectionist Temporal Classification Criterion based on [warp-ctc](https://github.com/baidu-research/warp-ctc);\n  * [PushTable (and PullTable)](#nnx.PushTable) : extracts a table element and inserts it later in the network;\n  * [MultiSoftMax](#nnx.MultiSoftMax) : performs a softmax over the last dimension of a 2D or 3D input;\n  * [SpatialReSampling](#nnx.SpatialReSampling) : performs bilinear resampling of a 3D or 4D input image;\n  * [QDRiemaNNLinear] (#nnx.QDRiemaNNLinear) : quasi-diagonal reduction for Riemannian gradient descent\n  * [Recurrent](#nnx.Recurrent) : a generalized recurrent neural network container;\n  \n<a name='nnx.SoftMaxTree'/>\n### SoftMaxTree ###\nA hierarchy of parameterized log-softmaxes. Used for computing the likelihood of a leaf class. \nThis Module should be used in conjunction with the [TreeNLLCriterion](#nnx.TreeNLLCriterion). \nUsing this for large vocabularies (100,000 and more) greatly accelerates training and evaluation \nof neural network language models (NNLM). \nA vocabulary hierarchy is provided via the [dp](https://github.com/nicholas-leonard/dp/blob/master/README.md) package's\n[BillionWords](https://github.com/nicholas-leonard/dp/blob/master/doc/data.md#dp.BillionWords) \n[DataSource](https://github.com/nicholas-leonard/dp/blob/master/doc/data.md#dp.DataSource).\n\nThe constructor takes 2 mandatory and 4 optional arguments : \n * `inputSize` : the number of units in the input embedding representation;\n * `hierarchy` : a Tensor mapping one `parent_id` to many `child_id` (a tree);\n * `rootId` : a number identifying the root node in the hierarchy. Defaults to `-1`;\n * `accUpdate` : when the intent is to use `backwardUpdate` or `accUpdateGradParameters`, set this to true to save memory. Defaults to false;\n * `static` : when true (the defualt), returns parameters with keys that don't change from batch to batch;\n * `verbose` : prints some additional information concerning the hierarchy during construction.\n\nThe `forward` method returns an `output` Tensor of size 1D, while \n`backward` returns a table `{gradInput, gradTarget}`. The second \nvariable is just a Tensor of zeros , such that the `targets` can be \npropagated through [Containers](https://github.com/torch/nn/blob/master/doc/containers.md#nn.Containers) \nlike [ParallelTable](https://github.com/torch/nn/blob/master/doc/table.md#nn.ParallelTable).\n\n```lua\n> input = torch.randn(5,10)\n> target = torch.IntTensor{20,24,27,10,12}\n> gradOutput = torch.randn(5)\n> root_id = 29\n> input_size = 10\t\n> hierarchy = {\n>>    [29]=torch.IntTensor{30,1,2}, [1]=torch.IntTensor{3,4,5}, \n>>    [2]=torch.IntTensor{6,7,8}, [3]=torch.IntTensor{9,10,11},\n>>    [4]=torch.IntTensor{12,13,14}, [5]=torch.IntTensor{15,16,17},\n>>    [6]=torch.IntTensor{18,19,20}, [7]=torch.IntTensor{21,22,23},\n>>    [8]=torch.IntTensor{24,25,26,27,28}\n>> }\n> smt = nn.SoftMaxTree(input_size, hierarchy, root_id)\n> smt:forward{input, target}\n-3.5186\n-3.8950\n-3.7433\n-3.3071\n-3.0522\n[torch.DoubleTensor of dimension 5]\n> smt:backward({input, target}, gradOutput)\n{\n  1 : DoubleTensor - size: 5x10\n  2 : IntTensor - size: 5\n}\n\n```\n\n<a name='nnx.TreeNLLCriterion'/>\n### TreeNLLCriterion ###\nMeasures the Negative log-likelihood (NLL) for [SoftMaxTrees](#nnx.SoftMaxTree). \nUsed for maximizing the likelihood of SoftMaxTree outputs.\nThe SoftMaxTree Module outputs a column Tensor representing the log likelihood\nof each target in the batch. Thus SoftMaxTree requires the targets.\nSo this Criterion only computes the negative of those outputs, as \nwell as its corresponding gradients.\n\n<a name='nnx.PullTable'/>\n<a name='nnx.PushTable'/>\n### PushTable (and PullTable) ###\nPushTable and PullTable work together. The first can be put earlier\nin a digraph of Modules such that it can communicate with a \nPullTable located later in the graph. `PushTable:forward(input)` \nfor an `input` table of Tensors to the output, excluding one, the index of which \nis specified by the `index` argument in the `PushTable(index)` constructor.\nThe Tensor identified by this `index` is communicated to one or many \nPullTables created via the `PushTable:pull(index)` factory method. \nThese can be inserted later in the digraph such that \na call to `PushTable:forward(input)`, where `input` is a table or a Tensor, \nwill output a table with the previously *pushed* Tensor inserted \nat index `index`.\n\nAn example utilizing the above [SoftMaxTree](#nnx.SoftMaxTree) Module\nand a Linear Module demonstrates how the PushTable can be used to \nforward the `target` Tensor without any other \n[Table Modules](https://github.com/torch/nn/blob/master/doc/table.md#table-layers):\n```lua\n> mlp = nn.Sequential()\n> linear = nn.Linear(50,100)\n> push = nn.PushTable(2)\n> pull = push:pull(2)\n> mlp:add(push)\n> mlp:add(nn.SelectTable(1))\n> mlp:add(linear)\n> mlp:add(pull)\n> mlp:add(smt) --smt is a SoftMaxTree instance\n> mlp:forward{input, target} -- input and target are defined above\n-3.5186\n-3.8950\n-3.7433\n-3.3071\n-3.0522\n[torch.DoubleTensor of dimension 5]\n> mlp:backward({input, target}, gradOutput) -- so is gradOutput\n{\n  1 : DoubleTensor - size: 5x10\n  2 : IntTensor - size: 5\n}\n```\nThe above code is equivalent to the following:\n```lua\n> mlp2 = nn.Sequential()\n> para = nn.ParallelTable()\n> para:add(linear)\n> para:add(nn.Identity())\n> mlp2:add(para)\n> mlp2:add(smt)\n> mlp2:forward{input, target}\n-3.5186\n-3.8950\n-3.7433\n-3.3071\n-3.0522\n[torch.DoubleTensor of dimension 5]\n> mlp2:backward({input, target}, gradOutput)\n{\n  1 : DoubleTensor - size: 5x10\n  2 : IntTensor - size: 5\n}\n```\nIn some cases, this can simplify the digraph of Modules. Note that \na PushTable can be associated to many PullTables, but each PullTable \nis associated to only one PushTable.\n\n<a name='nnx.CTCCriterion'/>\n### CTCCriterion ###\n```\ncriterion = nn.CTCCriterion()\n```\nCreates a Criterion based on Baidus' [warp-ctc](https://github.com/baidu-research/warp-ctc) implementation.\nThis Module measures the loss between a 3D output of (batch x time x inputdim) and a target without needing alignment of inputs and labels.\nMust have installed warp-ctc which can be installed via luarocks:\n```\nluarocks install http://raw.githubusercontent.com/baidu-research/warp-ctc/master/torch_binding/rocks/warp-ctc-scm-1.rockspec\n```\nSupports cuda via:\n```\ncriterion = nn.CTCCriterion():cuda()\n```\nExample:\n```\noutput = torch.Tensor({{{1,2,3,4,5},{6,7,8,9,10}}}) -- Tensor of size 1x1x5 (batch x time x inputdim).\nlabel = {{1,3}}\nctcCriterion = nn.CTCCriterion()\n\nprint(ctcCriterion:forward(output,label))\n\nctcCriterion = ctcCriterion:cuda() -- Switch to cuda implementation.\noutput = output:cuda()\n\nprint(ctcCriterion:forward(output,label))\n```\n\ngives the output:\n```\n4.9038286209106\n4.9038290977478\n```\n<a name='nnx.MultiSoftMax'/>\n### MultiSoftMax ###\nThis Module takes 2D or 3D input and performs a softmax over the last dimension. \nIt uses the existing [SoftMax](https://github.com/torch/nn/blob/master/doc/transfer.md#nn.SoftMax) \nCUDA/C code to do so such that the Module can be used on both GPU and CPU. \nThis can be useful for [keypoint detection](https://github.com/nicholas-leonard/dp/blob/master/doc/facialkeypointstutorial.md#multisoftmax).\n\n<a name='nnx.SpatialReSampling'/>\n### SpatialReSampling ###\nApplies a 2D re-sampling over an input image composed of\nseveral input planes (or channels, colors). The input tensor in `forward(input)` is \nexpected to be a 3D or 4D tensor of size : `[batchSize x] nInputPlane x width x height`. \nThe number of output planes will be the same as the number of input\nplanes.\n\nThe re-sampling is done using [bilinear interpolation](http://en.wikipedia.org/wiki/Bilinear_interpolation). \nFor a simple nearest-neihbor upsampling, use `nn.SpatialUpSampling()`,\nand for a simple average-based down-sampling, use \n`nn.SpatialDownSampling()`.\n\nIf the input image is a 3D tensor of size `nInputPlane x height x width`,\nthe output image size will be `nInputPlane x oheight x owidth` where\n`owidth` and `oheight` are given to the constructor.\n\nInstead of `owidth` and `oheight`, one can provide `rwidth` and `rheight`, \nsuch that `owidth = iwidth*rwidth` and `oheight = iheight*rheight`.\n\nAs an example, we can run the following code on the famous Lenna image:\n```lua\nrequire 'image'                                                           \nrequire 'nnx'\ninput = image.loadPNG('doc/image/Lenna.png')\nl = nn.SpatialReSampling{owidth=150,oheight=150}\noutput = l:forward(input)\nimage.save('doc/image/Lenna-150x150-bilinear.png', output)\n```\n\nThe input:\n\n![Lenna](doc/image/Lenna.png) \n\nThe re-sampled output:\n\n![Lenna re-sampled](doc/image/Lenna-150x150-bilinear.png) \n\n<a name='nnx.QDRiemaNNLinear'/>\n### QDRiemaNNLinear ###\nThe Quasi-Diagonal Riemannian Neural Network Linear (QDRiemaNNLinear) module is an implementation\nof the quasi-diagonal reduction of metrics, used for Riemannian gradient descent.\nThe algorithm is defined in Riemannian metrics for neural networks I: feedforward networks by Yann Ollivier (http://arxiv.org/abs/1303.0818) and an efficient implementation is described in Practical Riemannian Neural Networks by Yann Ollivier and Gaetan Marceau-Caron (http://arxiv.org/abs/1602.08007).\nTo use this module, simply replace `nn.Linear(ninput,noutput)` with `nnx.QDRiemaNNLinear(ninput,noutput)`.\nAs always, the step-size must be chosen accordingly.\nTwo additional arguments are also possible:\n* gamma (default=0.01): determine the update rate of the metric for a minibatch setting, i.e., (1-gamma) * oldMetric + gamma newMetric. Smaller minibatches require a smaller gamma. A default value depending on the size of the minibatches is `gamma = 1. - torch.pow(1.-1./nTraining,miniBatchSize)` where `nTraining` is the number of training examples of the dataset and `miniBatchSize` is the number of training examples per minibatch. \n* qdFlag (default=true): Whether to use the quasi-diagonal reduction (true) or only the diagonal (false). The former should be better.\n\nThis module is a straightforward implementation of the outer product gradient descent.\n\n## Requirements\n\n* Torch7 (www.torch.ch)\n\n## Installation\n\n* Install Torch7 (refer to its own documentation).\n* clone this project into dev directory of Torch7.\n* Rebuild torch, it will include new projects too.\n\n## Use the library\n\nFirst run torch, and load nnx:\n\n``` sh\n$ torch\n``` \n\n``` lua\n> require 'nnx'\n```\n\nOnce loaded, tab-completion will help you navigate through the\nlibrary (note that most function are added directly to nn):\n\n``` lua\n> nnx. + TAB\n...\n> nn. + TAB\n```\n\nIn particular, it's good to verify that all modules provided pass their\ntests:\n\n``` lua\n> nnx.test_all()\n> nnx.test_omp()\n```\n\n<a name='nnx.Recurrent'/>\n### Recurrent ###\n\nDEPRECATED July 6th, 2015. Use [rnn](https://github.com/Element-Research/rnn) instead.\n", 
  "id": 2002672
}
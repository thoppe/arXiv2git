{
  "read_at": 1462550962, 
  "description": "Reference implementations of state-based CRDTs that offer deltas for all mutations.", 
  "README.md": "delta-enabled-crdts\n===================\n\nReference implementations of state-based CRDTs that offer deltas for all mutations.\n\nDatatypes\n---------\n\nCurrent datatypes are:\n\n  * GSet: A grow only set \n  * 2PSet: A two phase set that supports removing an element for ever\n  * Pair: A pair of CRDTs, first and second. \n  * GCounter: A grow only counter\n  * PNCounter: A counter supporting increment and decrement\n  * LexCounter: A counter supporting increment and decrement (Cassandra inspired)\n  * DotKernel: (Auxiliary datatype for building causal based datatypes)\n  * CCounter: A (causal) counter for map embedding (Optimization over Riak EMCounter)\n  * AWORSet: A add-wins optimized observed-remove set that allows adds and removes\n  * RWORSet: A remove-wins optimized observed-remove set that allows adds and removes\n  * MVRegister: An optimized multi-value register (new unpublished datatype)\n  * EWFlag: Flag with enable/disable. Enable wins (Riak Flag inspired)\n  * DWFlag: Flag with enable/disable. Disable wins (Riak Flag inspired)\n  * GMap: Grow only map of keys to CRDTs\n  * ORMap: Map of keys to causal CRDTs. (spec in common with the Riak Map)\n  * RWLWWSet: Last-writer-wins set with remove wins bias (SoundCloud inspired)\n  * LWWReg: Last-writer-wins register\n  * BCounter: Non negative bounder counter. (by Valter, et all. SRDS 2015)\n  * ORSeq: A causal sequence prototype. (Treedoc inspired)\n\nEach datatype depicts some mutation methods and some access methods. Mutations will inflate the state in the join semi-lattice and also return a state with a delta mutation. The delta mutations are intended to be much smaller that the whole state and can be joined together or to full states to synchronize states.  \n\nIf the return of mutation methods is ignored, the datatypes behave as standard state based CRDTs. The use of deltas is strictly optional. \n\nCheck the delta-tests.cc file to get a rough idea on how to use the datatypes.  \nThe code is still in a very early state and was not properly tested yet. \n\nSimple Example\n--------------\n\nLets make two replicas of an add-wins or-set of strings. Node `x` uses replica `sx` and node `y` uses `sy` (in practice you would like to run this in different nodes, and serialize state to move it between nodes). The first node will add and then remove a given string and the other node will add that same string and a diferent one. Finally we will join the two states and see the result. \n\n```cpp\naworset<string> sx(\"x\"),sy(\"y\");\n\n// Node x\nsx.add(\"apple\");\nsx.rmv(\"apple\");\n// Node y\nsy.add(\"juice\");\nsy.add(\"apple\");\n\n// Join into one object and show it \nsx.join(sy);\ncout << sx.read() << endl;\n```\n\nThe output will be: `( apple juice )`\n\nNow, the same example, with a remove-wins or-set and using chars for node ids.\nThe default template type for node ids is string, so we need to change it to char in the second template argument. \n\n```cpp\nrworset<string,char> sx('x'),sy('y');\n\n// Node x\nsx.add(\"apple\");\nsx.rmv(\"apple\");\n// Node y\nsy.add(\"juice\");\nsy.add(\"apple\");\n\n// Join into one object and show it \nsx.join(sy);\ncout << sx.read() << endl;\n```\n\nThe output will be: `( juice )`\n\nExample with delta-mutations\n----------------------------\n\nThe above example show how to operate with standard state-based CRDTs. One\ndrawback is that we need to ship and join full states. It would be much better\nif we  could ship instead only the parts of the state that changed. We call\nthese parts deltas. \n\nIn the next example, using a simple grow-only set of integers `gset<int>`, node\n`x` will create a replica and replicate it to node `y`. Afterwards we will do\nsome new operations in `y`, collect the deltas and ship them back and merge\nthem to `x` replica. \n\n```cpp\n  gset<int> sx;\n\n  // Node x does initial operations\n  sx.add(1); sx.add(4);\n\n  // Replicate full state in sy;\n  gset<int> sy=sx;\n\n  // Node y records operations in delta \n  gset<int> dy;\n  dy=sy.add(2);\n  dy.join(sy.add(3));  // Join delta to delta\n\n  cout << sy.read() << endl;  // ( 1 2 3 4 )\n\n  // Merge deltas ( 2 3 ) to node x\n  cout << dy.read() << endl;  // ( 2 3 )\n  cout << sx.read() << endl;  // ( 1 4 )\n  sx.join(dy);\n  cout << sx.read() << endl;  // ( 1 2 3 4 )\n```\n\nDatatype Example Catalog\n------------------------\n\nIn construction is a catalog of simple examples for each datatype. To keep the examples simple, deltas are not collected. \n\nGSet\n----\n\nGrow only sets do not require node ids and can store any type that is storable in a C++ std::set. These sets can only grow and do not support removal of elements. Join is by set union. \n\n```cpp\n  gset<string> a,b;\n\n  a.add(\"red\");\n  b.add(\"blue\");\n\n  cout << join(a,b) << endl; // GSet: ( blue red )\n```\n\nTwoPSet\n-------\n\nTwo phase sets can both add and remove elements, but removed elements cannot be re-added. Both GSets and TwoPSets can be read to return a std::set with the payload. \n\n```cpp\n  twopset<float> a,b;\n\n  a.add(3.1415);\n  a.rmv(3.1415);\n  b.add(42);\n  b.add(3.1415);\n\n  cout << join(a,b) << endl; // 2PSet: S( 42 ) T ( 3.1415 )\n\n  gset<float> c;\n  c.add(42);\n\n  cout << ( join(a,b).read() == c.read() ) << endl; // true\n```\n\nPair\n----\n\nAll CRDTs here can be composed in a pair using the std::pair construction. Join is defined for pairs and applies independently a join to the first and second components of the pair. More formally, pair is the composition by product.  \n\nThe example bellow uses the GSets, but any other valid CRDT types could be composed (including other pairs). \n\n```cpp\n  pair<gset<int>,gset<char>> a,b,c;\n\n  a.first.add(0); \n  b.first.add(1);\n  a.second.add('a'); \n  b.second.add('x'); b.second.add('y');\n\n  c=join(a,b);\n\n  cout << c << endl; // (GSet: ( 0 1 ),GSet: ( a x y ))\n```\n\nA special use of pairs is when the first elements are comparable in a total order (int, float, bool, double, ...). In that case a special lexicographic join can be used as alternative to join. It compares the first elements and when one is higher it dictates the whole winning pair. On ties a join is performed on the second elements. The example also shows that primitive type numbers can be joined (by taking their max). \n\n```cpp\n  pair<int,float> lww_a(12,42), lww_b(20,3.1415);\n\n  cout << join(lww_a,lww_b) << endl; // (20,42)\n  cout << lexjoin(lww_a,lww_b) << endl; // (20,3.1415)\n```\n\nGCounter\n--------\n\nThe GCounter is basically a counter that starts at 0 and can only be incremented (and thus stays always positive). It is implemented by storing one number per each active replica, and thus the programmer must decide a type for the replica/actor) id (string by default) and indicate the type for the value itself (int by default). Increments have a default of +1 but they can be changed. In the example we create three replicas 'x', 'y', 'z' and do some concurrent and sequential increments and read the result. We also show that join is idempotent.  \n\n```cpp\n  gcounter<unsigned int> x(\"x\"),y(\"y\"),z(\"z\");\n\n  x.inc(); x.inc();\n  y.inc(2);\n  z.join(x); z.join(y);\n  \n  cout << z.read() << endl; // 4\n\n  x.inc(2);\n  z.inc(2);\n  z.join(x);\n  z.join(x);\n\n  cout << z.read() << endl; // 8\n  cout << z << endl; // GCounter: ( x->4 y->2 z->2 ) \n```\n\nPNCounter\n---------\n\nThe PNCounter allows increments and decrements, by keeping a separate account of increments and decrements. You can think of it as two GCounters.  The reported value is the number of increments minus the number of decrements. \n\nIn the example bellow we declare two instances of counters for integers and change the default key type to be char (instead of string). Since among the two instances we did a total of 4 increments and 2 decrements, the overall value after should be 2. \n\n```cpp \n  pncounter<int,char> x('a'), y('b');\n\n  x.inc(4); x.dec();\n  y.dec();\n\n  cout << (x.read() == y.read()) << endl; // value is diferent\n\n  x.join(y); y.join(x);\n\n  cout << (x.read() == y.read()) << endl; // value is the same, both are 2\n```\n\nLexCounter\n---------\n\nThe Lexicographic Counter is similar to the counters used in Cassandra (tough earlier specs existed). It is an alternative to the PNCounter and is based on a lexicographic pair, per actor, of a grow-only version number and count produced by that actor. Its use is just like a PNCounter, so we use a similar example bellow. To make the example slightly different we use the default string keys and no longer mention a char in the second template argument.\n\n```cpp \n  lexcounter<int> x(\"a\"), y(\"b\");\n\n  x.inc(4); x.dec();\n  y.dec();\n\n  cout << (x.read() == y.read()) << endl; // value is diferent\n\n  x.join(y); y.join(x);\n\n  cout << (x.read() == y.read()) << endl; // value is the same, both are 2\n```\n\nDotKernel\n---------\n\nWhile the DotKernel is a proper CRDT, with mutations and providing a join, its purpose is not direct use but instead serve as a basis for all the datatypes that use dot based causality tracking (namely AWORSet, RWORSet, MVRegister, EWFlag, DWFlag and ORMap). All the supported datatypes do not need to define a specialized join and simply use the DotKernel generic join. \n\nThe DotKernel can be used to locally create unique tags/dots (by consulting information on a causal context variable cc) and store in its local datastore (a map variable named ds) associations from that tag to an instance of a given payload type. \n\nIf a mapping is removed, the tag/dot is still remembered (in a compact form) on the causal context and this allows the join to be efficient in the propagation of removes without resorting to more space demanding tombstones. In short, it implements the theory behind Optimized OR-Sets (a.k.a. ORSWOT) and offers a more general use for other similar datatypes. \n\nCCounter\n--------\n\nA Causal Counter is a variation of a LexCounter that can be used inside ORMaps. \nEach time a given actor wants to increase or decrease a count, it consults its last updated count, changes it and stores it under a new dot entry after deleting its previous entry. As required for all ORMap embeddable datatypes a reset is supported, but it is not a perfect observed reset. \n\nWe show a simple example with increments and decrements\n\n```cpp\n  ccounter<int> x(\"a\"), y(\"b\");\n\n  x.inc(4); x.dec();\n  y.dec();\n\n  cout << (x.read() == y.read()) << endl; // value is diferent\n\n  x.join(y); y.join(x);\n\n  cout << (x.read() == y.read()) << endl; // value is the same, both are 2\n  \n  x.reset();\n\n  cout << x.read() << endl; // you guessed correctly, its 0\n}\n```\n\nAWORSet\n-------\n\nAn Add Wins Observed Remove Set is a set that allows element additions and removals. The removals only affect the elements that are visible locally, so that a concurrent removal and addition of the same element will result in the element still being present after joining the sets. The implementation used the DotKernel and is optimized, it is also known as ORSWOT in the early literature.\n\nThe example bellow will show a concurrent add and remove and finally a reset. \n\n```cpp\n  aworset<float> x(\"a\"), y(\"b\");\n\n  x.add(3.14); x.add(2.718); x.rmv(3.14);\n  y.add(3.14);\n\n  x.join(y);\n\n  cout << x.read() << endl; // Both 3.14 and 2.718 are there\n\n  x.reset(); x.join(y);\n\n  cout << x.read() << endl; // Empty, since 3.14 adition from \"b\" was visible\n```\n\nRWORSet\n-------\n\nA Removed Wins Observed Remove Set is the dual implementation to AWORSet where concurrent removes win over adds. The implementation is slightly more complex but still optimized and based on the DotKernel. \n\nWe show the same example as above, but with a different outcome. \n\n```cpp\n  rworset<float> x(\"a\"), y(\"b\");\n\n  x.add(3.14); x.add(2.718); x.rmv(3.14);\n  y.add(3.14);\n\n  x.join(y);\n\n  cout << x.read() << endl; // Only 2.718 is there, since remove wins\n\n  x.reset(); x.join(y);\n\n  cout << x.read() << endl; // Empty\n```\n\nMVReg\n-----\n\nA Multi-Value Register is a simple data type that allows read and write operations of a given payload. Writes will overwrite all locally visible values, but concurrent writes will create alternative values tat are represented as siblings. Thus, unlike a sequential register, reads may return multiple values.   \n\nIn the example bellow, we do some sequential writes that overwrite the initial writes, and then we join two concurrent writes to show a pair of siblings. Finally we overwrite everything with the string \"mars\", in replica y, and show that this effect propagates on join to replica x. \n\n```cpp\n  mvreg<string> x(\"uid-x\"),y(\"uid-y\");\n\n  x.write(\"hello\"); x.write(\"world\"); \n\n  y.write(\"world\"); y.write(\"hello\"); \n\n  y.join(x);\n\n  cout << y.read() << endl; // Output is ( hello world )\n\n  y.write(\"mars\");\n\n  x.join(y);\n\n  cout << x.read() << endl; // Output is ( mars )\n```\n\nMulti-value registers can store any type of \"opaque\" payload. However if the payload supports a partial order, it is possible to use a resolve method to reduce the number of siblings to only those that are maximal elements in the order. In other words, if any sibling has another sibling that is greater than it, it is removed. A special case is when the stored payload is a total order, implying that resolve will always produce a register with a single element, the maximal element. \n\n```cpp\n  mvreg<int> a(\"uid-a\"), b(\"uid-b\");\n\n  a.write(0); b.write(3); a.join(b); \n\n  cout << a.read() << endl; // Output is ( 0 3 )\n  \n  a.resolve();\n\n  cout << a.read() << endl; // Output is ( 3 )\n\n  a.write(1); // Value can go down again\n\n  cout << a.read() << endl; // Output is ( 1 )\n```\n\nThe last example, bellow, shows a payload that reflects a partial order, and can thus allow for concurrent maximals after resolve. \n\n```cpp\n  mvreg<pair<int,int>> j(\"uid-j\"),k(\"uid-k\"),l(\"uid-l\");\n\n  j.write(pair<int,int>(0,0));\n  k.write(pair<int,int>(1,0));\n  l.write(pair<int,int>(0,1));\n\n  j.join(k); j.join(l); j.resolve();\n\n  cout << j.read() << endl; // Output is ( (0,1) (1,0) )\n```\n\nORMap\n-----\n\nAn Observed Remove Map can be used to compose a map of keys to CRDTs. Not all CRDTs make sense inside such a map, so currently it is restricted to AWORSet, RWORSet, MVRegister, EWFlag, DWFlag, CCounter and the ORMap (enabling recursive composition). \n\nLets start with a simple example of a map that maps strings to AWORSets. \nWe have two map replicas that will have a key in common and be joined. Later we remove content from one of the keys and see the effect after joining again. \n\n```cpp\n  ormap<string,rworset<string>> mx(\"x\"),my(\"y\");\n\n  mx[\"paint\"].add(\"blue\");\n  mx[\"sound\"].add(\"loud\");  mx[\"sound\"].add(\"soft\");\n  my[\"paint\"].add(\"red\");\n  my[\"number\"].add(\"42\");\n\n  mx.join(my);\n\n  cout << mx << endl; // this map includes all added elements\n\n  my[\"number\"].rmv(\"42\");\n  mx.join(my);\n\n  cout << mx << endl; // number set is now empty also in mx\n```\n\nIf a key is erased in a map, this is equivalent to resenting the whole CRDT that it points to. If its a set it will become empty, a counter goes back to 0 and so forth. \n\n```cpp\n  mx.erase(\"paint\");\n  my[\"paint\"].add(\"green\");\n\n  my.join(mx);\n\n  cout << my << endl; // in the \"paint\" key there is only \"green\" \n```\n\nAbove we see that if new operations are done concurrently with the erase they still take place. The reset is an observed reset and it only affects data that is already present. \n\nThe next example illustrates that maps can hold other maps and that the key type can also be chosen. \n\n```cpp\n  ormap<int,ormap<string,aworset<string>>> ma(\"alice\"), mb(\"bob\");\n\n  ma[23][\"color\"].add(\"red at 23\");\n  ma[44][\"color\"].add(\"blue at 44\");\n  mb[44][\"sound\"].add(\"soft at 44\");\n\n\n  ma.join(mb);\n\n  cout << ma << endl; // Map with two map entries, inner map 44 with two entries\n```\n\nIn a map, capturing a delta is done in the usual way, with the exception of the key access operator. This is due to the access returning a reference to the stored value, and thus its delta mutations will be of that type and must be converted to a suitable map type. \n\n```cpp\n  ormap<string,aworset<string>> mx(\"x\"),d1,d2;\n  mx[\"color\"].add(\"red\");\n  mx[\"color\"].add(\"blue\");\n\n  // Now make some deltas, d1 and d2\n\n  d1=mx.erase(\"color\");\n\n  d2[\"color\"].join(mx[\"color\"].add(\"black\"));\n\n  cout << d1 << endl; // Will erase observed dots in the \"color\" entry\n  cout << d2 << endl; // Will add a dot (x:3) for \"black\" entry under \"color\"\n```\n\nKeep tuned for more datatype examples soon ...\n\nAcknowledgments\n---------------\n\nThis work was partially supported by projects: FP7 SyncFree under grant 609551, and ON2 project NORTE-07-0124-FEDER-000058. \n\nDisclaimer\n----------\n\nThe provided implementations are still in an alpha stage. The present focus is\nestablishing the main operational properties of the targeted CRDTs, that\nmatches the theory supporting them, and not the extensive programming of a rich\nAPI for each, or ensuring production quality code. Only a minimal amount of\nexample-based testing was conducted and no serious benchmarking was done.  If\nyou are a developer and have a product that can benefit from these datatypes,\nyou should either ensure you understand the code and can improve it to meet\nyour needs, or you can contact me and work out a way to allocate the resources\nfor product improvement. \n\nAdditional information\n----------------------\n\nFor more information on CRDTs and the newer concept of delta mutation consider checking the following papers and video presentation:\n\n  1. A comprehensive study of Convergent and Commutative Replicated Data Types\nhttp://hal.inria.fr/docs/00/55/55/88/PDF/techreport.pdf\n\n  2. Efficient State-based CRDTs by Delta-Mutation\nhttp://arxiv.org/pdf/1410.2803v1.pdf\n\n  3. Conflict-free Replicated Data Types\nhttp://gsd.di.uminho.pt/members/cbm/members/cbm/ps/sss2011.pdf\n\n  4. Implementation of CRDTs with d-mutators\n  https://www.youtube.com/watch?v=jwCx1A181vY&list=PL9Jh2HsAWHxIc7Tt2M6xez_TOP21GBH6M&index=15 \n", 
  "id": 21395444
}
{
  "read_at": 1462547552, 
  "description": "Egison is a purely functional programming language with non-linear pattern-matching against non-free data types. We can directly pattern-match against a wide range of data types such as lists, multisets, sets, trees and graphs with Egison.", 
  "README.md": "# The Egison Programming Language\n\nEgison is the **pattern-matching-oriented**, purely functional programming language.\nWe can directly represent pattern-matching against lists, multisets, sets, trees, graphs and any kind of data types.\nThis is the repository of the interpreter of Egison.\n\nFor more information, visit <a target=\"_blank\" href=\"https://www.egison.org\">our website</a>.\n\n## Non-Linear Pattern-Matching against Non-Free Data Types\n\nWe can do non-linear pattern-matching against non-free data types in Egison.\nAn non-free data type is a data type whose data have no canonical form, a standard way to represent that object.\nIt enables us to write elegant programs.\n\n### Twin Primes\n\nWe can use pattern-matching for enumeration.\nThe following code enumerates all twin primes from the infinite list of prime numbers with pattern-matching!\n\n<hr/>\n<img width=\"100%\" src=\"https://raw.githubusercontent.com/egison/egison/master/images/twin-primes.png\" />\n<hr/>\n\n### Poker Hands\n\nThe following code is the program that determines poker-hands written in Egison.\nAll hands are expressed in a single pattern.\n\n<hr/>\n<img width=\"100%\" src=\"https://raw.githubusercontent.com/egison/egison/master/images/poker-hands.png\" />\n<hr/>\n\n### Mahjong\n\nWe can write a pattern even against mahjong tiles.\nWe modularize patterns to represent complex mahjong hands.\n\n<hr/>\n<img width=\"100%\" src=\"https://raw.githubusercontent.com/egison/egison/master/images/mahjong.png\" />\n<hr/>\n\n### Graphs\n\nWe can pattern-match against graphs.\nWe can write program to solve the travelling salesman problem in a single pattern-matching expression.\n\n<hr/>\n<img width=\"100%\" src=\"https://raw.githubusercontent.com/egison/egison/master/images/salesman.png\" />\n<hr/>\n\nAren't these exciting?\nThe pattern-matching of Egison is very powerful.\nWe can use it for pattern-matching also against graphs and tree-structures such as XML.\n\n## Egison as a Computer Algebra System\n\nAs an application of Egison, we implemented a computer algebra system on Egison.\nThe most part of this computer algebra system is written in Egison and extensible in Egison.\n\n### Symbolic Algebra\n\nUnbound variables are treated as symbols.\n\n```\n> x\nx\n> (** (+ x y) 2)\n(+ x^2 (* 2 x y) y^2)\n> (** (+ x y) 10)\n(+ x^10 (* 10 x^9 y) (* 45 x^8 y^2) (* 120 x^7 y^3) (* 210 x^6 y^4) (* 252 x^5 y^5) (* 210 x^4 y^6) (* 120 x^3 y^7) (* 45 x^2 y^8) (* 10 x y^9) y^10)\n```\n\nWe can handle algebraic numbers, too.\n\n* [Definition of `sqrt` in `root.egi`](https://github.com/egison/egison/blob/master/lib/math/algebra/root.egi)\n\n```\n> (sqrt x)\n(sqrt x)\n> (sqrt 2)\n(sqrt 2)\n> (sqrt 4)\n2\n> (+ x (sqrt y))\n(+ x (sqrt y))\n```\n\n### Complex Numbers\n\nThe symbol `i` is defined to rewrite `i^2` to `-1` in Egison library.\n\n* [Rewriting rule for `i` in `normalize.egi`](https://github.com/egison/egison/blob/master/lib/math/normalize.egi)\n\n```\n> (* i i)\n-1\n> (* (+ 1 (* 1 i))  (+ 1 (* 1 i)))\n(* 2 i)\n> (** (+ 1 (* 1 i)) 10)\n(* 32 i)\n> (* (+ x (* y i))  (+ x (* y i)))\n(+ x^2 (* 2 i x y) (* -1 y^2))\n```\n\n### Square Root\n\nThe rewriting rule for `sqrt` is also defined in Egison library.\n\n* [Rewriting rule for `sqrt` in `normalize.egi`](https://github.com/egison/egison/blob/master/lib/math/normalize.egi)\n\n```\n> (* (sqrt 2) (sqrt 2))\n2\n> (* (sqrt 6) (sqrt 10))\n(* 2 (sqrt 15))\n> (sqrt x)\n(sqrt x)\n> (* (sqrt (* x y)) (sqrt (* 2 x)))\n(* x (sqrt 2) (sqrt y))\n```\n\n### The 5th Roots of Unity\n\nThe following is a sample to calculate the 5th roots of unity.\n\n* [Definition of `q-f'` in `equations.egi`](https://github.com/egison/egison/blob/master/lib/math/algebra/equations.egi)\n\n```\n> (q-f' 1 1 -1)\n[(/ (+ -1 (sqrt 5)) 2) (/ (+ -1 (* -1 (sqrt 5))) 2)]\n> (define $t (fst (q-f' 1 1 -1)))\n> (q-f' 1 (* -1 t) 1)\n[(/ (+ -1 (sqrt 5) (sqrt (+ -10 (* -2 (sqrt 5))))) 4) (/ (+ -1 (sqrt 5) (* -1 (sqrt (+ -10 (* -2 (sqrt 5)))))) 4)]\n> (define $z (fst (q-f' 1 (* -1 t) 1)))\n> z\n(/ (+ -1 (sqrt 5) (sqrt (+ -10 (* -2 (sqrt 5))))) 4)\n> (** z 5)\n1\n```\n\n### Differentiation\n\nWe can implement differentiation easily in Egison.\n\n* [Definition of `d/d` in `derivative.egi`](https://github.com/egison/egison/blob/master/lib/math/analysis/derivative.egi)\n\n```\n> (d/d (** x 3) x)\n(* 3 x^2)\n> (d/d (** e (* i x)) x)\n(* i (** e (* i x)))\n> (d/d (d/d (log x) x) x)\n(/ -1 x^2)\n> (d/d (* (cos x) (sin x)) x)\n(+ (* -1 (sin x)^2) (cos x)^2)\n```\n\n### Taylor Expansion\n\nThe following sample executes Taylor expansion on Egison.\nWe verify [Euler's formula](https://en.wikipedia.org/wiki/Euler%27s_formula) in the following sample.\n\n* [Definition of `taylor-expansion` in `derivative.egi`](https://github.com/egison/egison/blob/master/lib/math/analysis/derivative.egi)\n\n```\n> (take 8 (taylor-expansion (** e (* i x)) x 0))\n{1 (* i x) (/ (* -1 x^2) 2) (/ (* -1 i x^3) 6) (/ x^4 24) (/ (* i x^5) 120) (/ (* -1 x^6) 720) (/ (* -1 i x^7) 5040)}\n> (take 8 (taylor-expansion (cos x) x 0))\n{1 0 (/ (* -1 x^2) 2) 0 (/ x^4 24) 0 (/ (* -1 x^6) 720) 0}\n> (take 8 (taylor-expansion (* i (sin x)) x 0))\n{0 (* i x) 0 (/ (* -1 i x^3) 6) 0 (/ (* i x^5) 120) 0 (/ (* -1 i x^7) 5040)}\n> (take 8 (map2 + (taylor-expansion (cos x) x 0) (taylor-expansion (* i (sin x)) x 0)))\n{1 (* i x) (/ (* -1 x^2) 2) (/ (* -1 i x^3) 6) (/ x^4 24) (/ (* i x^5) 120) (/ (* -1 x^6) 720) (/ (* -1 i x^7) 5040)}\n```\n\n### Vector and Matrix\n\nWe support tesnsor algebra.\nWe use [Einstein notation](https://en.wikipedia.org/wiki/Einstein_notation) to express arithmetic operations between tensors.\n\nA tensor is expressed by enclosing its dimensions and elements with `(|` and `|)`.\n\n```\n(| <dimensions> <elements> |)\n```\n\n\n```\n> (define $V1 (| {3} {x_1 x_2 x_3} |))\n> (define $V2 (| {3} {y_1 y_2 y_3} |))\n> (. V1_i V2_i)\n(+ (* x_1 y_1) (* x_2 y_2) (* x_3 y_3))\n> (. V1_i V2_j)\n(| {3 3} {(* x_1 y_1) (* x_1 y_2) (* x_1 y_3) (* x_2 y_1) (* x_2 y_2) (* x_2 y_3) (* x_3 y_1) (* x_3 y_2) (* x_3 y_3)} |)_i_j\n```\n\n```\n> (define $M1 (generate-tensor 2#x_%1_%2 {2 2}))\n> (define $M2 (generate-tensor 2#y_%1_%2 {2 2}))\n> M1\n(| {2 2} {x_1_1 x_1_2 x_2_1 x_2_2} |)\n> M2\n(| {2 2} {y_1_1 y_1_2 y_2_1 y_2_2} |)\n> M1_i_1\n(| {2} {x_1_1 x_2_1} |)_i\n> M1_1_j\n(| {2} {x_1_1 x_1_2} |)_j\n> (. M1_i_j M2_j_k)\n(| {2 2} {(+ (* x_1_1 y_1_1) (* x_1_2 y_2_1)) (+ (* x_1_1 y_1_2) (* x_1_2 y_2_2)) (+ (* x_2_1 y_1_1) (* x_2_2 y_2_1)) (+ (* x_2_1 y_1_2) (* x_2_2 y_2_2))} |)_i_k\n> (. M1_i_j M2_k_l)\n(| {2 2 2 2} {(* x_1_1 y_1_1) (* x_1_1 y_1_2) (* x_1_1 y_2_1) (* x_1_1 y_2_2) (* x_1_2 y_1_1) (* x_1_2 y_1_2) (* x_1_2 y_2_1) (* x_1_2 y_2_2) (* x_2_1 y_1_1) (* x_2_1 y_1_2) (* x_2_1 y_2_1) (* x_2_1 y_2_2) (* x_2_2 y_1_1) (* x_2_2 y_1_2) (* x_2_2 y_2_1) (* x_2_2 y_2_2)} |)_i_j_k_l\n```\n\nAddition of tensors and arithmetic between a scalar and a tensor are expressed as follow.\n\n* [tensor.egi](https://github.com/egison/egison/blob/master/lib/math/algebra/tensor.egi)\n\n```\n> (define $X (generate-tensor 2#x_%1_%2 {2 2}))\n> (define $Y (generate-tensor 2#y_%1_%2 {2 2}))\n> X\n(| {2 2} {x_1_1 x_1_2 x_2_1 x_2_2} |)\n> Y\n(| {2 2} {y_1_1 y_1_2 y_2_1 y_2_2} |)\n> (T.map2 + X_i_j  Y_j_i)\n(| {2 2} {(+ x_1_1 y_1_1) (+ x_1_2 y_2_1) (+ x_2_1 y_1_2) (+ x_2_2 y_2_2)} |)_i_j\n> (T.+ X 100)\n(| {2 2} {(+ x_1_1 100) x_1_2 x_2_1 (+ x_2_2 100)} |)\n```\n\n### Egison Math Notebook\n\nHere are more samples.\n\n* [Egison Math Notebook](https://www.egison.org/math/)\n\n## Comparison with Related Work\n\nThere are <a target=\"_blank\" href=\"https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#Relatedwork\">a lot of existing work</a> for pattern-matching.\n\nThe advantage of Egison is that it achieves **all of the following features** at the same time.\n\n* Modularization of the way of pattern-matching for each data type\n* Pattern-matching with multiple results (backtracking)\n* Non-linear pattern-matching with **lexical scoping**\n* Parametric polymorphism of pattern-constructors\n\nThe <a target=\"_blank\" href=\"https://www.egison.org/manual/mechanism.html\">Pattern-Matching Mechanism</a> section in Egison developer's manual explains how we achieve that.\n\nPlease read <a target=\"_blank\" href=\"http://arxiv.org/abs/1407.0729\">our paper on arXiv.org</a> for details.\n\n## Installation\n\nIf you are using Linux, please install `libncurses-dev` at first.\n\n```\n% sudo apt-get install libncurses-dev # on Debian\n```\n\nTo compile Egison, you also need to install <a target=\"_blank\" href=\"https://www.haskell.org/platform/\">Haskell Platform</a>.\n\nAfter you installed Haskell Platform, run the following commands on the terminal.\n\n```\n% cabal update\n% cabal install egison\n```\n\nNow, you can try Egison.\n\n```\n% egison\nEgison Version X.X.X(C) 2011-2014 Satoshi Egi\nhttps://www.egison.org\nWelcome to Egison Interpreter!\n> ^D\nLeaving Egison Interpreter.\n```\n\nIf you are a beginner of Egison, it would be better to install <a target=\"_blank\" href=\"https://github.com/egison/egison-tutorial\">`egison-tutorial`</a>.\n\n```\n% cabal update\n% cabal install egison-tutorial\n% egison-tutorial\nEgison Tutorial Version 3.3.6 (C) 2013-2014 Satoshi Egi\nWelcome to Egison Tutorial!\n** Information **\nWe can use a 'Tab' key to complete keywords on the interpreter.\nIf we type a 'Tab' key after a closed parenthesis, the next closed parenthesis will be completed.\n*****************\n==============================\nList of sections in the tutorial.\n1: Calculate numbers                             (10 minutes)\n2: Basics of functional programming              (10 minutes)\n3: Basics of pattern-matching                    (10 minutes)\n4: Pattern-matching against infinite collections (5 minutes)\n==============================\nChoose a section to learn.\n(1-4): 1\n====================\nWe can do arithmetic operations with '+', '-', '*', '/', 'modulo' and 'power'.\n\nExamples:\n  (+ 1 2)\n  (- 30 15)\n  (* 10 20)\n  (/ 20 5)\n  (modulo 17 4)\n  (power 2 10)\n====================\n>\n```\n\nWe can try it also <a target=\"_blank\" href=\"http://try.egison.org\">online</a>.\nEnjoy!\n\n## Note for Developers\n\n### How to Run Test\n\n```\n% cabal test\n```\n\n### How to Profile the Interpreter\n\n```\n% sudo apt-get install haskell-platform-doc haskell-platform-prof\n% cabal install --enable-library-profiling --enable-executable-profiling\n% egison +RTS -p -RTS -l sample/sequence.egi\n% cat egison.prof\n```\n\n## Community\n\nWe have <a target=\"_blank\" href=\"https://www.egison.org/community.html\">a mailing list</a>.\nPlease join us!\n\nWe are on <a target=\"_blank\" href=\"https://twitter.com/Egison_Lang\">Twitter</a>.\nPlease follow us.\n\n## Acknowledgement\n\nI thank Ryo Tanaka, Takahisa Watanabe, Takuya Kuwahara and Kentaro Honda for their help to implement the interpreter.\n\n## License\n\nCopyright (c) 2011-2016, Satoshi Egi\n\nEgison is released under the [MIT license](https://github.com/egison/egison/blob/master/LICENSE).\n\nI used [husk-scheme](http://justinethier.github.io/husk-scheme/) by Justin Ethier as reference to implement the base part of the previous version of the interpreter.\n\n## Sponsors\n\nEgison is sponsored by [Rakuten, Inc.](http://global.rakuten.com/corp/) and [Rakuten Institute of Technology](http://rit.rakuten.co.jp/).\n", 
  "id": 8212790
}
{
  "id": 3676375, 
  "read_at": 1462547177, 
  "README.rst": "************************\nmatlab-science-functions\n************************\n\n:Date: March 9, 2012\n:Version: 0.4\n:Authors: Berian James\n:Web site: https://github.com/berianjames/matlab-science-functions\n:Copyright: This document has been placed in the public domain.\n:License: This code is released under the MIT license.\n\n===========================\nMatlab scientific functions\n===========================\n\nThis repository holds a set of short functions that aid scientific programming and data analysis in Matlab. Some of them implement routines that are similar to code that exists elsewhere, and I try to indicate this when I can. Many are not readily available elsewhere. \n\nIndex\n=====\n\n* halokit - A cosmological halo modelling library \n\n* PolynomialDivision - routines for polynomial division\n* numericaltools - general numerical support routines\n* plottingtools - plot tweaking routines\n* scientifictools - scientific routines\n\nhalokit - halo modelling in cosmology\n=====================================\n\nA suite of functions for performing analysis of cosmological data measurements of galaxy clustering, using the formalism known as the halo model. Built to be self-contained, the library takes a cosmological parameter set, a redshift and halo masses as input and computes the power spectrum and correlation function of dark matter, the density profile of dark matter haloes and the combined clustering statistics associated with these bodies.\n\nDetailed documentation is provided in the docstrings to the functions. The best way to get started is to dive in with HaloDriver, which is a script interface calling routines in the library.\n\nThis library was reimplemented in Python as PyHalo, but is provided for Matlab users who will find it of interest. PyHalo itself was extended substantially by Henrik Brink (brinkar).\n\nPolynomialDivision\n==================\n\nContains two functions for performing division on polynomials: one is for division over the integers and the other is over the integers mod n. These scripts were written to help with analysis of torus knots in knot theory, as published in [C11]_.\n\nPolynomialDivision\n------------------\n\n  [quot,rem] = PolynomialDivision(coeffs,div)`\n\nPolynomials are represented as vectors of coefficients, going from x^n down to x^0. E.g., x^3 + 2x + 4 :: [1 0 2 4]\n\nThis routine calculates quotient and remainder such that coeffs / div = quot + rem / div\n\nPolynomialDivisionMod\n---------------------\n\n  [quot,rem] = PolynomialDivisionMod(coeffs,div,n)`\n\nPerforms polynomial division with the integers mod n.\n\n\n.. [C11] Collins, Julia (2011), The L^2 signature of torus knots, http://arxiv.org/abs/1001.1329\n\nnumericaltools\n==============\n\nThese are a set of numerical functions I use commonly in analysing data. There is some overlap with scientifictools---the distinction is mostly that these functions are shorter and deployed more frequently.\n\nbisect\n------\nImplementation of 1-d bisection, written as an exericse, but used frequently.\n\nInput\n  array (vector of scalar values)\n  values (vector of bisection locations to find)\n\nOutput \n  index (vector of bisection indices)\n\n\ngaussian, gaussian2, gaussian3, gaussian3b\n------------------------------------------\n\nConstruct one-, two- and three-dimensional isotropic gaussian, and three-dimensional anisotropic gaussian (3b). Styled on code from within the Mathworks distribution.\n\nInput \n  field (1-, 2- or 3-d array of scalar values)\n  width (scalar or 3-vector (gaussian3b), representing smoothing width)\n\nhist2, hist3, whist2\n--------------------\nTwo- and three-dimensional histogramming from data coordinates, and weighted two-dimensional histogramming.\n\n  n = hist2(data,[nx,ny,w,[xmin xmax ymin ymax]])\n\nInputs\n  data (n x 2 vector of x,y values, n x 3 in hist3),\n  nx, ny (integers, number of bins in the x- and y-directions,\n  [in whist2] w (n-vector, weights for each data point),\n  xmin, xmax, ymin, ymax (floats, limits on x and y),\n  [in hist3] nz (bins in z-direction),\n  [in hist3] zmin, zmax (limits in z-direction)\n\nOutput\n  counts (two- or three-dimensional histogram)\n\nsmooth, smooth2, smooth3b\n-------------------------\n\n1-, 2- and 3-D Gaussian smoothing using FFT.\n\nInput\n  input (vector of scalar values),\n  width (float, width of smoothing, in pixels),\n  padding (integer, number of cells to pad with zeros)    \n\nOutput\n  vector of smoothed scalar values, same size as original\n\nplottingtools\n=============\n\nA set of short snippets I use ubiquitously in producing plots for papers. \n\nimageplot and imageplot_smooth\n------------------------------\n\n   [counts,h] = imageplot(x,y,res);\n\nimageplot snippet to return and plot a two-dimension histogram from (x,y) data and imageplot the result, scaling and inverting the colormap to give black counts on a white background. Uses hist2 from numericaltools.\n\nInput\n  x (vector),\n  y (vector),\n  res (scalar or 2-vector)\n\nOutput \n  counts (2-d array), plot handle\n\nlogaxislabels\n-------------\n\n   logaxislabels(Axis)\n\nModifies labels on a logarithmic axis to display as, e.g., 0.01 instead of 10^2. Looks a bit more professional, really.\n\nInput\n  Axis (axis handle)\n\nprep_fig\n--------\n\nPrepares a simple Matlab plot figure for exporting (with exportfig, say). This amounts to making the axis ticks larger, adding labels.\n\nInput\n  handle (figure handle), xlab, ylab (strings for x- and y-labels, with $math$ to be parsed by LaTeX, fsize (integer font size)\n\nscientifictools\n===============\n\nThese are more specialist functions that I have used in research relating to the statistics of gaussian random fields. \n\ngrfPk\n-----\n\n   A = grfPk(N,L,Pfn)\n\nGenerates mean-zero three-dimensional Gaussian random field on an N^3 grid, of physical length scale L (per side), with power spectrum specified by the function handle Pfn. \n\nThis routine operates by creating a random field of the size of the output and Fourier transforming it to generate Hermitian symmetry pairs. With that done, the Fourier space field has its phases set to be $U[0,2\\pi)$ and amplitudes set to be Rayleigh distributed with parameter $\\sqrt(P(k)/2)$. This field has the Hermitian symmetry applied and is inverted back to configuration space, yielding a real-valued field with the desired power spectrum.\n\nIf no power spectrum is supplied, a power law with index 0.96 is used, inspired by the primoridial cosmological power spectrum.\n\nInput\n   N (1- or 3-vector, box size in pixels)\n   L (1- or 3-vector, box size in physical units)\n   Pfn (function handle that returns P(k) for input k)\n\nOutput\n   A (3-dimensional real-valued gaussian random array with power spectrum P(k))\n\nHermitePolyGen\n--------------\n\nReturns a vector representing coefficients of the Hermite polynomial of degree n. Extends the HermitePoly routine of David Terr to allow for both the probabilists' and physicists' defintions of the Hermite polynomials, as described in [W12]_.\n\nInput\n   n (integer, order of Hermite polynomial)\n   def (string, either 'prob' or 'phys')\n\nOutput\n   hk ( (n+1)-vector of polynomial coefficients)\n\nHermiteFunction\n---------------\n\nReturns a vector of the values of Hermite function of order $n$ at locations $x$, using either the probabilists' and physicists' defintions of the Hermite polynomial, as discussed in [W12]_. See also section 7.1 of that article for the definition and applications of the Hermite functions.\n\nInput\n   n (integer, order of Hermite function)\n   x (abscissa at which the Hermite function values are returned\n   def (string, either 'prob' or 'phys')\n\nOutput\n   y (vector of length len(x) of Hermite function values).\n\n.. [W12] See `http://en.wikipedia.org/wiki/Hermite_polynomials#Definition`\n", 
  "description": "Short utility functions for use in scientific research"
}
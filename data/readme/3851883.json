{
  "read_at": 1462547161, 
  "description": "Efficient exact cover solver", 
  "README.md": "Dancing Links\n=============\n\nThis is an efficient C++ implementation of Algorithm DLX from Knuth's *Dancing\nLinks* paper for the exact cover problem.\n\nKnuth's paper gives a very readable explanation of the problem, the algorithm,\nand several applications. I think it's still the best place to start.\nhttp://arxiv.org/pdf/cs/0011047v1.pdf\n\nImplementation\n==============\n\nThe implementation consists of a few classes defined under\n[include/dlx/](include/dlx/) and [src/](src/). There is no documentation at the\nmoment, so take a look at the examples.\n\n`dlx` can also solve generalized exact cover problems (see Knuth's paper). The\ncolumns of the matrix should be sorted so that all secondary columns are on the\nleft, before primary columns. N-queens is a good example of this.\n\nExample: dlx\n============\n\n[example/dlx](example/dlx) is a simple command-line program that reads an exact\ncover problem from stdin and solves it.\n\nThe first line of stdin contains the number of columns, and the following lines\ncontain the rows of the matrix.\n\nOutput can be controlled by flags. By default, only the number of solutions is\nprinted. If `-p` is given, every solution is printed on its own line by giving\nthe indices of the selected rows. With `-v`, the full rows are printed.\n\n<big><pre>\n$ make examples\n$ ./build/dlx -pv < [data/knuth\\_example.txt](data/knuth_example.txt)\n1 0 0 1 0 0 0\n0 0 1 0 1 1 0\n0 1 0 0 0 0 1<br><br>solutions: 1\n</pre></big>\n\nWith `-s`, input can be given as a sparse matrix.\n\n<big><pre>\n$ ./build/dlx -ps < [data/knuth\\_example\\_sparse.txt](data/knuth_example_sparse.txt)\n3 0 4\nsolutions: 1\n</pre></big>\n\nTo solve a generalized exact cover problem, put the number of secondary columns\non the first line, after the number of all columns. The default value is zero,\nin other words, a regular exact cover problem.\n\n<big><pre>\n$ ./build/dlx -pv < [data/generalized\\_example.txt](data/generalized_example.txt)\n0 1 1<br><br>solutions: 1\n</pre></big>\n\nExample: Sudoku\n===============\n\nThis program can solve and generate various types of Sudokus. See\n[example/sudoku/README.md](example/sudoku/README.md) for details.\n\n<big><pre>\n$ make examples\n$ ./build/sudoku < [data/sudoku.txt](data/sudoku.txt)\n[output](https://gist.github.com/jlaire/4429d93d016b73ef6511)\n</pre></big>\n\nExample: N-queens\n=================\n\nPlace N queens on an NxN chessboard so that they don't attack each other. This\nis a good example of a generalized exact cover problem: each diagonal must\ncontain *at most* one queen, but zero is ok.\n\n```\n$ make examples\n$ ./build/nqueens 8 12\nSolutions for n=8: 92\nSolutions for n=12: 14200\n```\n\n```\n$ ./build/nqueens -v 1 2 3 4\nSolutions for n=1: 1\nQ\n\nSolutions for n=2: 0\nSolutions for n=3: 0\nSolutions for n=4: 2\n..Q.\nQ...\n...Q\n.Q..\n\n.Q..\n...Q\nQ...\n..Q.\n```\n\nExample: Langford pairings\n==========================\n\nSee [Wikipedia](https://en.wikipedia.org/wiki/Langford_pairing).\n\n    $ make examples\n    $ ./build/langford -v 1 2 3 4 5\n    Solutions for n = 1: 0\n    Solutions for n = 2: 0\n    Solutions for n = 3: 1\n    3 1 2 1 3 2\n    Solutions for n = 4: 1\n    4 1 3 1 2 4 3 2\n    Solutions for n = 5: 0\n\nExample: N-pieces\n=================\n\nGeneralized version of N-queens: place N knights and Q queens on an AxB board.\nQuite slow, unfortunately.\n\n    $ make examples\n    $ ./build/npieces 8 8 5 5\n    Solutions for 8x8, N=5, Q=5: 16\n    NN......\n    ....Q...\n    ......Q.\n    NN......\n    N.......\n    .......Q\n    .....Q..\n    ..Q.....\n    <snip>\n\nExample: Polyominoes\n====================\n\nThe code can solve any polyomino puzzle, but for now the executable simply\nprints all solutions to Scott's pentomino problem:\n\n    $ make examples\n    $ ./build/polyomino | head -n8\n    LLXCCVVV\n    LXXXCVZZ\n    LNXCCVZY\n    LNT  ZZY\n    NNT  WYY\n    NTTTWWFY\n    PPPWWFFF\n    PPIIIIIF\n\nTODO\n====\n\n  - ExactCoverProblem: Export in Knuth's format for benchmarking.\n  - AlgorithmDLX: Option to estimate the search tree with Monte Carlo.\n  - All examples: Option to export the exact cover problem. A hacky solution\n    would be an environment variable that enables this within the dlx library\n    itself.\n  - CMake\n  - Polyomino: Find unique solutions.\n  - More examples:\n    * Latin squares (Knuth, volume 4a)\n", 
  "id": 3851883
}
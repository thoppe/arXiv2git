{
  "read_at": 1462552131, 
  "description": "Support for OI-FITS (optical interferometry data format) in Julia.", 
  "README.md": "# OIFITS.jl\n\nThe `OIFITS.jl` package provides support for OI-FITS data in Julia language.\nThe support for the actual FITS files is provided by the\n[`FITSIO.jl`](https://github.com/JuliaAstro/FITSIO.jl) package.\n\n\n## OI-FITS Summary\n\nOI-FITS is a standard to store optical interferometry data as a collection of\ndata-blocks.  In the first version of the standard (see [Ref. 1](#references)),\nthe available data-blocks are:\n\n* `OI_TARGET` provides a list of observed targets;\n* `OI_ARRAY` describes a given array of stations;\n* `OI_WAVELENGTH` describes a given instrument (notably the effective\n  wavelengths and bandwidths of its spectral channels);\n* `OI_VIS` contains complex visibility data;\n* `OI_VIS2` contains squared visibility (powerspectrum) data;\n* `OI_T3` contains triple product (bispectrum) data.\n\nThese data-blocks, are stored as binary tables in a FITS data file.\n\n\n## Installation\n\nOIFITS is a [registered Julia package](http://pkg.julialang.org/), the\ninstallation is as simple as:\n```julia\nPkg.add(\"OIFITS\")\nPkg.update()\n```\nThe last command `Pkg.update()` may be unnecessary.\n\n\n## Typical usage\n\nLoading an OI-FITS data file:\n```julia\nusing OIFITS\nmaster = OIFITS.load(\"testdata.oifits\")\n```\n\nTo iterate through all data-blocks:\n```julia\nfor db in master\n    dbname = OIFITS.get_dbname(db)\n    revn = OIFITS.get_revn(db)\n    println(\"Data block is $dbname, revision $revn\")\nend\n```\n\nTo iterate through a sub-set of the data-blocks (here the complex visibility\ndata, the powerspectrum data and the bispectrum data):\n```julia\nfor db in OIFITS.select(master, \"OI_VIS\", \"OI_VIS2\", \"OI_T3\")\n    dbname = OIFITS.get_dbname(db)\n    n = length(OIFITS.get_time(db))\n    println(\"Data block is $dbname, number of exposures is $n\")\nend\n```\n\n\n## Accessor functions\n\nAny OI-FITS field (keyword/column) of a given data-block can be retrieved\nvia an accessor whose name has suffix `OIFITS.get_` followed by the name of\nthe field (in lower case letters and with all non-letter and all non-digit\nletters replaced by the underscore character `'_'`).  A notable exception is\nthe revision number corresponding to the keyword \"OI_REVN\" which is\nretrieved with the method `OIFITS.get_revn()`.  For instance:\n\n```julia\nOIFITS.get_revn(db)      # get the revison number of the format (OI_REVN)\nOIFITS.get_eff_wave(db)  # get effective wavelengths (EFF_WAVE)\nOIFITS.get_eff_band(db)  # get effective bandwidths (EFF_BAND)\nOIFITS.get_ucoord(db)    # get the U coordinates of the data (UCOORD)\n```\nOf course, getting a given field must make sense.  For instance,\n`OIFITS.get_eff_wave()` can be applied on any `OI_WAVELENGTH` data-blocks\nbut also on data-blocks which contains interferometric data such as\n`OI_VIS`, `OI_VIS2`, `OI_T3`, *etc.* but not on other data-blocks like\n`OI_TARGET`.\n\n\n## Reading data\n\nTo load the contents of an OI-FITS file in memory, use:\n```julia\nmaster = OIFITS.load(filename)\n```\nwhere `filename` is the name of the file and the returned value, `master`,\ncontains all the OI-FITS data-blocks of the file.  You may have the names\nof the data blocks printed as they get read with keyword `quiet=false`:\n```julia\nmaster = OIFITS.load(filename, quiet=false)\n```\nIf you already have a `FITS` handle to the data, you can use it as the\nargument to `OIFITS.load` in place of the file name.\n\n\n## Constructors\n\nIt is possible to build OI-FITS data-blocks individually.  The general\nsyntax is:\n```julia\nOIFITS.new_XXX(KEY1=VAL1, KEY2=VAL2, ...)\n```\nwhere `XXX` is the type of the data-block and `KEYn=VALn` constructions\ngive the fields of the data-block and their values.  The names of the\nfields follow the same convention as for the field accessors.\n\nAvailable data-block constructors are:\n\n* `OIFITS.new_target` => `OI_TARGET`\n* `OIFITS.new_array` => `OI_ARRAY`\n* `OIFITS.new_wavelength` => `OI_WAVELENGTH`\n* `OIFITS.new_vis`  => `OI_VIS`\n* `OIFITS.new_vis2` => `OI_VIS2`\n* `OIFITS.new_t3`   => `OI_T3`\n\nWhen defining a new data-block, all mandatory fields must be provided.\nFor instance, to create an `OI_WAVELENGTH` data-block:\n```julia\num = 1e-6  # all values are in SI units in OI-FITS\ndb = OIFITS.new_wavelength(insname=\"Amber\",\n                           eff_wave=[1.4um,1.6um,1.8um],\n                           eff_band=[0.2um,0.2um,0.2um])\n```\nNote that the revision number (`revn=...`) can be omitted; by default, the\nhighest defined revision will be used.\n\nA consistent set of OI-FITS data-blocks is made of: exactly one `OI_TARGET`\ndata-block, one or more `OI_WAVELENGTH` data-blocks, one or more `OI_ARRAY`\ndata-blocks and any number of data-blocks with interferometric data\n(`OI_VIS`, `OI_VIS2` or `OI_T3`).  These data-blocks must be stored in a\ncontainer created by:\n```julia\nmaster = OIFITS.new_master()\n```\nThen, call:\n```julia\nOIFITS.attach(master, db)\n```\nto attach all data-block `db` to the OI-FITS container (in any order).\nFinally, you must call:\n```julia\nOIFITS.update(master)\n```\nto update internal information such as links between data-blocks with\ninterferometric data and the related instrument (`OI_WAVELENGTH`\ndata-block) and array of stations (`OI_ARRAY` data-block).  If you do not\ndo that, then applying some accessors may not work, *e.g.*\n`OIFITS.get_eff_wave()` on a data-blocks with interferometric data.\n\nTo read an OI-FITS data-block from the HDU of a FITS file:\n```julia\ndb = OIFITS.read_datablock(hdu)\n```\nwhere `hdu` is a `HDU` handle.  The result may be `nothing` if the\ncurrent HDU does not contain an OI-FITS data-block.\n\n\n## Miscellaneous functions\n\nOI-FITS implements some useful functions which can be used to deal with\nFITS file (not just OI-FITS ones).  These functions could be part of `FITSIO`\npackage.\n\n\n### Retrieving information from the header of a FITS HDU\n\nThe header of a FITS HDU can be read with the function:\n```julia\nfts = FITS(filename)\nhdr = FITSIO.read_header(fts[1])\n```\nwhich returns an indexable and iterable object, here `hdr`.  The keys of\n`hdr` are the FITS keywords of the header.  For instance:\n```julia\nkeys(hdr)          # yield an iterator on the keys of hdr\ncollect(keys(hdr)) # yield all the keys of hdr\nhaskey(hdr, key)   # check whether key is present\nhdr[key]           # retrieve the contents associated with the key\n```\nFor commentary FITS keywords (`\"HISTORY\"` or `\"COMMENT\"`), there is no\nvalue, just a comment but there may be any number of these *commentary*\nkeywords.  Other keywords must be unique and thus have a scalar value.  Use\n`get_comment` to retrieve the comment of a FITS keyword:\n```julia\nget_comment(hdr, key)keys(hdr)          # yield an iterator on the keys of hdr\ncollect(keys(hdr)) # yield all the keys of hdr\nhaskey(hdr, key)   # check whether key is present\nhdr[key]           # retrieve the contents associated with the key\n```\n\n*OIFITS* provides method `OIFITS.get_value()` and `OIFITS.get_comment()`\nmethod to retrieve the value and comment (respectively) of a FITS keyword\nwith type checking and, optionaly, let you provide a default value if the\nkeyword is absent:\n```julia\nval = OIFITS.get_value(hdr, key)\nval = OIFITS.get_value(hdr, key, def)\ncom = OIFITS.get_comment(hdr, key)\ncom = OIFITS.get_comment(hdr, key, def)\n```\nTo retrieve a value and make sure it has a specific type, the following\nmethods are available:\n```julia\nOIFITS.get_logical(hdr, \"SIMPLE\")\nOIFITS.get_integer(hdr, \"BITPIX\")\nOIFITS.get_real(hdr, \"BSCALE\")\nOIFITS.get_string(hdr, \"XTENSION\")\n```\nwhich throw an error if the keyword is not present and perform type\nchecking and conversion if allowed.  It is also possible to supply a\ndefault value to return if the keyword is not present:\n```julia\nbscale = OIFITS.get_real(hdr, \"BSCALE\", 1.0)\nbzero = OIFITS.get_real(hdr, \"BZERO\", 0.0)\nxtension = OIFITS.get_string(hdr, \"XTENSION\", \"IMAGE\")\n```\n\nThe function:\n```julia\nOIFITS.get_hdutype(hdr)\n```\nreturns the HDU type as a symbol, `:image_hdu` for an image, `:ascii_table`\nfor an ASCII table, `:binary_table` for a binary table, and `:unknown`\notherwise.\n\nFor a FITS table, the function:\n```julia\nOIFITS.get_dbtype(hdr)\n```\nreturns the OI-FITS data-block type as a symbol like `:OI_TARGET`,\n`:OI_WAVELENGTH`, *etc.*\n\n\n### Reading FITS tables\n\nIn addition to the method `read(tbl::TableHDU, colname::ASCIIString)`\nprovided by FITSIO for reading a specific column of a FITS table, the\nlow-level function:\n```julia\nOIFITS.read_column(ff::FITSFile, colnum::Integer)\n```\nreturns a Julia array with the contents of the `colnum`-th column of the\ncurrent HDU in FITS file handle `ff`.  The current HDU must be a FITS table\n(an ASCII or a binary one).  The last dimension of the result corresponds\nto the rows of the table.  It is also possible to read all the table:\n```julia\nOIFITS.read_table(ff::FITSFile)\nOIFITS.read_table(hdu::Union(TableHDU,ASCIITableHDU))\n```\nor at high-level:\n```julia\nread(hdu::Union(TableHDU,ASCIITableHDU))\n```\nThe result is a dictionary whose keys are the names of the columns (in\nuppercase letters and with trailing spaces removed).  If a column has given\nunits, the units are stored in the dictionary with suffix `\".units\"`\nappended to the column name.  For instance, the units for column `\"TIME\"`\nare accessible with key `\"TIME.units\"`.\n\n\n### FITS and Julia types conversion\n\nThe functions `cfitsio_datatype()` and `fits_bitpix()` deal with conversion\nbetween CFITSIO type code or BITPIX value and actual Julia data types.\nThey can be used as follows (assuming `T` is a Julia data type, while\n`code` and `bitpix` are integers):\n```julia\ncfitsio_datatype(T) --------> code (e.g., TBYTE, TFLOAT, etc.)\ncfitsio_datatype(code) -----> T\n\nfits_bitpix(T) -------------> bitpix (e.g., BYTE_IMG, FLOAT_IMG, etc.)\nfits_bitpix(bitpix) --------> T\n```\n\nThe functions `fits_get_coltype()` and `fits_get_eqcoltype()` yield the\ndata type, repeat count and width in bytes of a given column, their\nprototypes are:\n```julia\n(code, repcnt, width) = fits_get_coltype(ff::FITSFile, colnum::Integer)\n(code, repcnt, width) = fits_get_eqcoltype(ff::FITSFile, colnum::Integer)\n```\nwith `colnum` the column number, `code` the CFITSIO column type (call\n`cfitsio_datatype(code)` to convert it to a Julia type) of the elements in\nthis column, `repcnt` and `width` the repeat count and width of a cell in\nthis column.  The difference between `fits_get_coltype()` and\n`fits_get_eqcoltype()` is that the former yields the column type as it is\nstored in the file, while the latter yields the column type after automatic\nscaling by the values `\"TSCALn\"` and `\"TZEROn\"` keywods if present (with\n`n` the column number).  Note that reading the column data with\n`fits_read_col()` or `fitsio_read_column()` automatically apply this kind\nof scaling.\n\nTo retrieve the dimensions of the cells in a given column, call the\nfunction `fits_read_tdim()`, its prototype is:\n```julia\ndims = fits_read_tdim(ff::FITSFile, colnum::Integer)\n```\nwhere `dims` is a vector of integer dimensions.\n\n\n## Credits\n\nThe developments of this package has received funding from the European\nCommunity's Seventh Framework Programme (FP7/2013-2016) under Grant\nAgreement 312430 (OPTICON).\n\n\n## References\n\n1. Pauls, T. A., Young, J. S., Cotton, W. D., & Monnier, J. D. \"A data exchange\n   standard for optical (visible/IR) interferometry.\" Publications of the\n   Astronomical Society of the Pacific, vol. 117, no 837, p. 1255 (2005).\n   [[pdf]](http://arxiv.org/pdf/astro-ph/0508185)\n\n2. Duvert, G., Young, J., & Hummel, C. \"OIFITS 2: the 2nd version of the Data\n   Exchange Standard for Optical (Visible/IR) Interferometry.\" arXiv preprint\n   [[arXiv:1510.04556v2.04556]](http://arxiv.org/abs/1510.04556v2).\n", 
  "id": 31301739
}
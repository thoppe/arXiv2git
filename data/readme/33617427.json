{
  "read_at": 1462511959, 
  "description": "Model checkers for various spatial logics based on topological spaces and closure spaces", 
  "README.md": "Topochecker: a topological model checker\n========================================\n\nTopochecker is a spatio-temporal model checker based on closure spaces\nand Kripke frames. Currently it checks a spatial extension of CTL\nnamed STLCS (spatio-temporal logic of closure spaces).\n\nSpatio-temporal model checking\n==============================\n\nSpatio-temporal model checking is perforemd with a variant of\nComputation Tree Logic (CTL) featuring spatial operators coming from the\ntradition of topological spatial logics.\n\nCTL is widely known. See e.g.:\n\nhttps://mitpress.mit.edu/books/principles-model-checking\n\nThe spatial operators come from the Spatial Logic of Closure Spaces\n(SLCS), of which you can read in the following paper:\n\nhttp://link.springer.com/chapter/10.1007%2F978-3-662-44602-7_18\n\nhttp://arxiv.org/abs/1406.6393\n\nhttps://raw.githubusercontent.com/vincenzoml/topochecker/master/doc/specifying_and_verifying_properties_of_space.pdf\n\nThe used algorithm is an extension of both CTL and SLCS model checking, described in a paper (to appear in VERY* 2015 @ SEFM):\n\nhttps://raw.githubusercontent.com/vincenzoml/topochecker/master/doc/an_experimental_spatio-temporal_model_checker.pdf\n\nFor an introduction to topological spatial logics see\n\nhttp://www.springer.com/us/book/9781402055867\n\n\nQuick installation for the impatient running a debian-based distribution\n========================================================================\n\nOpen a terminal and run the following four commands:\n\n```\nsudo apt-get install git ocaml-native-compilers libcsv-ocaml-dev libocamlgraph-ocaml-dev\ngit clone https://github.com/vincenzoml/topochecker.git \ncd topochecker\nmake\n```\n\nOptionally, type\n\n```\nmake all\n```\n\nto also build the examples (some of them take plenty of space-time!)\n\nPrerequisites\n=============\n\nThe program is cross-platform. Prerequisites for compilation are:\n\n- ocaml (best to use optimizing compiler ocamlopt.opt)\n- the ocamlgraph library\n- the ocamlcsv library\n\n\nInstalling prerequisites on ubuntu\n----------------------------------\n\ninstall the following packages using apt:\n\n`ocaml ocaml-native-compilers libocamlgraph-ocaml-dev libcsv-ocaml-dev`\n\n\nInstalling prerequisites on OSX\n-------------------------------\n\nthere may be more than one way, however the quickest path is to\ninstall OPAM (e.g., from macports, ocamlbrew of from source):\n\nhttps://opam.ocaml.org/doc/Install.html\n\nand then install all the required dependencies using it:\n\n```\nopam init\nopam install ocamlfind\nopam install csv\nopam install ocamlgraph\n```\n\nCompiling topochecker\n=====================\n\nSimply run\n\n`make`\n\nYou can also use\n\n`make all`\n\nwill also run the model checker on the examples in\nthe examples subdirectory.\n\nBIG NOTE: topochecker uses ocamlbuild to build the tool, which\nautomatically handles dependencies; if ocamlbuild is not available,\nthe tool falls back to old-style makefile dependencies. If you have\ntroubles with ocamlbuild and want to use makefile dependencies, run\n\"make slow\" in the tool directory; you can make that the default\ntarget in the makefile; see the comment in src/Makefile for that.\n\n\nUsage\n=====\n\nUsage:\n\n`topochecker EXPERIMENT_FILENAME`\n\nThis will run the model checker on an experiment described by the file\nat EXPERIMENT_FILENAME\n\n\nServer mode\n===========\n\nBelow, a long explanation of the syntax of experiments is\ngiven. However, if no output file is specified, and no commands are\ngiven, the system will run in \"servere mode\". In this mode,\ntopochecker will wait for input on stdin. The only command accepted is:\n\n`Ask \"ID\" QFORMULA;\n`Ask \"ID\" { \"ID1\", ... , \"IDn\" } QFORMULA;\n\nID is a string; QFORMULA is a quantitative formula, with syntax described later in this document. Result is a floating point value <VALUE> which is printed on stdout in the format \"ID: <VALUE>\". The optional list of identifiers in curly braces specifies a set of ids of space points; if such list is specified, then all counting formulas are restricted to the specified points (for example, if only one point is specified, then the result of a counting formula is either 0.0 or 1.0).\n\nSyntax of experiment description files\n======================================\n\nEXPERIMENT_FILENAME, usually with \".topochecker\" extension, consists\nof a model declaration, an optional macro declaration part, and a\n\"commands\" part (see files with extension .topochecker in the\nexamples).\n\nComments\n--------\n\nComments can be introduced by \"//\"; everything from \"//\" to the end of\na line is ignored by the model checker.\n\n\nModel declaration\n-----------------\n\n\nDot file format:\n----------------\n\nModel declaration takes the form:\n\n`Kripke \"kripke.dot\" Space \"space.dot\" Eval \"eval.csv\";`\n\nWhere \"kripke.dot\" \"space.dot\" and \"eval.csv\" are file names.\n\n\"kripke.dot\" is a dot file containing a directed unlabelled graph,\nrepresenting a Kripke frame. Node ids must be numbers starting at 0\nand with no gaps. The Kripke frame is completed by adding self-loops\nto all nodes whose number of outgoing edges is 0.\n\n\"space.dot\" is a dot file containing a directed unlabelled graph,\nrepresenting space.\n\nBoth graphs can be weighted; to achieve this, just add a property\n\"weight=n\" to each edge, where n is a float; the default value for n\nis 1.0.\n\n\"eval.csv\" is a csv file, with three or more columns. Each row takes\nthe form\n\n`state point prop1 prop2 ... propN`\n\nwhere state is a node id in kripke.dot, space is a node id in\nspace.dot, and prop1 ... propN are strings (at least one must be\npresent) that are used as atomic propositions associated to state\n\"state\" and point \"point\", giving rise to a spatio-temporal model;\nalternatively, each of prop1 ... propN may be in the form string=int,\nassociating a quantity to a proposition. Actually, the first form is a\nshorthand for string=1, and omitting a string makes its value equal to\n0. Note that each pair of state and point id can be repeated many\ntimes, if needed; different atomic propositions will be accepted in\ndifferent rows. However, for numeric values of atomic propositions, no\ncombination is done. The first value found in the csv is the one\naccepted for the given atomic proposition if more than one row for the\nsame pair of ids, and the same atomic formula, is found.\n\nNifti medical imaging file format\n---------------------------------\n\nModel declaration takes the form\n\nSpace \"space.nifti\";\n\nThis requires medcon (open source converter for medical images) to be\navailable in the current path. The only atomic proposition is \"value\"\nand it takes numeric values used in the same way as for dot\nfiles. Output is written in raw+header file format.\n\n\nMacro declaration\n-----------------\n\nMacro declaration takes the form of a list of statements of the form\n\n`Let ide = FORMULA;`\n\nor\n\n`Let ide (arg1,...,argN) = FORMULA;`\n\n\nSyntax of commands\n------------------\n\nPossible commands are:\n\n`Check \"COLOR\" FMLA;`\n\ng(mind the semicolon!). COLOR is an integer, which can also be in hexadecimal form (0xNNNNNN); this RGB color is used to color the output for the specified formula. Colours are currently just summed for different formulas.\n\n`Output \"filename\";`\n`Output \"filename\" state1,state2,...\n\nOutputs to a set of files named \"filename-STATEID\", closing the\nprevious ones.  The output is written as OUTPUT_PREFIX-nn.dot where nn\nis replaced by the name of each state in the Kripke structure of the\nexperiment, and each file OUTPUT_PREFIX-nn.dot is a graphical\nrepresentation of the evaluation of formulas in the experiment over\nspace, in the dot file format. If a list of states is additionally\nspecified, then only these states are saved.\n\nSyntax of formulas\n------------------\n\nFormulas are described by the following syntax:\n\n```\nFMLA ::=\n         [string]                       (atomic proposition, no quotes around the string; see below for reserved names)\n       | [string OP INTEGER]\t\t(quantitative check, OP is <, <=, ==, !=, >, >=)\n       | TT                             (true)\n       | FF                             (false)\n       | FMLA & FMLA\t\t\t(and)\n       | FMLA | FMLA \t\t\t(or)\n       | (FMLA)                         (subformula)\n       | identifier                     (as declared with Let ide = FMLA)\n       | identifier(arg1,...,argN)      (as declared with Let ide(arg1,...,argN) = FMLA)\n       | N FMLA                         (near in space: reachable in one step)\n       | N^k FMLA                       (k is a number; nested application of N)\n       | I FMLA                         (dual of N: not reaching in one step)\n       | FMLA S FMLA                    (surrounded in space)\n       | E X FMLA                       (EX from CTL)\n       | A X FMLA                       (AX from CTL)\n       | E G FMLA                       (EG from CTL)            \n       | A G FMLA                       (AG from CTL)\n       | E F FMLA                       (EF from CTL)\n       | A F FMLA                       (AF from CTL)\n       | E FMLA U FMLA                  (EU from CTL)\n       | A FMLA U FMLA                  (AU from CTL)\n```\n\nQuantitative formulas are described by the following syntax\n\nQFMLA ::=\n         float\t\t\t\t(floating point constant)\n       | (QFMLA)\t\t\t(subformula)\n       | QFMLA OP QFMLA \t\t(quantitative check, OP as above)\n       | # QFMLA  \t\t\t(count points in space satisfying QFMLA in state 0)\t\n\nSpecial treatment of deadlocks and reserved names of atomic propositions\n========================================================================\n\nIt may happen that there are deadlock states in a Kripke structure,\nthat is, states with no outgoing edges. In that case, usually the\nstructure is completed with self-loops to make sure that only infinite\npaths are considered. Additionally, we make such states observable, by\nadding an atomic predicate \"deadlock\" that is true only on these\nstates; this means that the name \"deadlock\" should be avoided for\natomic propositions.\n\nSee also\n========\n\nPrevious iteration of the tool, loading spatio-temporal models based\non images:\n\nhttps://github.com/cherosene/ctl_logic\n", 
  "id": 33617427
}
{
  "read_at": 1462550598, 
  "description": "A simulation of the EPR experiment", 
  "README.md": "EPR-simple\n==========\n\nA Simple event-by-event simulation of the EPR experiment\n\nHow it works:\n------------\nThe simulation consists of a Source, generating particle pairs, to be analyzed at 2 Detection stations. The maths of the model can be summarized as:  \n\n        l = {e, p, s},  e [?] [0..2p), s = {1/2, 1}\n        p =  1/2 sin2t, t [?] [0..p/2)\n        e' = e + 2ps\n        A(a,l) = sign(-1n cos n(a - e)) if |cos n(a - e)| > p\n        B(b,l) = sign(-1n cos n(b - e')) if |cos n(b - e')| > p\n        where n = 2s\n        \n        Alternatively,  p = t, t [?] [0..p/4), k=p/2 also works well.\n\n1) The Source, and Particles:\n\n        Usage:\n\t         python source.py <duration in seconds> <spin> \n\nGenerates two files containing the emitted particles, one for each arm of the experiment.\nEach file is a gzipped binary numpy array file containing 3 columns with the rows representing the \nparameters of a single emitted particle. The files are named `SrcLeft.npy.gz` and `SrcRight.npy.gz`.\nThe source has a single parameter `spin (s)` which determines the type of particles produced. For spin 1/2 particles such as electrons, s=1/2 for photons s=1.\n\nA particle pair is generated as follows:  \n\n    `e` - an angle common to both particles selected randomly each time from the range [0, 2p)\n    `p` - a property common to both particles selected randomly according to a prescribed probability distribution\n    \nThe left particle is the tuple `(e, p, n)`\nThe right particle is the tuple `(e + 2ps, p, n)`\n\n2) The Detection Stations:  \n\n        Usage:\n\t         python station.py <ArmSrcFile> [seting1,setting2,setting3,...]\n\nReads one of the source files generated by `source.py` and generates another file\ncontaining the outcomes. The same program is run on both arms just with a different\nsource file. The input parameters are:  \n\n        `ArmSrcFile`: one of `SrcLeft.npy.gz` or `SrcRight.npy.gz`\n        `settings sequence`: optional comma separated list of settings to randomly chose between\n           for example 0,22.5,45,67.5 (no spaces between). if no sequence is provided, a sequence of\n           33 evenly spaced angles between 0 and 2p will be generated and used.\n\nThe output file will be named `Alice.npy.gz` if provided source file was `SrcLeft.npy.gz` and `Bob.npy.gz` if the provided file was `SrcRight.npy.gz`. The format of the output files are also gzipped binary numpy array files containing 2 columns. The detection at each station proceeds as follows:  \n\n    - A transformed value `C` is calculated using the particle properties and \n      the detector setting `x` as `C = -1n cos n(x - e)`. The sign and magnitude of this function is used \n      to determine which channel the particle will be detected at; `+1` or `-1`\n    - The setting `x` and the outcomes are registered locally. Each station is not aware of and \n      uses no information from or about the other station. In fact, the `SrcLeft.npy.gz` and `SrcRight.npy.gz`\n      can be copied onto separate computers disconnected from the network, and a copy of the station program run\n      on those computers to generate the output files\n      \n\nStatistical Analysis:\n--------------------    \n\n        Usage: \n\t         analyse.py <spin>\n\nThis program performs the statistical analysis of the results following the standard practice of analyzing experimental correlations for EPRB experiments. The statistics are calculated as follows. The angle difference between Alice and Bob's setting is calculated using the first column of their respective output arrays, converted to degrees and rounded to the nearest degree. For each angle in the range [0, 2p), we collect all instances where that angle difference was observed. Then we count the number of occurences of (++), (+-), (-+), (--) coincidences between the outcomes of Alice and Bob:  \n\n    - N++ : Number of pairs where Both Alice and Bob measured +1\n    - N-- : ...  Both Alice and Bob measured -1\n    - N+- : ...  Alice got +1 and Bob got -1\n    - N-+ : ...  Alice got -1 and Bob got +1\n    - nA+ : ...  Alice got +1\n    - nB+ : ...  Bob got +1\n\nFrom these counts, we calcualte the individual probabilities:  \n\n    Pj = Nj/(N++ + N-- + N+- + N-+), ij [?] {++, --, +-, -+}\n    \nThe probability for single sided results A and B are calculated:  \n\n    pA = nA/(nA+ + nA-), pB = nB/(nB+ + nB-), i[?] {+,-}\n    \nFrom these probabilities we can calcualte the Expectation value:  \n\n    E(a,b) = P++ + P-- - P+- - P-+   \n\nThe results are then plotted for every angle pair (a,b) in the range [0, 2p). A sample plot after a 60 second simulation is shown in the file `analysis.png`. The output for the Bell-test angles (0, 22.5, 45, 67.5) are shown below:  \n\n\n    Expectation values\n      Settings       N_ab   <AB>_sim    <AB>_qm StdErr_sim\n       0, 22.5       1534     -0.934     -0.924      0.024\n       0, 67.5       1364     -0.391     -0.383      0.011\n      45, 22.5       1510     -0.926     -0.924      0.024\n      45, 67.5       1532     -0.943     -0.924      0.024\n\n\tSame Angle <AB> = -1.00\n\tOppo Angle <AB> = +1.00\n\tCHSH: <= 2.0, Sim: 2.410, QM: 2.389\n    \n\n\nNotes:\n-----\n\nEach particle is treated separately from the source to detection in a completely local and realistic manner. In fact the whole simulation can be performed on separate computers as illustrated above, with the analysis performed on a fourth computer. A typical run of a \"separate computer\" version of the simulation would look like the following:  \n\n    Computer 1: python source.py 60 0.5  \n        -Copy SrcLeft.npy.gz to computer 2  \n        -Copy SrcRight.npy.gz to computer 3  \n    Computer 2: python station.py SrcLeft.npy.gz  \n    Computer 3: python station.py SrcRight.npy.gz  \n        -Copy Alice.npy.gz from computer 2 to computer 4  \n        -Copy SrcRight.npy.gz from computer 3 to computer 4  \n    Computer 4: python analyse.py 0.5  \n\n\n\nEach detection station behaves exactly the same as the other. Swapping the particles and sending them the opposite way does not change the results.\n\nThe model reproduces *almost* exactly the QM correlation for both electrons and photons\nand matches experimental data very well. See http://arxiv.org/pdf/quant-ph/0606122.pdf (Fig 1).\n\nObviously the model would \"violate\" the CHSH inequality in the same way as QM predictions and experimental expectation values. More careful study of the inequalities actually reveal that such violation by QM, experiments, and simulations like this are only apparent.\n\nTo run the simulation yourself, start by running the source for a shorter time period, say 10s. This version of the simulation uses all the CPU cores available on your computer to run faster. Longer runs may require a lot of memory. Running the source for 10 seconds will produce files that can be processed at each station for roughly the same amount of time. On any Linux system, you need to have `matplotlib` installed for the plotting, as well as `numpy`. I haven't tested on Windows but you probably want a \"batteries-included\" python distribution such as \"Python xy\" http://code.google.com/p/pythonxy/. \n", 
  "id": 13941560
}
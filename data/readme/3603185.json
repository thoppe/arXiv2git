{
  "read_at": 1462547156, 
  "description": "Saves a tree in a table, fast. Official version moved to https://github.com/grzlus/acts_as_nested_interval", 
  "README.md": "# ActsAsNestedInterval [![Build Status](https://secure.travis-ci.org/clyfe/acts_as_nested_interval.png)](http://travis-ci.org/clyfe/acts_as_nested_interval)\n\n## About\n\nThis act implements a nested-interval tree.  \nYou can find all descendants or all ancestors with just one select query.  \nYou can insert and delete records without\na full table update (compared to nested set, where at insert, half the table is updated on average).\n\nMake sure you really need this, otherwise give a look to https://github.com/stefankroes/ancestry ,\nthat implements a simpler encoding model (variant of materialized path).  \n\nIf your database supports recursive queryes (`WITH RECURSIVE`) or specific custom extensions\n(`CONNECT BY`, ltree) and you don't need portability, you're probably better off using those.\n\n\n## Install\n\n```ruby\n# add to Gemfile\ngem 'acts_as_nested_interval'\n```\n\n```sh\n# install\nbundle install\n```\n\nRequires a `parent_id` foreign key column, and `lftp` and `lftq` integer columns.  \nIf your database does not support stored procedures then you also need `rgtp` and `rgtq` integer columns.  \nIf your database does not support functional indexes then you also need a `rgt` float column.  \nThe `lft` float column is optional.  \n\nExample:\n\n```ruby\ncreate_table :regions do |t|\n  t.integer :parent_id\n  t.integer :lftp, null: false\n  t.integer :lftq, null: false\n  t.integer :rgtp, null: false\n  t.integer :rgtq, null: false\n  t.decimal :lft, precision: 31, scale: 30, null: false\n  t.decimal :rgt, precision: 31, scale: 30, null: false\n  t.string :name, null: false\nend\nadd_index :regions, :parent_id\nadd_index :regions, :lftp\nadd_index :regions, :lftq\nadd_index :regions, :lft\nadd_index :regions, :rgt\n```\n\n## Usage\n\nThe size of the tree is limited by the precision of the integer and floating\npoint data types in the database.\n\nThis act provides these named scopes:\n\n```ruby\nRegion.roots    # returns roots of tree.\nRegion.preorder # returns records for preorder traversal.\n```\n\nThis act provides these instance methods:\n\n```ruby\nRegion.parent      # returns parent of record.\nRegion.children    # returns children of record.\nRegion.ancestors   # returns scoped ancestors of record.\nRegion.descendants # returns scoped descendants of record.\nRegion.depth       # returns depth of record.\n```\n\nExample:\n\n```ruby\nclass Region < ActiveRecord::Base\n  acts_as_nested_interval\nend\n\nearth = Region.create :name => \"Earth\"\noceania = Region.create :name => \"Oceania\", :parent => earth\naustralia = Region.create :name => \"Australia\", :parent => oceania\nnew_zealand = Region.new :name => \"New Zealand\"\noceania.children << new_zealand\nearth.descendants      # => [oceania, australia, new_zealand]\nearth.children         # => [oceania]\noceania.children       # => [australia, new_zealand]\noceania.depth          # => 1\naustralia.parent       # => oceania\nnew_zealand.ancestors  # => [earth, oceania]\nRegion.roots           # => [earth]\n```\n\n## How it works\n\nThe **mediant** of two rationals is the rational with the sum of the two\nnumerators for the numerator, and the sum of the two denominators for the\ndenominator (where the denominators are positive).  \nThe mediant is numerically between the two rationals.  \nExample: `3/5` is the mediant of `1/2` and `2/3`, and `1/2 < 3/5 < 2/3`.  \n\nEach record \"covers\" a half-open interval `(lftp/lftq, rgtp/rgtq]`.  \nThe tree root covers `(0/1, 1/1]`.  \nThe first child of a record covers interval `(mediant{lftp/lftq, rgtp/rgtq}, rgtp/rgtq]`.  \nThe next child covers the interval\n `(mediant{lftp/lftq, mediant{lftp/lftq, rgtp/rgtq}}, mediant{lftp/lftq, rgtp/rgtq}]`.  \n\nWith this construction each lftp and lftq are relatively prime and the identity\n`lftq * rgtp = 1 + lftp * rgtq` holds.\n\nExample:\n\n                 0/1                           1/2   3/5 2/3                 1/1\n    earth         (-----------------------------------------------------------]\n    oceania                                     (-----------------------------]\n    australia                                             (-------------------]\n    new zealand                                       (---]\n\nThe descendants of a record are those records that cover subintervals of the\ninterval covered by the record, and the ancestors are those records that cover\nsuperintervals.\n\nOnly the left end of an interval needs to be stored, since the right end can be\ncalculated (with special exceptions) using the above identity:\n\n    rgtp := x\n    rgtq := (x * lftq - 1) / lftp\n\nwhere x is the inverse of lftq modulo lftp.\n\nSimilarly, the left end of the interval covered by the parent of a record can\nbe calculated using the above identity:\n\n    lftp := (x * lftp - 1) / lftq\n    lftq := x\n\nwhere x is the inverse of lftp modulo lftq.\n\n## Moving nodes\n\nTo move a record from `old.lftp, old.lftq` to `new.lftp, new.lftq`,\nthe following linear transform is applied to lftp, lftq of all descendants:\n\n    lftp := (old.lftq * new.rgtp - old.rgtq * new.lftp) * lftp\n             + (old.rgtp * new.lftp - old.lftp * new.rgtp) * lftq\n    lftq := (old.lftq * new.rgtq - old.rgtq * new.lftq) * lftp\n             + (old.rgtp * new.lftq - old.lftp * new.rgtq) * lftq\n\nYou should acquire a table lock before moving a record.\n\nExample:\n\n```ruby\npacific = Region.create :name => \"Pacific\", :parent => earth\nActiveRecord::Base.connection.execute(\"LOCK TABLES regions WRITE\")\noceania.parent = pacific\noceania.save!\nActiveRecord::Base.connection.execute(\"UNLOCK TABLES\")\n```\n\n## Migrating from acts_as_tree\n\nIf you come from acts_as_tree or another system where you only have a parent_id,\nto rebuild the intervals based on `acts_as_nested_interval`, after you migrated the DB\nand created the columns required by `acts_as_nested_interval` run:\n\n```ruby\nRegion.rebuild_nested_interval_tree!\n```\n\nNOTE! About `rebuild_nested_interval_tree!`:  \nIt zeroes all your tree intervals before recomputing them!  \nIt does a lot of N+1 queries of type `record.parent` and not only.\nThis might change once the AR identity_map is finished.\n\n## Authors\n\nAcknowledgement: http://arxiv.org/html/cs.DB/0401014 by Vadim Tropashko.  \n\nhttps://github.com/pythonic  \nhttps://github.com/klobuczek  \nhttps://github.com/clyfe  \nhttps://github.com/quangquach  \nhttps://github.com/kidlab  \n", 
  "id": 3603185
}
{
  "read_at": 1462554268, 
  "description": "", 
  "readme.md": "# Generating Faces with Torch\nIn this blog post we'll implement a generative image model that converts random noise into images of faces! [Code available on Github](https://github.com/skaae/torch-gan).\n\n\n<p align='center'><img width=\"75%\" src=\"images/model.png\"></p>\n\nFor this task, we employ a [Generative Adversarial Network](http://arxiv.org/abs/1406.2661) (GAN) [1].\nA GAN consists of two components; a *generator* which converts random noise into images and a *discriminator* which tries to distinguish between generated and real images. Here, 'real' means that the image came from our training set of images in contrast to the generated fakes.\n\nTo train the model we let the discriminator and generator play a game against each other. We first show the discriminator a mixed batch of real images from our training set and of fake images generated by the generator. We then simultaneously optimize the discriminator to answer NO to fake images and YES to real images and optimize the generator to fool the discriminator into believing that the fake images were real. This corresponds to minimizing the classification error wrt. to the discriminator and maximizing it wrt. the generator.\nWith careful optimization both generator and discriminator will improve and the generator will eventually start generating convincing images.\n\n### Implementing a GAN\nWe implement the generator and discriminator as convnets and train them with stochastic gradient descent.\n\nThe discriminator is a standard convnet with consecutive blocks of convolution, ReLU activation, max-pooling and dropout.\n\n```LUA\nmodel_D = nn.Sequential()\nmodel_D:add(cudnn.SpatialConvolution(3, 32, 5, 5, 1, 1, 2, 2))\nmodel_D:add(cudnn.SpatialMaxPooling(2,2))\nmodel_D:add(cudnn.ReLU(true))\nmodel_D:add(nn.SpatialDropout(0.2))\nmodel_D:add(cudnn.SpatialConvolution(32, 64, 5, 5, 1, 1, 2, 2))\nmodel_D:add(cudnn.SpatialMaxPooling(2,2))\nmodel_D:add(cudnn.ReLU(true))\nmodel_D:add(nn.SpatialDropout(0.2))\nmodel_D:add(cudnn.SpatialConvolution(64, 96, 5, 5, 1, 1, 2, 2))\nmodel_D:add(cudnn.ReLU(true))\nmodel_D:add(cudnn.SpatialMaxPooling(2,2))\nmodel_D:add(nn.SpatialDropout(0.2))\nmodel_D:add(nn.Reshape(8*8*96))\nmodel_D:add(nn.Linear(8*8*96, 1024))\nmodel_D:add(cudnn.ReLU(true))\nmodel_D:add(nn.Dropout())\nmodel_D:add(nn.Linear(1024,1))\nmodel_D:add(nn.Sigmoid())\n```\nThis is a pretty standard architecture. The discriminator takes a 64x64 RGB image as input and predicts YES or NO with a single sigmoid output.\n\nThe generator goes in the opposite direction. We start with a small image which is upsampled and convolved repeatedly:\n\n```LUA\nx_input = nn.Identity()()\nlg = nn.Linear(opt.noiseDim, 128*8*8)(x_input)\nlg = nn.Reshape(128, 8, 8)(lg)\nlg = cudnn.ReLU(true)(lg)\nlg = nn.SpatialUpSamplingNearest(2)(lg)\nlg = cudnn.SpatialConvolution(128, 256, 5, 5, 1, 1, 2, 2)(lg)\nlg = nn.SpatialBatchNormalization(256)(lg)\nlg = cudnn.ReLU(true)(lg)\nlg = nn.SpatialUpSamplingNearest(2)(lg)\nlg = cudnn.SpatialConvolution(256, 256, 5, 5, 1, 1, 2, 2)(lg)\nlg = nn.SpatialBatchNormalization(256)(lg)\nlg = cudnn.ReLU(true)(lg)\nlg = nn.SpatialUpSamplingNearest(2)(lg)\nlg = cudnn.SpatialConvolution(256, 128, 5, 5, 1, 1, 2, 2)(lg)\nlg = nn.SpatialBatchNormalization(128)(lg)\nlg = cudnn.ReLU(true)(lg)\nlg = cudnn.SpatialConvolution(128, 3, 3, 3, 1, 1, 1, 1)(lg)\nmodel_G = nn.gModule({x_input}, {lg})\n```\n\nTo generate an image we feed the generator with noise distributed N(0,1). After successful training, the output should be meaningful images!\n\n```LUA\nlocal noise_inputs = torch.Tensor(N, opt.noiseDim)\nnoise_inputs:normal(0, 1)\nlocal samples = model_G:forward(noise_inputs)\n```\n\n### Balancing the GAN game\nIn principle, the GAN optimization game is simple. We use binary cross entropy to optimize the parameters in the discriminator. Afterwards we use binary cross entropy to optimize the generator to fool the discriminator. That said, you often find yourself left with not very convincing outputs from generator:\n\n\n<p align='center'><img src=\"images/bad_examples.png\"></p>\n\nThis gibberish is typical for a generator trained without proper care!\n\nA couple of tricks are necessary for to facilitate training: First of, we need to make sure that that neither the generator nor the discriminator becomes too good compared to the other. If the discriminator 'wins' and classifies all images correctly, the error signal will be poor and the generator will not be able to learn from it. Conversely, if we allow the generator to win, it is usually exploiting a non-meaningful weakness in the discriminator (e.g. by coloring the entire image blue) which is not desirable.\n\nWe monitor the training by plotting three quantities:\n\n  1. How good the generator is at at fooling the discriminator (gen)\n  2. How good the discriminator is at classifying fakes as fakes (fake)\n  3. How good the discriminator is at classifying real images as real (real)\n\nBelow we plot these quantities during trained for three separate networks.\nIn panel A) we have made the discriminator too powerful by adding batch normalization layers. The training never converges because the sigmoid saturates resulting in a poor error signal for backpropagation.\n\nTo alleviate the problem, we monitor how good the discriminator is at classifying real and fake images and how good the generator is at fooling the discriminator. If one of the networks is too good, we skip updating its parameters according to the following rules. The convergence is shown in panel B). We also removed batch normalization from the discriminator.\n\n```LUA\nlocal margin = 0.3\n     sgdState_D.optimize = true\n     sgdState_G.optimize = true\nif err_F < margin or err_R < margin then\n     sgdState_D.optimize = false\nend\nif err_F > (1.0-margin) or err_R > (1.0-margin) then\n     sgdState_G.optimize = false\nend\nif sgdState_G.optimize == false and sgdState_D.optimize == false then\n     sgdState_G.optimize = true\n     sgdState_D.optimize = true\nend\n```\nIt seems a bit wasteful to not update the parameters in every batch. We therefore try another heuristic based on regularization of the discriminator if the generator is performing poorly. We increment the discriminators L2 penalty if the generator is not within a target range. If the generator fools the discriminator in 50% of the cases the error would be ~log(0.5) ~=0.69. We set the target range to be 0.9-1.2 i.e the discriminator should be better than the generator but not too much.\nThe training is shown in panel C) (Keep in mind that the x-axis is different)\n\n```LUA\nif f > 1.3 then  -- f is generator error\nsgdState_D.coefL2 = sgdState_D.coefL2 + 0.00001\nend\n\nif f < 0.9 then\nsgdState_D.coefL2 = sgdState_D.coefL2 - 0.00001\nend\n\nif sgdState_D.coefL2 < 0 then\nsgdState_D.coefL2 = 0\nend\n```\n\n<p align='center'><img src=\"images/monitor.png\"></p>\n\nThese simple heuristics seem to work, but there is definitely room for improvement. Most importantly, they allows us to crank up the learning rate and use RMSProp.\n\nA few other tricks are necessary for successful GAN traning:\n\n * Batch normalization speeds up training a lot when used in the generator. Using batch normalization in the discriminator is dangerous as the discriminator becomes too powerful.\n\n * Plenty of dropout is needed in the discriminator to avoid oscillating behavior caused by the generator exploiting a weakness of the discriminator. Dropout can also be used in the generator.\n\n * It may be beneficial to limit the capacity of the discriminator. This is done by decreasing its number of features such that the generator contains more parameters.\n\n\n### Generating faces\nWe train our GAN using aligned and cropped images from the [Labeled faces in the wild](http://vis-www.cs.umass.edu/lfw/) dataset. After a around 5 epochs (around 30 minutes on a GPU) you should start to see some spooky faces (left).\nWhich after 100 epochs will look more pleasant (right).\n\n<p align='center'><img width=\"80%\" src=\"images/samples_during_training.png\"></p>\n\nAfter a day of training, we get decent looking walks around in the latent space of the GAN ([full movie on YouTube](https://www.youtube.com/watch?v=PmC6ZOaCAOs&feature=youtu.be)):\n\n\n<p align='center'><img width=\"30%\" src=\"images/out.gif\"></p>\n\n\n### Going Further\nWhile it is good fun to generate images from noise, GANs gives us no control over the latent space.\n\nA related generative model is the [Variational autoencoder](http://arxiv.org/abs/1312.6114) (VAE) [3] in which the decoder maps samples from a prior distribution to dataset samples - very similar to the GAN generator.\n\n\n<p align='center'><img width=\"75%\" src=\"images/vae.png\"></p>\n\nThe VAE decoder is trained differently as we seek to minimize the pixelwise reconstruction error of the decoded image compared to the encoded image. This error term is problematic for images since translation is punished disproportionately to the small error perceived by human vision. In practice, this means that VAEs are biased towards generating smooth images with a correct global subject whereas GAN generated images have more correct local style with less emphasis on the global structure.\n\nHere is an example of VAE images generated from random samples z ~ N(0,1):\n\n<p align='center'><img width=\"40%\" src=\"images/samples_vae_crop.png\"></p>\n\nThough the images clearly contain faces, they are somewhat boring because of their smoothness.\nTo improve this, we try to combine VAE and GAN in one model:\n\n<p align='center'><img width=\"60%\" src=\"images/vaegan.png\"></p>\n\nWe let the GAN and the VAE share latent space z ~ N(0,1) as well as the decoder/generator. We combine the error terms when training the model:\n\n**Error = [VAE prior] + [VAE reconstruction error] + [GAN error]**\n\nTo optimize the parameters of the combined model, we minimize the VAE terms while balancing the GAN term as already described. The gradients to the decoder/generator parameters are weighted to ensure a sensible contribution from both models.\n\nBelow we show images generated by the VAE/GAN model.\n\n<p align='center'><img width=\"95%\" src=\"images/reconstructions.png\"></p>\n\nCompared to the plain VAE, the VAE/GAN images are more interesting as they contain more details. Most notably, VAE/GAN has learned to reconstruct a pair of glasses.\n\n### Acknowledgements\nEyescream authors [2] for making their code public. Our code is heavily based on the CIFAR code released for the LAPGAN paper[2].\n\nTorch VAE from Y0st: https://github.com/y0ast/VAE-Torch\n\n### References\n[1] Goodfellow, Ian, et al. \"Generative adversarial nets.\" Advances in Neural Information Processing Systems. 2014.\n\n[2] Denton, Emily, et al. \"Deep Generative Image Models using a Laplacian Pyramid of Adversarial Networks.\" arXiv preprint arXiv:1506.05751 (2015).\n\n[3] Kingma, Diederik P., and Max Welling. \"Auto-encoding variational bayes.\" arXiv preprint arXiv:1312.6114 (2013).\n", 
  "id": 45978604
}
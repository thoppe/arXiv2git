{
  "read_at": 1462546726, 
  "description": "Pseudo Likelihood Maximization for protein in Julia ", 
  "README.md": "PlmDCA\n======\n\nPseudo-likelihood maximization in [Julia](http://julialang.org). A\ncomplete description of the algorithm can be found at\nhttp://plmdca.csc.kth.se/. If you use this algorithm you should cite:\n\n1. M. Ekeberg, C. Lovkvist, Y. Lan, M. Weigt, E. Aurell, Improved\n   contact prediction in proteins: Using pseudolikelihoods to infer Potts\n   models, Phys. Rev. E 87, 012707 (2013)\n\n2. M. Ekeberg, T. Hartonen, E. Aurell, Fast pseudolikelihood\n   maximization for direct-coupling analysis of protein structure from\n   many homologous amino-acid sequences,\n   [arXiv:1401.4832](http://arxiv.org/abs/1401.4832) (supplementary\n   material)\n\nThe present software is a Julia implementation of above mentioned\npapers, with no reference to the original MATLAB\n[software](http://plmdca.csc.kth.se) implementation.\n\nOverview\n--------\n\nThe code uses [NLopt](https://github.com/JuliaOpt/NLopt.jl) which\nprovides a Julia interfaces to the free/open-source [NLopt\nlibrary](http://ab-initio.mit.edu/wiki/index.php/NLopt). The program\n(only in its asymmetric version so far, see below) can be run on\nmultiple cores previous ``addprocs(nprocs)`` where ``nprocs`` should\nbe some integer number `np` lower or equal to your (physical) number\nof cores.\n\nInstall\n-------\n\nIt requires the installation of:\n\n* [NLopt.jl](https://github.com/JuliaOpt/NLopt.jl). \n```\njulia> Pkg.add(\"NLopt\")\n```\n* [GaussDCA](https://github.com/carlobaldassi/GaussDCA.jl)\n```\njulia> Pkg.clone(\"https://github.com/carlobaldassi/GaussDCA.jl\")\n```\n* [PlmDCA] The PlmDCA module itself can be added with\n```\njulia> Pkg.clone(\"https://github.com/pagnani/PlmDCA\")\n```\n   \n   \nWe have not tested yet the software on Windows.\n\nUsage\n-----\nTo load the code just type\n```\njulia> using PlmDCA\n```\n\nThe software provides two main functions `plmdca(filename::String,\n...)` and `plmdcasym(filename::String,...)` (resp. the asymmetric and\nsymmetric coupling version of the algorithm). Empirically it turns out\nthat the asymmetric version is faster and more accurate. This function\ntake as input the name of a (possibly zipped) multiple sequence.\n\nWe also provide another function `mutualinfo(filename::String,...)` to\ncompute the mutual information score. \n\nThere are a number of possible algorithmic strategies for the\noptimization problem. As long as local gradient-based optimization is\nconcerned, this is a list of `:symbols` (associated to the different\nmethods): \n```\n:LD_MMA, :LD_SLSQP, :LD_LBFGS, :LD_TNEWTON_PRECOND\n:LD_TNEWTON_PRECOND_RESTART, :LD_TNEWTON, :LD_VAR2, :LD_VAR1\n```\n\nAfter some test we found that the best compromise between accuracy and\nspeed is achieved by the Low Storage BFGS method `:LD_LBFGS`, which is\nthe default method in the code. The other methods can be set changing\nthe default optional argument (e.g. `method=:LD_SLSQP`).\n\nThere are more optional arguments that can be set (to be documented...).\n\nOutput\n======\nThe functions output a `type PlmOut` (say `X`) with 3 fields:\n\n\n*  `X.Jtensor`: the coupling matrix `J[ri,rj,i,j]` a not symmetric\n`q x q x N x N` array, where `N` is the number of residues in the\nmultiple sequence alignment, and `q` is the alphabet \"size\" (typically\n21 for proteins).\n*  `X.pslike`: the pseudolikelihood\n*  `X.score`: a `(Int, Int, Float64)` (in julia version 0.3) or a\n`Tuple{Int,Int,Float64}` in (in julia version 0.4) vector of Tuples containing the candidate contact descending order (residue1, residue2 , score12).\n\n\n\n\n\nRequirements\n---\n\nThe minimal julia version for using this code is 0.3. It requires the\npackage [Compat](https://github.com/JuliaLang/Compat.jl) to guarantee\ncompatibility between different Julia versions.\n\n\nTodos \n----- \n\nA lot!\n", 
  "id": 19616785
}
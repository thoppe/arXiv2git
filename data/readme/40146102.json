{
  "read_at": 1462545978, 
  "description": "Implements the algorithms described in \u201cMultiple binomial sums\u201d", 
  "README.md": "BinomSums\n=========\n\n*BinomSums* is a package, for the computer algebra system Maple 17 or later,\nproviding functions to handle multiple binomial sums.  It implements the\nalgorithms described in the paper:\n\n> A. Bostan, P. Lairez, and B. Salvy, \"Multiple binomial sums\"\n\n> [arxiv:1510.07487](http://arxiv.org/abs/1510.07487)\n\nTable of Contents\n-----------------\n\n* [Warning](#warning)\n* [License](#license)\n* [Installation](#installation)\n* [Usage](#usage)\n  * [Binomial sums](#binomial-sums)\n  * [Examples of binomial sums](#examples-of-binomial-sums)\n  * [Description of the main functions](#description-of-the-main-functions)\n    * [sumtores](#sumtores)\n    * [ratres](#ratres)\n    * [geomred](#geomred)\n    * [computesum](#computesum)\n    * [rser](#rser)\n  * [Other functions](#other-functions)\n    * [geomredall](#geomredall)\n    * [sumtoct](#sumtoct)\n    * [addnewgf](#addnewgf)\n\n\nWarning\n-------\n\n*This is a very preliminary implementation.*\nIt is likely to contain bugs. It is provided *as is*.\nDo not hesitate to submit bug reports of pull requests.\n\n\nLicense\n-------\n\n*BinomSums* is released under the terms of the MIT license.\n\nSee the file LICENSE for more information.\n\n\nInstallation\n------------\n\n1. Execute `make`, this produces the file `binomsums.mla`.\n2. Check that the variable `libname` in Maple contains the path to `binomsums.mla` or to its parent directory.\n3. Load the package in Maple with `with(BinomSums);`\n\n\nUsage\n-----\n\n### Binomial sums\n\nA *binomial sum* is a Maple expression made with the following rules.  For\nsimplicity, let us assume that Maples indeterminates split in two sets: the\ncontinuous variables and the discrete ones. An `<integer form>` is a polynomial\nof degree one in the discrete variables, with integer coefficients. \n\nA *supergeometric* sequence `<supergeom>` can be:\n\n* A polynomial in the discrete variables\n* `<rational function of continous variables>^<integer form>`\n* `<supergeom> + <supergeom>`\n* `<supergeom> * <supergeom>`\n\nA `<binomial sum>` can be either *primitive*:\n\n* `Binomial(<integer form >, <integer form>)`\n* `Delta(<integer form >)`\n* `H(<integer form >)`\n* `Catalan(<integer form >)`\n* `Multinomial([<integer form >, ...])`\n* `<supergeom>`\n\nOr a `<binomial sum>` can be *composed*:\n\n* `<binomial sum> + <binomial sum>`\n* `<binomial sum> * <binomial sum>`\n* `<binomial sum>^<integer>`\n* `Sum(<binomial sum>, <discrete variable>=<integer form>..(<integer form> || infinity))`\n\nA generating function `<gfun>` is a binomial sum whose discrete variables are\nall bound by a `Sum`.\n\n### Examples of binomial sums\n\n```\nS1 := Binomial(n,k)^2*Multinomial([n,k]);\n\nS2 := Sum(t^n*Sum(Binomial(n,k)^2*Multinomial([n,k]), k=0..infinity), n=0..infinity);\n\nS3 := Sum(Sum(x^n*y^m*Binomial(n+2*m, m), n=0..infinity), m=0..infinity);\n\nS4 := Sum(t^n*Sum(Binomial(n,n-k), k=0..infinity), n=0..infinity);\n```\n\nNote that `S2`, `S3` and `S4` are generating functions.\n\n### Description of the main functions\n\n#### `sumtores`\n\n`sumtores(S :: <gfun>, v :: name, [geomred = false]) -> ratpoly, list(name)`\n\nReturns a rational function `R` and a list of names `ord`.\n\nThe variables in `R` are the continuous variables in `S` and `v[1]`, `v[2]`,\netc.\n\nThe generating function `S` is the residue of `R` with respect to the `v[i]`'s.\nThe list `ord` gives, by ascending order, the order of the variables defining\nthe iterated Laurent series field in which the residue is defined (see the\npaper for definition).\n\n`sumtores` fails if it does not find an order on the variables that makes the\ninfinite sums converge.\n\nIf `geomred=false` is given, then the *geometric reduction* (see the paper for\ndefinition) is not performed.\n\n##### Examples\n\n```\n> sumtores(S2, v);\n                                 1\n  ---------------------------------------------------------------, [t, v[1], v[2]]\n  (v[1] v[2] - v[1] - v[2]) t + v[1] v[2] (-1 + v[2]) (-1 + v[1])\n\n> sumtores(S3, v);\n                                v[1]\n                  ---------------------------------, [x, y, v[1]]\n                  (y + v[1] (-1 + v[1])) (x - v[1])\n\n> sumtores(S4, v);\nError, (in solvecons) inconsistent\n\n```\n\n#### `ratres`\n\n```\nratres(R :: ratpol, v :: name, ord :: list(name)) -> ratpoly or FAIL\n```\n\nReturns `FAIL` or a rational function `T` that is the residue of `R` with\nrespect to the variable `v` in the iterated Laurent series field defined by the\nordering `ord`. It implements Algorithm 3 of the paper.\n\n##### Example\n\n```\n> ratres(1/(t*(1+z)^19+z-t), z, [t, z]);\n                                      1\n                                   --------\n                                   19 t + 1\n```\n\n#### `geomred`\n\n```geomred(R :: ratpoly, ord :: list(name), params :: set(name)) -> ratpoly```\n\nTries to apply `ratres` with all the variables of `ord` that are not in\n`params`, one after the other, and returns the result.\n\nSo it returns a rational function `T` with less variables, hopefully, than `R`\nsuch that its residue with respect to the variables in `R` that are not in\n`params` is equal to the residue of `S` with respect to the variables in `S`\nthat are not in `params`.\n\n#### `computesum`\n\n`computesum(S :: <binomial sum>, maxn :: integer)`\n\nReplace `infinity` by `maxn` in `S`, and then compute the sum.  Useful for\nchecking that things are consistent.\n\n##### Example\n```\n> computesum(S2, 6); \n                   6          5         4        3       2\n           104959 t  + 11253 t  + 1251 t  + 147 t  + 19 t  + 3 t + 1\n```\n\n#### `rser`\n\n`rser(R :: ratpoly, vars :: list(name), n :: posint) -> truncated power series`\n\nCompute the first `n` terms of the power series expansion of the residue of `R`\nwith respect to all the variables of `vars` except the first one.  The ordering\nof `vars` defines the iterated Laurent series field in which the computation\ntakes place.  Useful for checking that things are consistent.\n\n##### Example\n```\n> rser(sumtores(S2, v), 7);\n                         2        3         4          5           6\n           1 + 3 t + 19 t  + 147 t  + 1251 t  + 11253 t  + 104959 t\n```\n\n\n### Other functions\n\n#### `geomredall`\n\n`geomredall(R :: ratpoly, ord :: list(name), params :: set(name)) -> set(ratpoly)`\n\nThe same as `geomred` but tries every possible order to eliminate the\nvariables.\n\n#### `sumtoct`\n\n`sumtoct(S :: <binomial sum>, v :: name) -> <supergeom>` \n\nReturns `T :: <supergeom>`.\n\nIf `S` contains no infinite sum, the continuous variables of `T` are those of\n`S` and `v[1]`, `v[2]`, etc.  In this case, for any integer value of the\ndiscrete variables, the value of `S` is the constant term of `T`, with respect\nto the variables `v[i]`'s, in any order.\n\n`T` will contain an extra variable `_W[_k]` for each infinite sum\n`k=a..infinity`. They are used internally to determine an order on the\nvariables that makes things converge.\n\n##### Examples\n\n```\n> sumtoct(S1, v);                                                                   \n             (k + 1)     (n - k)           (k + 1)     (n - k)\n1/((1 - v[1])        v[1]        (1 - v[2])        v[2]        (1 - v[3] - v[4])\n\n        n     k\n    v[3]  v[4] )\n\n> sumtoct(S2, v);\n- v[4] v[1] v[2] v[3]/((-v[1] v[2] v[3] + t _W[_n])\n\n    (_W[_k] v[1] v[2] - v[1] v[2] v[4] + v[1] v[4] + v[2] v[4] - v[4])\n\n    (-1 + v[3] + v[4]))\n\n```\n\n#### `addnewgf`\n\n*TODO*\n\n\n\n", 
  "id": 40146102
}
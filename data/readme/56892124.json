{
  "read_at": 1462548535, 
  "description": "A python PEG parser generator", 
  "README.md": "# Fastidious\nA python [parsing expression grammar (PEG)](https://en.wikipedia.org/wiki/Parsing_expression_grammar) based parser generator.\nIt is loosely based on https://github.com/PuerkitoBio/pigeon\n\n## Usage\nFrom [the calculator example](examples/calculator.py)\n\n```python\n#! /usr/bin/python\nfrom fastidious import Parser\n\n\nclass Calculator(Parser):\n\n    # __grammar__ is the PEG definition. Each `rulename <- a rule`\n    # adds a method `Calculator.rulename()`. This methods tries to\n    # match the input at current position\n    __grammar__ = r\"\"\"\n    # the label is ommited. `:expr` is equivalent to `expr:expr`\n    eval <- :expr EOF {@expr}\n\n    # action {on_expr} calls `Calculator.on_expr(self, value, first, rest)`\n    # on match. `first` and `rest` args are the labeled parts of the rule\n    term <- first:factor rest:( _ mult_op _ factor )* {on_expr}\n\n    # Because the Parser has a method named `on_expr` (\"on_\" + rulename)\n    # this method is the implicit action of this rule. We omitted {on_expr}\n    expr <- _ first:term rest:( _ add_op _ term  )* _\n\n    # there's no explicit or implicit action. These rules return their exact\n    # matches\n    add_op <- '+' / '-'\n    mult_op <- '*' / '/'\n\n    # action {@fact} means : return only the match of part labeled `fact`.\n    factor <- ( '(' fact:expr ')' ) / fact:integer {@fact}\n\n    integer <- '-'? [0-9]+\n    _ <- [ \\n\\t\\r]*\n\n    # this one is tricky. `.` means \"any char\". At EOF there's no char,\n    # thus Not any char, thus `!.`\n    EOF <- !.\n    \"\"\"\n\n    def on_expr(self, value, first, rest):\n        result = first\n        for r in rest:\n            op = r[1]\n            if op == '+':\n                result += r[3]\n            elif op == '-':\n                result -= r[3]\n            elif op == '*':\n                result *= r[3]\n            else:\n                result /= r[3]\n        return result\n\n    def on_integer(self, value):\n        return int(self.flatten(value))\n\nif __name__ == \"__main__\":\n    import sys\n    c = Calculator(\"\".join(sys.argv[1:]))\n    print(c.eval())\n```\nThen you have a full-fledge state-of-the-art integer only calculator \\o/\n\n```sh\nexamples/calculator.py \"-21 *  ( 3 + 1 ) / -2\"\n42\n```\n## PEG Syntax\nThe whole syntax is formely defined i in [fastidious parser code](fastidious/parser.py), using the PEG syntax (which is actually used to generate the fastidious parser itself, so it's THE TRUTH. I like meta-stuff). What follows is an informal description of this syntax.\n\nIdentifiers, whitespace, comments and literals follow a subset of python notation:\n\n```\n# a comment\n'a string literal'\n\"a more \\\"complex\\\" one with a litteral '\\\\' \\nand a second line\"\n_aN_iden7ifi3r\n```\nIdentifier MUST be valid python identifiers as they are added as methods on the parser objects. Parsers have utility methods that are prefixed by `p_` and `_p_`. Please avoid these names.\n\n### Rules\n\nA PEG grammar consists of a set of rules. A rule is an identifier followed by a rule definition operator `<-` and an expression. An optional display name - a string literal used in error messages instead of the rule identifier - can be specified after the rule identifier. An action can also be specified enclosed in `{}` after the rule, more on this later.\n\n```\nrule_a \"friendly name\" <- 'a'+ {an_action} # one or more lowercase 'a's\n```\n\n### Expressions\n\nA rule is defined by an expression. The following sections describe the various expression types. Expressions can be grouped by using parentheses, and a rule can be referenced by its identifier in place of an expression.\n\n#### Choice expression\n\nThe choice expression is a list of expressions that will be tested in the order they are defined. The first one that matches will be used. Expressions are separated by the forward slash character \"/\". E.g.:\n```\nchoice_expr <- A / B / C # A, B and C should be rules declared in the grammar\n```\nBecause the first match is used, it is important to think about the order of expressions. For example, in this rule, \"<=\" would never be used because the \"<\" expression comes first:\n```\nbad_choice_expr <- \"<\" / \"<=\"\n```\n\n#### Sequence expression\n\nThe sequence expression is a list of expressions that must all match in that same order for the sequence expression to be considered a match. Expressions are separated by whitespace. E.g.:\n\n```\nseq_expr <- \"A\" \"b\" \"c\" # matches \"Abc\", but not \"Acb\"\n```\n\n#### Labeled expression\n\nA labeled expression consists of an identifier followed by a colon \":\" and an expression. A labeled expression introduces a variable named with the label that can be referenced in the action of the rule. The variable will have the value of the expression that follows the colon. E.g.:\n\n```\nlabeled_expr <- value:[a-z]+ \"a suffix\" {@value}\n```\nIf this sequence matches, the rule returns only the `[a-z]+` part instead of `[\"thevalue\", \"a suffix\"]`\n\n\n## TODO\n- make it pip installable\n- add error reporting using this paper http://arxiv.org/pdf/1405.6646v1.pdf\n- make a tool to generate standalone modules\n- python3\n- more tests\n- tox\n- travis\n\n\n", 
  "id": 56892124
}
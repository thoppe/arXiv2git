{
  "read_at": 1462550732, 
  "description": "Probabilistic data structures for OCaml", 
  "README.md": "flajolet\n========\n\nProbabilistic data structures for OCaml intended for use in streaming data analysis\n\nFlajolet is an OCaml library providing streaming data structures in the vein of the popular\n[streamlib](https://github.com/addthis/stream-lib) library for Java.\n\nFlajolet is named for INRIA professor [Philippe Flajolet](http://algo.inria.fr/flajolet/), inventor of the HyperLogLog data structure.\n\n##Installation\nFirst install dependencies:\n- core_extended: `opam install core_extended`\n- farmhash: https://github.com/ahrefs/ocaml-farmhash\n- bitarray: https://github.com/travisbrady/ocaml-bitarray\n- uint: `opam install uint`\n\nThen:\n`$ make install`\n\nModules:\n=========\n\n*ALPHA* \nStill very much in development.\n\n####Hyperloglog:\nDistinct values counting. This example: [card.ml](https://github.com/travisbrady/flajolet/blob/master/examples/card.ml)\nprovides a very simple demonstration of the idea here.\n\nToy example usage counting 4 unique strings:\n```ocaml\n# #require \"flajolet\";;\n# let hll = Hyperloglog.create 0.03;;\nval hll : Hyperloglog.t = <abstr>\n# List.iter (fun x -> Hyperloglog.offer hll x) [\"hi\"; \"hello\"; \"bonjour\"; \"salut\"; \"hi\"; \"hi\"; \"hi\"];;\n- : unit = ()\n# Hyperloglog.card hll;;\n- : float = 4.00391134373\n```\n\n####Bloom Filter\nSupports approximate set membership queries with no false negatives.\n\nExample:\n```ocaml\n(* Create a bloom filter with 10_000 expected items and a 1% desired false positive rate *)\n# let b = Bloom.create_with_estimates 10_000 0.01;;\n# Bloom.add b \"hey\";;\n# Bloom.test b \"hey\";;\n- : bool = true\nBloom.test b \"nope\";;\n- : bool = false\n```\n\n####Count-Min Sketch\nA well-known sketch used for frequency estimation. You can think of it as a hash table for storing\napproximate frequencies where you don't maintain the keys. You can ask \"how many times have you\nseen the `blah_blah_blah`?\" and the Cmsketch will answer with an estimated count. But it cannot\nprovide a list of keys ever seen. Also allows deletion.\nThe tests in [test_cmsketch.ml](lib_test/test_cmsketch.ml) are instructive.\n\n####Minhash\nUseful for computing the Jaccard coefficient in bounded space. Invented originall to detect\nnear-duplicate webpages and can be applied to all sorts of near-dupicate detection problems\nprovided you've got a way to featurize your data.\nUsed primarily for set similarity but also supports cardinality estimation.\nSee the tests in [test_minhash.ml](lib_test/test_minhash.ml)\n\n####StreamSummary:\nTop-k queries in bounded memory.  When you've scanning a stream user ids and want to ask\n\"who are the top 10 most frequently seen users?\" but storing a map from every user id to every\nappearance count is infeasible.\n\nSee [topk.ml](https://github.com/travisbrady/flajolet/blob/master/examples/topk.ml) for an example of using a stream summary to calculate the top-k most frequenty itemsin a shell pipeline.\n\n####Histogram:\na streaming histogram, allowing for computation of descriptive stats (min, max, mean, variance) and\nquantiles in bounded memory in a streaming fashion.\n\nHave a look at [destats.ml](https://github.com/travisbrady/flajolet/blob/master/examples/destats.ml) for an example of using a Histogram to compute descriptive stats on a column of numbers read of stdin.\n\nExample with some fake data:\n```\n$ cat floats\n0.0\n1.0\n2.0\n3.0\n4.0\n$ cat floats | ./destats.native\ncount:       5.00\nmean :       2.00\nstd  :       1.41\nmin  :       0.00\n25%  :       1.00\n50%  :       2.00\n75%  :       3.00\nmax  :       4.00\n```\n\n####Recordinality\nAnother distinct values estimation method, this time created by a former student (Jeremie Lumbroso) of Flajolet's.\nThe benefit here is that Recordinality allows you to count distinct values and to retrieve a sample\nof previously seen values.\n\n####Self-Learning Bitmaps (aka Sbitmap):\nAnother distinct values estimator with scale-invariant errors.  More space-efficient than a \nHyperloglog often when cardinality is < 10^6 and the desired error rate is low.\nFor more see page 27 of Chen and Cao's paper: \nhttp://arxiv.org/pdf/1107.1697v1.pdf\n\n##Acknowledgements: portions of this code were understood in part by reading code from: \n- https://github.com/dgryski\n- https://github.com/seiflotfy\n- https://github.com/svpcom/hyperloglog\n\n##License: MIT\n", 
  "id": 18824807
}
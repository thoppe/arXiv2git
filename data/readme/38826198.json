{
  "read_at": 1462546458, 
  "description": ":exclamation:\u00a0This\u00a0is\u00a0a\u00a0read-only\u00a0mirror\u00a0of\u00a0the\u00a0CRAN\u00a0R\u00a0package\u00a0repository.  PythonInR\u00a0\u2014\u00a0Use\u00a0Python\u00a0from\u00a0Within\u00a0R.\u00a0Homepage:\u00a0https://bitbucket.org/Floooo/pythoninr/  Report\u00a0bugs\u00a0for\u00a0this\u00a0package:\u00a0https://bitbucket.org/Floooo/pythoninr/issues", 
  "README.md": "# PythonInR - Makes accessing Python from within R as easy as pie.\n\nMore documenation can be found at [https://bitbucket.org/Floooo/pythoninr](https://bitbucket.org/Floooo/pythoninr) and [http://pythoninr.bitbucket.org/](http://pythoninr.bitbucket.org/).\n\n## Dependencies\n\n**Python** >= 2.7.0\n**R** >= 2.15.0\n \n**R-packages:**   \n- pack\n\n\n### Linux\n**Python headers** \n\nOn **Debian** and Debian-based Linux distributions (including **Ubuntu**\nand other derivatives) the *\"Python Development Headers\"* can be installed\nby typing the following into the terminal.\n\n```bash\n    apt-get install python-dev\n```    \n\nFor installation on **Red Hat Enterprise Linux** , **Fedora**, and other **Red Hat\nLinux-based** distributions, use the following:\n\n```bash\n    yum install python-devel\n```\n\n### Windows\nThere are no additional dependencies on Windows. \n(One obviously needs to have R and Python installed.)\n\n## Installation\n```r\n    install.packages(\"PythonInR\")\n#   or via devtools\n    require(devtools)\n    install_bitbucket(\"Floooo/PythonInR\")\n```\n\n## Windows Setup\nSince the Windows version of PythonInR uses explicit linkage one can switch\nbetween different Python versions without recompiling the package. This flexibility\ncomes at the price of additional configuration at the startup. Which results in a different \nbehavior for the static (Linux default) and the explicit linked (Windows default) version. \nWhere as the static linked version automatically connects, when the package get's loaded, \nthe explicitly linked version needs to be connected manually.     \n     \nTo enable automatic connection for the explicitly linked version the environment variable\n**PYTHON_EXE** has to be set. You can put your Python path into your ```.Renviron``` or\n```.Rprofile``` file ([Setting up a .Renviron file](https://bitbucket.org/Floooo/pythoninr/wiki/Initialization%20at%20Start%20of%20an%20R%20Session%20on%20Windows)). \n\n## NOTES\n### Python 3\nDue to api changes in Python 3 the function `execfile` is no longer available.\nThe PythonInR package provides a `execfile` function following the typical\n[workaround](http://www.diveintopython3.net/porting-code-to-python-3-with-2to3.html#execfile).\n```python\ndef execfile(filename):\n    exec(compile(open(filename, 'rb').read(), filename, 'exec'), globals())\n```\n\n## Type Casting\n### R to Python (pySet)\nTo allow a nearly one to one conversion from R to Python, PythonInR provides\nPython classes for vectors, matrices and data.frames which allow \nan easy conversion from R to Python and back. The names of the classes are PrVector,\nPrMatrix and PrDataFrame.\n\n#### Default Conversion\n| R                  | length (n) | Python      |\n| ------------------ | ---------- | ----------- |\n| NULL               |            | None        |\n| logical            |          1 | boolean     |\n| integer            |          1 | integer     |\n| numeric            |          1 | double      |\n| character          |          1 | unicode     |\n| logical            |      n > 1 | PrVector    |\n| integer            |      n > 1 | PrVector    |\n| numeric            |      n > 1 | PrVector    |\n| character          |      n > 1 | PrVector    |\n| list without names |      n > 0 | list        |\n| list with names    |      n > 0 | dict        |\n| matrix             |      n > 0 | PrMatrix    |\n| data.frame         |      n > 0 | PrDataFrame |\n\n\n#### Change the predefined conversion of pySet\nPythonInR is designed in way that the conversion of types can easily be added or changed.\nThis is done by utilizing polymorphism: if pySet is called, pySet calls pySetPoly\nwhich can be easily modified by the user. The following example shows how pySetPoly \ncan be used to modify the behavior of pySet on the example of integer vectors.\n\nThe predefined type casting for integer vectors at an R level looks like the following:\n```r\nsetMethod(\"pySetPoly\", signature(key=\"character\", value = \"integer\"),\n          function(key, value){\n    success <- pySetSimple(key, list(vector=unname(value), names=names(value), rClass=class(value)))\n    cmd <- sprintf(\"%s = PythonInR.prVector(%s['vector'], %s['names'], %s['rClass'])\", \n                   key, key, key, key)\n    pyExec(cmd)\n})\n```\nTo change the predefined behavior one can simply use setMethod again.\n```r\npySetPoly <- PythonInR:::pySetPoly\nshowMethods(\"pySetPoly\")\n\npySet(\"x\", 1:3)\npyPrint(x)\npyType(\"x\")\n\nsetMethod(\"pySetPoly\",\n          signature(key=\"character\", value = \"integer\"),\n          function(key, value){\n    PythonInR:::pySetSimple(key, value)\n})\n\npySet(\"x\", 1:3)\npyPrint(x)\npyType(\"x\")\n```\n**NOTE PythonInR:::pySetSimple**   \nThe functions **pySetSimple** and **pySetPoly** shouldn't be used **outside** the function \n**pySet** since they do not check if R is connected to Python. If R is not connected \nto Python this can **yield** to **segfault** !\n\n\n**NOTE (named lists):**   \nWhen executing `pySet(\"x\", list(b=3, a=2))` and `pyGet(\"x\")` the order \nof the elements in x will change. This is not a special behavior of **PythonInR**\nbut the default behavior of Python for dictionaries.\n\n**NOTE (matrix):**   \nMatrices are either transformed to an object of the class PrMatrix or \nto an numpy array (if the option useNumpy is set to TRUE).\n\n\n**NOTE (data.frame):**   \nData frames are either transformed to an object of the class PrDataFrame   \nor to a pandas DataFrame (if the option usePandas is set to TRUE).\n\n\n### R to Python (pyGet)  \n\n| Python      | R                    | simplify     |\n| ----------- | -------------------- | ------------ |\n| None        | NULL                 | TRUE / FALSE |\n| boolean     | logical              | TRUE / FALSE |\n| integer     | integer              | TRUE / FALSE |\n| double      | numeric              | TRUE / FALSE |\n| string      | character            | TRUE / FALSE |\n| unicode     | character            | TRUE / FALSE |\n| bytes       | character            | TRUE / FALSE |\n| tuple       | list                 | FALSE        |\n| tuple       | list or vector       | TRUE         |\n| list        | list                 | FALSE        |\n| list        | list or vector       | TRUE         |\n| dict        | named list           | FALSE        |\n| dict        | named list or vector | TRUE         |\n| PrVetor     | vector               | TRUE / FALSE |\n| PrMatrix    | matrix               | TRUE         |\n| PrDataFrame | data.frame           | TRUE         |\n\n#### Change the predefined conversion of pyGet\nSimilar to pySet the behavior of pyGet can be changed by utilizing pyGetPoly.\nThe predefined version of pyGetPoly for an object of class PrMatrix looks like the following:\n```r\nsetMethod(\"pyGetPoly\", signature(key=\"character\", autoTypecast = \"logical\", simplify = \"logical\", pyClass = \"PrMatrix\"),\n          function(key, autoTypecast, simplify, pyClass){\n    x <- pyExecg(sprintf(\"x = %s.toDict()\", key), autoTypecast = autoTypecast, simplify = simplify)[['x']]\n    M <- do.call(rbind, x[['matrix']])\n    rownames(M) <- x[['rownames']]\n    colnames(M) <- x[['colnames']]\n    return(M)\n})\n```\nFor objects of type \"type\" no conversion is defined. Therefore, PythonInR doesn't know how\nto transform it into an R object so it will return a PythonInR_Object. This is kind of a\nnice example since the return value of type(x) is a function therefore PythonInR will\nreturn an object of type pyFunction.\n```r\npyGet(\"type(list())\")\n```\nOne can define a new function to get elements of type \"type\" as follows.\n```r\npyGetPoly <- PythonInR:::pyGetPoly\nsetClass(\"type\")\nsetMethod(\"pyGetPoly\", signature(key=\"character\", autoTypecast = \"logical\", simplify = \"logical\", pyClass = \"type\"),\n          function(key, autoTypecast, simplify, pyClass){\n    pyExecg(sprintf(\"x = %s.__name__\", key))[['x']]\n})\npyGet(\"type(list())\")\n```\n\n**NOTE pyGetPoly**   \nThe functions **pyGetPoly** should not be used **outside** the function \n**pyGet** since it does not check if R is connected to Python. If R is not connected \nto Python this will **yield** to **segfault** !\n\n\n**NOTE (bytes):**   \nIn short, in Python 3 the data type string was replaced by the data type bytes.\nMore information can be found [here](http://www.diveintopython3.net/strings.html).\n\n\n## Cheat Sheet  \n\n| Command          | Short Description                                  | Example Usage                                                        |\n| ---------------- | -------------------------------------------------- | -------------------------------------------------------------------- |\n| BEGIN.Python     | Start a Python read\\-eval\\-print loop              | `BEGIN.Python() print(\"Hello\" + \" \" + \"R!\") END.Python`              |\n| pyAttach         | Attach a Python object to an R environment         | `pyAttach(\"os.getcwd\", .GlobalEnv)`                                  |\n| pyCall           | Call a callable Python object                      | `pyCall(\"pow\", list(2,3), namespace=\"math\")`                         |\n| pyConnect        | Connect R to Python                                | `pyConnect()`                                                        |\n| pyDict           | Create a representation of a Python dict in R      | `myNewDict = pyDict('myNewDict', list(p=2, y=9, r=1))`               |\n| pyDir            | The Python function dir (similar to ls)            | `pyDir()`                                                            |\n| pyExec           | Execute Python code                                | `pyExec('some_python_code = \"executed\"')`                            |\n| pyExecfile       | Execute a file (like source)                       | `pyExecfile(\"myPythonFile.py\")`                                      |\n| pyExecg          | Execute Python code and get all assigned variables | `pyExecg('some_python_code = \"executed\"')`                           |\n| pyExecp          | Execute and print Python Code                      | `pyExecp('\"Hello\" + \" \" + \"R!\"')`                                    |\n| pyExit           | Close Python                                       | `pyExit()`                                                           |\n| pyFunction       | Create a representation of a Python function in R  | `pyFunction(key)`                                                    |\n| pyGet            | Get a Python variable                              | `pyGet('myPythonVariable')`                                          |\n| pyGet0           | Get a Python variable                              | `pyGet0('myPythonVariable')`                                         |\n| pyHelp           | Python help                                        | `pyHelp(\"help\")`                                                     |\n| pyImport         | Import a Python module                             | `pyImport(\"numpy\", \"np\")`                                            |\n| pyIsConnected    | Check if R is connected to Python                  | `pyIsConnected()`                                                    |\n| pyList           | Create a representation of a Python list in R      | `pyList(key)`                                                        |\n| pyObject         | Create a representation of a Python object in R    | `pyObject(key)`                                                      |\n| pyOptions        | A function to get and set some package options     | `pyOptions(\"numpyAlias\", \"np\")`                                      |\n| pyPrint          | Print a Python variable from within R              | `pyPrint(\"somePythonVariable\")`                                      |\n| pySet            | Set a R variable in Python                         | `pySet(\"pi\", pi)`                                                    |\n| pySource         | A modified BEGIN.Python aware version of source    | `pySource(\"myFile.R\")`                                               |\n| pyTuple          | Create a representation of a Python tuple in R     | `pyTuple(key)`                                                       |\n| pyType           | Get the type of a Python variable                  | `pyType(\"sys\")`                                                      |\n| pyVersion        | Returns the version of Python                      | `pyVersion()`                                                        |\n\n\n# Usage Examples   \n## Dynamic Documents\n  + **PythonInR and KnitR** [Example](https://gist.github.com/kohske/3e438a7962cacfef9d32)   \n\n## Data and Text Mining   \n  + **PythonInR and word2vec** [Example](https://speakerdeck.com/yamano357/tokyor51-lt)  \n    The word2vec tool takes a text corpus as input and produces the word vectors as output. More information can be found [here](https://code.google.com/p/word2vec/).  \n    [T Mikolov, K Chen, G Corrado, J Dean . \"Efficient estimation of word representations in vector space.\" arXiv preprint arXiv:1301.3781 (2013).](http://arxiv.org/pdf/1301.3781.pdf)  \n    For word2vec also R-packages are available [tmcn (A Text mining toolkit especially for Chinese)](https://r-forge.r-project.org/R/?group_id=1571) and [wordVectors](https://github.com/bmschmidt/wordVectors). An example application of *wordVectors* can be found [here](http://yamano357.hatenadiary.com/entry/2015/11/04/000332).\n    Furthermore it seems to be soon available in [h2o-3](https://github.com/h2oai/h2o-3/blob/master/h2o-r/h2o-package/R/word2vec.R).\n      \n\n  + **PythonInR and Glove** [Example](https://gist.github.com/yamano357/8a31b2dc0c7a20a30d36)  \n    GloVe is an unsupervised learning algorithm for obtaining vector representations for words. More information can be found [here](http://nlp.stanford.edu/projects/glove/).   \n    [Jeffrey Pennington, Richard Socher, and Christopher D. Manning. \"Glove: Global vectors for word representation.\" Proceedings of the Empiricial Methods in Natural Language Processing (EMNLP 2014) 12 (2014): 1532-1543.](http://nlp.stanford.edu/pubs/glove.pdf)\n      \n      \n  + **PythonInR and TensorFlow** [Example](http://qiita.com/yamano357/items/66272759fc29a5a2dd01)  \n    TensorFlow is an open source software library for numerical computation using data flow graphs. More information can be found [here](http://www.tensorflow.org/).  \n    [Martin Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S. Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Ian Goodfellow, Andrew Harp, Geoffrey Irving, Michael Isard, Rafal Jozefowicz, Yangqing Jia, Lukasz Kaiser, Manjunath Kudlur, Josh Levenberg, Dan Mane, Mike Schuster, Rajat Monga, Sherry Moore, Derek Murray, Chris Olah, Jonathon Shlens, Benoit Steiner, Ilya Sutskever, Kunal Talwar, Paul Tucker, Vincent Vanhoucke, Vijay Vasudevan, Fernanda Viegas, Oriol Vinyals, Pete Warden, Martin Wattenberg, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng. \"TensorFlow: Large-scale machine learning on heterogeneous systems.\" (2015).](http://download.tensorflow.org/paper/whitepaper2015.pdf)\n", 
  "id": 38826198
}
{
  "read_at": 1462511511, 
  "description": "Optimal Seed Solver (OSS) is a dynamic-programming algorithm that finds the optimal seeds of a read, which renders the minimum total seed frequency. It is described by Xin et al. at http://arxiv.org/pdf/1506.08235v1.pdf.", 
  "README.md": "# optimal-seed-solver\n\n## Background:\nOptimal Seed Solver (OSS) is a dynamic-programming algorithm that finds the optimal seeds of a read,\nwhich renders the minimum total seed frequency.\n\nSeed selection is an important step for pigeonhole based seed-and-extend read mappers. In seed\nselection, a read is broken into multiple non-overlapping substrings called seeds. Seeds are used as\nanchors to index into the reference genome. To tolerate _e_ errors, a read is typically broken into\n_e+1_ seeds such that by the pigeonhole principle, at least one seed is error free.\n\nThe overall frequency of the selected seeds has a direct impact on the performance of the mapper. If\nseeds are frequent, the mapper has to verify many potential mappings through edit-distance\ncalculation, which is a time-consuming process.\n\nOSS aims to find the least set of _e+1_ non-overlapping seeds from a read using dynamic programing\nmethod. For details about the algorithm of OSS, please consult our manuscript online at:\nhttp://arxiv.org/abs/1506.08235\n\n## Code files:\n\nThis repository contains many code files. Besides hosting the OSS code, it also contains other seed\nselection implementations, code files for main classes and misc code files. Below we summarize each code file.\n\n### Seed selection mechanisms:\n\n+ **optimalSolverLN.h, optimalSolverLN.cc**: contains the code of OSS.\n+ **optimalSolver.h, optimalSolver.cc**: contains the code of an optimal solver that has\nquadruple-complexity. We used this code to verify the integrity of OSS.\n+ **basicSolver.h, basicSolver.cc**: contains the code of a basic solver, which selects seeds at fix\npositions with fixed lengths.\n+ **fastHASHSolver.h, fastHASHSolver.cc**: contains the code simulating the fastHASH seed selection\nmechanism.\n+ **hobbesSolver.h, hobbesSolver.cc**: contains the code simulating the hobbes seed selection\nmechanism.\n+ **spacedSeedSolver.h, spacedSeedSolver.cc**: contains the code simulating the spaced seed\nselection mechanism.\n+ **thresholdSolver.h, thresholdSolver.cc**: contains the code simulating the Gem mapper's seed\nselection mechanism.\n\n### MISC code files:\n\n+ **KmerHash.h, KmerHash.cc**: a hash function that transforms a ASCII string into a 64-bit int number.\n+ **HashTree.h, HashTree.cc**: a suffix tree to index the reference genome. Notice that this\nimplementation is **not optimized for performance**. It was initially built for gathering statistics of\nthe reference genome. For human reference genome it needs 350 GB main memory for indexing. Please\nconsider replacing HashTree with BWT implementations if you plan to integrate OSS into a production\nmapper.\n+ **RefDB.h, RefDB.cc**: a database that caches the reference genome.\n\n### Main classes:\n\nEach seed selection mechanism has a complementary main-code file. They are named in a fashion of\n\"test(mechanism).cc\".\n\n## How to run:\n\nThere are two steps to run OSS (and similarly other seed selection mechanisms):\n\n1. Index the reference genome:\n`$ ./testHashTree referenceName.fasta treeFile.tree`\n\n2. Run OSS:\n`$ ./testOptimalSeedLN treeFile.tree readFile.fastq`\n", 
  "id": 33609992
}
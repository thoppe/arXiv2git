{
  "read_at": 1462547139, 
  "description": "Topology and Parameter Evolving Universal Learning Network Platform", 
  "README.txt": "DXNN v1.0 Erlang,\nBy Gene Sher\nhttp://DXNN.org\nhttp://DXNNResearch.com\nCorticalComputer@gmail.com\n\nBrief documentation for this package is included in this README file.  \n\n-------------\n1. LICENSE\n-------------\n\nCopyright (C) 2009 by Gene Sher, DXNN Research Group, CorticalComputer@gmail.com\nAll rights reserved.\n\nThis code is licensed under the version 3 of the GNU General Public License. Please see the LICENSE file that accompanies this project for the terms of use.\n\n---------------------\n2. USAGE and SUPPORT\n---------------------\n\nI hope that this software will be a useful starting point for your own\nexplorations in the creation of Computational Intelligence. The software is provided \nas is; however, I will do my best to maintain it and accommodate\nsuggestions. If you want to be notified of future releases of the\nsoftware or have questions, comments, bug reports or suggestions, send\nan email to CorticalComputer@gmail.com, or request a user account at www.DXNNResearch.com\n\nAlternatively, you may post your questions on dxnn.org or dxnnresearch.com\n\nThe following explains how to use DXNN.\n\nINTRO\n-----\nDXNN is a fully distributed Topology and Weight Evolving Artificial Neural Network system created and invented by Gene Sher. \nOriginaly introduced in the publication preprint of 2010 available on arXiv:1011.6022v3\nThe current state of the project is composed of the following:\n\nCortex synchronizes Neurons, Sensors, and Actuators. A population monitor controls a population of agents, it is the population_monitor process that spawns agents, waits for them to be evaluated, and then performs the selection, replication, and variation (application of various mutation operators). Furthermore, due to this being a memetic algorithm based system (although can be changed to genetic, by simply switching max_attempts variable to 1), each NN based agent system comes with an exoself process, which performs the synaptic weight tuning.\n\nScapes are simulations, not necessarily of 3d environments. It is through scapes that problems are presented to the agents, and it is the agent's morphology which defines the agent's sensors and actuators, and thus defines which scapes it can interface with. The system itself, the mnesia database, and the top most system, is called polis (It's Greek for city state).\n\nThis version is 1.0, and it does not have a lot of comments (or any), since I built it primarily for myself. But v2.0, which I will release very soon after this, is better and cleaner implemented. Has more functionality, and is fully documented. It is also the version built inside my upcoming book: Neuroevolution Through Erlang, to be released towards the end of this year (just recently submitted my manuscript to my editor). But if you want to give this version a try (feel free to send me an email if you can't get it to work), then by all means go for it. You might find strange comments somewhere in the source code, since I did not take out any notes I wrote for myself.\n\nSTARTING POINT\n--------------\nFrom inside Erlang.\n1. %%%%Compilation%%%%\n\tmake:all().\n2. %%%%Initialize All Databases%%%%\n\tFirst create a folder called \"benchmarks\", the system expects it to exist, and writes files to it when performing benchmarks.\n\tpolis:create(). % This creates the database\n3. %%%%Start The Polis Databases%%%%\n\tpolis:start(). % This starts the polis process, the whole thing, the infrastructure (it runs the scapes...)\n4. At this point you can summon NN based agents or populations of agents, construct Sensors and Actuators and provide them to the NNs... This section will be expanded in future additions.\n\nTo set the population and agents to the preferred sensors and actuators, modify the INIT_CONSTRAINTS (in population_monitor module), and use the particular morphology you want (check the morphology module, different morphologies are for different problems), and then execute population_monitor:start(), which will create the population of size decided by you of agents using the specified morphology and thus the sensors and actuators. If you want the agents to discover and explore the available sensors and actuators (perform feature selection in a sense) then modify modular_constructor, ensuring that you use the get_InitSensors() and get_InitActuators() function, instead of the get_Sensors() and get_Actuators() function used within the module. The get_Init.. starts the population off with the NN based agents using just a single sensor and actuator, exploring other available sensors and actuators within the morphology as they evolve. You can add new sensors and actuators by specifying those sensors and actuators in the morphology module, and then creating those functions in the sensors and actuators modules. New mutation operators, activation functions... all can be added within the records.hrl, as long as those functions are realized/implemented in their respective modules so that they can be executed when called upon.\n\nDXNN V2.0 uses similar algorithms (about 60% the same), but has a different architecture, more scalable, more versatile, simpler, better, and is fully documented. I'll release it as soon as I can.\n", 
  "id": 3864483
}
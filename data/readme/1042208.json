{
  "read_at": 1462543032, 
  "description": "A compressed bitmap class in C++. ", 
  "README.md": "#Compressed bitset in C++\n[![Build Status](https://travis-ci.org/lemire/EWAHBoolArray.png)](https://travis-ci.org/lemire/EWAHBoolArray)\n\n\n\n\n## What is this?\n\nThe class EWAHBoolArray is a compressed bitset data structure.\nIt supports several word sizes by a template parameter (16-bit, 32-bit, 64-bit).\nYou should expect the 64-bit word-size to provide better performance, but\nhigher memory usage, while a 32-bit word-size might compress a bit better,\nat the expense of some performance.\n\nThe library also provides a basic BoolArray class which can serve as a traditional\nbitmap.\n\n\n## Real-world usage\n\nEWAH is used to accelerate the distributed version control system Git (http://githubengineering.com/counting-objects/). You can find the C port of EWAH written by the Git team at https://github.com/git/git/tree/master/ewah\n\nThe Java counterpart of this library (JavaEWAH) is part of Apache Hive and its derivatives (e.g.,  Apache Spark) and Eclipse JGit. It has been used in production systems for many years. It is part of major Linux distributions.\n\n\nThis library is used by database and information retrieval engines\nsuch as Hustle -- A column oriented, embarrassingly distributed relational\nevent database (see https://github.com/chango/hustle).\n\n\n\n## When should you use a bitmap?\n\nSets are a fundamental abstraction in\nsoftware. They can be implemented in various\nways, as hash sets, as trees, and so forth.\nIn databases and search engines, sets are often an integral\npart of indexes. For example, we may need to maintain a set\nof all documents or rows  (represented by numerical identifier)\nthat satisfy some property. Besides adding or removing\nelements from the set, we need fast functions\nto compute the intersection, the union, the difference between sets, and so on.\n\n\nTo implement a set\nof integers, a particularly appealing strategy is the\nbitmap (also called bitset or bit vector). Using n bits,\nwe can represent any set made of the integers from the range\n[0,n): it suffices to set the ith bit is set to one if integer i is present in the set.\nCommodity processors use words of W=32 or W=64 bits. By combining many such words, we can\nsupport large values of n. Intersections, unions and differences can then be implemented\n as bitwise AND, OR and ANDNOT operations.\nMore complicated set functions can also be implemented as bitwise operations.\n\nWhen the bitset approach is applicable, it can be orders of\nmagnitude faster than other possible implementation of a set (e.g., as a hash set)\nwhile using several times less memory.\n\n\n## When should you use compressed bitmaps?\n\nAn uncompress BitSet can use a lot of memory. For example, if you take a BitSet\nand set the bit at position 1,000,000 to true and you have just over 100kB. That's over 100kB\nto store the position of one bit. This is wasteful  even if you do not care about memory:\nsuppose that you need to compute the intersection between this BitSet and another one\nthat has a bit at position 1,000,001 to true, then you need to go through all these zeroes,\nwhether you like it or not. That can become very wasteful.\n\nThis being said, there are definitively cases where attempting to use compressed bitmaps is wasteful.\nFor example, if you have a small universe size. E.g., your bitmaps represent sets of integers\nfrom [0,n) where n is small (e.g., n=64 or n=128). If you are able to uncompressed BitSet and\nit does not blow up your memory usage,  then compressed bitmaps are probably not useful\nto you. In fact, if you do not need compression, then a BitSet offers remarkable speed.\nOne of the downsides of a compressed bitmap like those provided by EWAHBoolArray is slower random access:\nchecking whether a bit is set to true in a compressed bitmap takes longer.\n\n\n## How does EWAH compares with the alternatives?\n\nEWAH is part of a larger family of compressed bitmaps that are run-length-encoded\nbitmaps. They identify long runs of 1s or 0s and they represent them with a marker word.\nIf you have a local mix of 1s and 0, you use an uncompressed word.\n\nThere are many formats in this family beside EWAH:\n\n* Oracle's BBC is an obsolete format at this point: though it may provide good compression,\nit is likely much slower than more recent alternatives due to excessive branching.\n* WAH is a patented variation on BBC that provides better performance.\n* Concise is a variation on the patented WAH. It some specific instances, it can compress\nmuch better than WAH (up to 2x better), but it is generally slower.\n* EWAH is both free of patent, and it is faster than all the above. On the downside, it\ndoes not compress quite as well. It is faster because it allows some form of \"skipping\"\nover uncompressed words. So though none of these formats are great at random access, EWAH\nis better than the alternatives.\n\nThere are other alternatives however. For example, the Roaring\nformat (https://github.com/lemire/RoaringBitmap) is not a run-length-encoded hybrid. It provides faster random access\nthan even EWAH.\n\n\n## Licensing\n\nApache License 2.0.\n\nUpdate (May 20th, 2013): though by default I use the Apache License 2.0 (which is compatible with GPL 3.0), you can *also* consider this library licensed under GPL 2.0.\n\n\n## Dependencies\n\nNone. (Will work under MacOS, Windows or Linux.)\n\nCompilers tested: clang++, g++, Intel compiler, Microsoft Visual Studio\n\nIt works on x64 processors as well as on 32-bit ARM processors. \n\nVersions 0.5 and above assume that the compiler supports the C++11 standard.\n\n# Usage\n\n    make\n    ./unit\n    make example\n    ./example\n\n# Example\n\nPlease see example.cpp.\nFor an example with tabular data, please see example2.cpp.\n\n# Further documentation\n\nIf you have ``doxygen`` installed, you can type ``make doxygen`` and create a documentation folder that might prove useful.\n\n# Further reading\n\nPlease see\n\n* Daniel Lemire, Owen Kaser, Kamel Aouiche, Sorting improves word-aligned bitmap indexes. Data & Knowledge Engineering 69 (1), pages 3-28, 2010. http://arxiv.org/abs/0901.3751\n* Owen Kaser and Daniel Lemire, Compressed bitmap indexes: beyond unions and intersections, Software: Practice and Experience 46 (2), 2016. http://arxiv.org/abs/1402.4466\n\n# Ruby wrapper\n\nJosh Ferguson wrote a wrapper for Ruby.\nThe implementation is packaged and installable as a ruby gem.\n\nYou can install it by typing:\n\n        gem install ewah-bitset\n\n\n\n## Persistent storage\n\nIf you save the bitmap to disk using \"write\" and then try to read it again with \"read\" on a different machine, it *may* crash. The file format is specific to the machine you are using. E.g., using two 64-bit Windows PC might work, but if you send the same data to a 32-bit Linux box it may fail.\n\nYou can get better persistence with the readBuffer and writeBuffer methods. They will be consistent across machines except for bit endianness: you may need to manually check bit endianness. Moreover, these methods require you to save some metadata (i.e., buffersize and sizeinbits) yourself in some portable way.\n\n\nFor saving in a persistent way:\n\n     size_t sb = mybitmap.sizeInBits(); // save sb somewhere safe, your responsibility!\n     size_t bs = mybitmap.bufferSize(); // save bs somewhere safe, your responsibility!\n     mybitmap.writeBuffer(out); // this writes the internal buffer of the bitmap\n\n\nFor loading:\n\n     mybitmap.readBuffer(in,bs); // recover the saved internal buffer, you are responsible for endianness\n     mybitmap.setSizeInBits(sb); // you have to do this to get a proper bitmap size\n", 
  "id": 1042208
}
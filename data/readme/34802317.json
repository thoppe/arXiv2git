{
  "read_at": 1462511932, 
  "description": "Automatic transfer of theorems along isomorphisms in Coq", 
  "README.md": "# Transfer library for Coq\n\nThis library helps you working seamlessly with several representations\nfor the same objects, switching from one to another when doing proofs\nand easily transferring theorems across representations.\n\nA typical workflow would be the following:\n- You define two new types and a few functions on them.\n- You relate the two types and their functions by adequate transfer\ndeclarations.\n- You prove your theorems only once (on the most suited representation)\nand if you need to use them on the other representation, instead of\ndoing ``exact my_thm``, you do ``exactm my_thm`` and the library\ntakes care of the transfer.\n- Similarly, you can use ``applym my_thm`` instead of ``apply my_thm``\nbut it is not guaranteed to work with any type of theorem.\n- Finally, if you have defined your transfer rules properly, you may\nalso be able to change your current proof goal from one representation\nto the other by doing ``transfer`` (this may not work well if you\nhave more than two related representations). This way of using the\ntransfer library was inspired by Isabelle ``transfer'`` tactic.\n\n## Transfer declarations\n\nFirst, you need to define a relation between the two types you\nare considering:\n``R : A -> B -> Prop``.\nIf you are given a function from one type to the other, say ``f : A -> B``,\nyou may define ``R x y := f x = y``.\n\nThen you need to declare properties of this relation, such as injectivity\n(right-uniqueness), functionality (left-uniqueness), surjectivity\n(right-totality) and (left-)totality.\n\nThe corresponding declarations should look like this:\n\n```coq\nInstance injectivity_of_R : Related (R ##> R ##> flip impl) (@eq A) (@eq B).\n\nInstance functionality_of_R : Related (R ##> R ##> impl) (@eq A) (@eq B).\n\nInstance surjectivity_of_R : Related ((R ##> impl) ##> impl) (@all A) (@all B).\n\nInstance totality_of_R : Related ((R ##> flip impl) ##> flip impl) (@all A) (@all B).\n```\n\n[Transfer.v](Transfer.v) contains proofs that the last two declarations correspond\nindeed to surjectivity and totality theorems.\n\nIf some of these properties are not true for relation ``R``, it may be possible to\nprove variants, for instance replacing equality with another equivalence\nor universal quantification with some bounded quantification.\n\n### Compatibility with functions and relations\n\nHere are some examples of such declarations:\n\n```coq\nInstance compat_with_binary_op : Related (R ##> R ##> R) bin_op_A bin_op_B.\n\nInstance compat_with_internal_function : Related (R ##> R) fun_A fun_B.\n\nInstance compat_with_external_function : Related (R ##> eq) fun_from_A fun_from_B.\n\nInstance compat_with_binary_relation_one_way : Related (R ##> R ##> impl) bin_rel_A bin_rel_B.\n\nInstance compat_with_binary_relation_other_way : Related (R ##> R ##> flip impl) bin_rel_A bin_rel_B.\n```\n\nNB: for now, all these declarations will be good only for transferring\ntheorems from ``A`` to ``B``. If you need to go both ways, you should\nadd the corresponding reversed declarations, even when they are equivalent.\nFor instance:\n\n```coq\nInstance compat_with_binary_op' : Related (flip R ##> flip R ##> flip R) bin_op_B bin_op_A.\n```\n\n## Usage of the library\n\n### Transfer of theorems\n\nYou can see examples of transferred theorems in [NArithTests.v](NArithTests.v).\nWhen two theorems have the same form but for related objects (in particular, quantification is\non two different types), you can prove only one of them and use\n``exact (modulo my_proved_thm)`` to get a proof of the other.\nThis will unify the current goal with ``my_proved_thm`` modulo some known relations\n(previously declared as instances of ``Related``).\n\n## Change of representation\n\n``modulo`` is a very general theorem:\n\n```coq\nmodulo : ?t -> ?u\nwhere\n?t : [ |- Prop]\n?u : [ |- Prop]\n?class : [ |- Related impl ?t ?u]\n```\n\nBy calling it through ``exact (modulo thm)`` you are providing it with the values\nof ``?t`` and ``?u`` and it just has to infer a proof of ``Related impl ?t ?u``\nfrom the known ``Related`` instances.\nAnother use however is to call ``apply modulo`` inside a proof development, thus\nproviding ``?u`` but not ``?t``. In some cases, it will be able to also infer\nthe value of ``?t`` and leave you with a transformed goal, thus effectively\noperating a change of representation.\nSince it is a more complicated task, it might also fail, or leave you a transformed\ngoal which does not correspond to what you wanted (in particular when your type\nis related to several other types).\n\nHere is an example of how it can be used to go beyond ``exact (modulo thm)``:\n\n```coq\nRequire Import NArithTransfer.\n\nGoal forall x1 y1 z1 : N, x1 = y1 -> N.add x1 z1 = N.add y1 z1.\nProof.\n  apply modulo. (* Now the goal is: forall x x0 x1 : nat, x = x0 -> x + x1 = x0 + x1 *)\n  intros.\n  Check f_equal2_plus. (* f_equal2_plus : forall x1 y1 x2 y2 : nat, x1 = y1 -> x2 = y2 -> x1 + x2 = y1 + y2 *)\n  apply f_equal2_plus; trivial.\nQed.\n```\n\nThere is an implementation problem which makes it difficult handling theorems\nwhere there is no implication under the quantifiers. To work around this\nlimitation, it may be useful to insert dummy hypotheses as in the following example:\n```coq\nRequire Import NArithTransfer.\n\n(** ** Basic specifications : pred add sub mul *)\n\nGoal forall n, N.pred (N.succ n) = n.\nProof.\n  enough (forall n, True -> N.pred (N.succ n) = n) by firstorder. (* Adding dummy hypothesis *)\n  apply modulo. (* Now the goal is: forall n : nat, True -> Nat.pred (S n) = n *)\n  intros n _.\n  apply PeanoNat.Nat.pred_succ.\nQed.\n```\n\n# Bibliography\n\n* Zimmermann T. and Herbelin H.\n*Automatic and Transparent Transfer of Theorems along Isomorphisms in the Coq Proof Assistant.*\nPresented at CICM 2015 (work-in-progress track).\nRead it\non [HAL](https://hal.archives-ouvertes.fr/hal-01152588)\nor on [arXiv](http://arxiv.org/abs/1505.05028).\n\nNB: you can find the *plugin* described in this paper in the *plugin* branch of this repository.\n", 
  "id": 34802317
}
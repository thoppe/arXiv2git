{
  "read_at": 1462511219, 
  "README.org": "Implementation of Abstracting Abstract Control (http://arxiv.org/pdf/1305.3163v8.pdf)\n\n  - aac.ml: implementation of the CESK*Ks machine (Figure 3). This is a CESK\n    machine with a continuation store separate from the value store.\n  - aac_optimized.ml: implementation of the CESIK*Ks machine (Figure 6). This\n    adds local continuations to the previous machine.\n  - aac_global.ml: implementation of the CESIK*Ks machine with a globalized\n    continuation store (Shiver's timestamp technique)\n  - aac_global_store.ml: implementation of the CESIK*Ks machine with globalized\n    stores (continuation and values).\n  - aac_memo.ml: implementation of the CESK*Ks machine with memoization\n    (Figure 12).\n  - aac_optimized_samemo.ml: adaptation of self-adjusting memoization to the\n    CESIK*Ks machine, with GC\n\nComing up:\n  - aac_optimized_memo.ml: adaptation of memoization to the CESIK*Ks\n    machine. This causes some problems, as the memoization needs to access\n    contexts when evaluating an application (`(e0 e1)` case), but in the CESIK*Ks\n    contexts are only created when stepping into the body of a function. There\n    is therefore no way to access the corresponding context when evaluating an\n    application, since the operand and operators where not yet evaluated. It\n    would be feasible to have two kinds of contexts (one created at function\n    application, one created when stepping into a function's body), but we would\n    lose the advantage of having local continuations (as continuations would be\n    stored before every function application).\n\nTo run:\n#+BEGIN_SRC\n$ make\n$ ./aac.byte # or any other .byte\n#+END_SRC\n\nThis generates a graph for each example program. Those graphs can be viewed with\n/dot/.\n", 
  "description": "Abstracting Abstract Control Implementation in OCaml", 
  "id": 25164774
}
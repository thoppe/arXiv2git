{
  "read_at": 1462544861, 
  "description": "Automatically exported from code.google.com/p/dagger-index", 
  "README.md": "# dagger-index\nAutomatically exported from code.google.com/p/dagger-index\n\n# DAGGER: Reachability Index for Dynamic Graphs #\nThis software is a C++ implementation of the methods proposed in the paper:\n\n> Hilmi Yildirim, Vineet Chaoji and Mohammed J. Zaki : \"_DAGGER: A Scalable Index for Reachability Queries in Large Dynamic Graphs_\", CoRR (Arxiv) abs/1301.0977, 2013 (http://arxiv.org/abs/1301.0977).\n\nPlease cite the papers if you use the software for academic purposes. You can download the whole package from [Downloads](http://code.google.com/p/dagger-index/downloads/list) or svn checkout from [Source](http://code.google.com/p/dagger-index/source/checkout) tab.\n\nPlease read ([README](README.md)) for the proper usage and instructions for installation.\n\nPlease see [SCRIPTS](SCRIPTS.md) for getting some statistics and plots from DAGGER.\n\n## Disclaimer: ##\nThe software is provided on an as is basis for research purposes and licensed under [GNU GPL v3](http://www.gnu.org/licenses/gpl.html). There is no additional support offered, nor are the author(s) or their institutions liable under any circumstances.\n\n## Acknowledgements: ##\nThis work was supported in part by NSF Grant EMT-0829835, and NIH Grant 1R01EB0080161-01A1.\n\n--------------------------------------------------------------\n\n## Contents ##\nThe package is available as a compressed **DAGGER** folder in [Downloads](http://code.google.com/p/dagger-index/downloads/list) and as browsable files in [Source](http://code.google.com/p/dagger-index/source/browse). Once compiled, the package provides the following executables:\n\n  1. **DGRAIL**: The main executable which evaluates the performance of DAGGER, DFS or BFS on a given input graph and an _update file_ (a file that lists the changes to be applied to the graph).\n  1. **correctness**: It checks the correctness of DAGGER/DFS/BFS by comparing the result of each query on a given input graph and update file.\n  1. **Graph Generators**: Random graph generators.\n    * **erGenerator**: Generates a random graph in Erdos-Renyi Model.\n    * **baGenerator**: Generates a random graph in Barabasi-Albert Model.\n  1. **testGenerator**: Given an input graph, it generates a random sequence of valid update operations which can be used to evaluate reachability indices.\n  1. **Graph Extractors**: These extracts an input(i.e., initial) graph from a list of updates and outputs in .gra format. The reason we need this tool is that in some cases updates are available from an empty graph but we want to simulate the evolution of the graph after some point. Therefore these tools apply the updates up to that point, output that graph in .gra format and also output the remaining updates as an update file.\n    * **graphExtractorFromPairs**:\n    * **graphExtractor**:\n\n## Installation ##\nA simple _make_ command in the folder would compile all the code as long as the c++ compiler supports the [C++0x](http://en.wikipedia.org/wiki/C%2B%2B0x) standard. It is because of the dependency to the [hashmap](http://en.wikipedia.org/wiki/Unordered_map_(C%2B%2B))s.\n\nPlease note that in some very large input graphs DGRAIL may give segmentation fault due to stack overflow. The reason is that in a very highly connected graph, a DFS can go very deep during the search. You can overcome this problem by setting a higher stack size.\n\nExample: _ulimit -s 200000_\n\n## Usage ##\n\n### RUNNING DAGGER on a graph and update file ###\nIt prints the input graph statistics at the beginning and at the end of the simulation.\n(e.g. #nodes, #edges, #dagnodes, size of largest SCC)\nAt the end it outputs the total time and particular update time averages.\n\nUsage:\n`./DGRAIL -g <grafile> -t <updatefile> -qpu <queriesperupdate> -type [mg | bmg | dfs | bfs] -dim <#dims>`\n\n**Example DFS RUN**:\n\n`./DGRAIL -g samplegraphs/sample2.gra -t testfiles/mytest.test -type dfs -qpu 5`\n  * No index is used and queries are answered by DFS. For each update in the input graph, 5 random queries are generated and answered.\n\n**Example BFS RUN**:\n\n`./DGRAIL -g samplegraphs/sample2.gra -t testfiles/mytest.test -type bfs -qpu 5`\n  * No index is used and queries are answered by BFS. For each update in the input graph, 5 random queries are generated and answered.\n\n**Example DAGGER RUN with DFS Search**:\n\n`./DGRAIL -g samplegraphs/sample2.gra -t testfiles/mytest.test -type mg -dim 1 -qpu 5`\n  * DAGGER with 1 interval label per node. For each update in the input graph, 5 random queries are generated and answered. Queries are answered by pruned DFS search. If `-dim 0` is set as the dimensionality, then the index maintains no labels so it will be basically a DFS search on the DAG graph (instead of the input graph).\n\n**Example DAGGER RUN with BFS Search**:\n\n`./DGRAIL -g samplegraphs/sample2.gra -t testfiles/mytest.test -type bmg -dim 1 -qpu 5`\n  * DAGGER with 1 interval label per node. For each update in the input graph, 5 random queries are generated and answered. Queries are answered by pruned BFS search. If -dim 0 is set as the dimensionality, then the index maintains no labels so it will be basically BFS search on the DAG graph (instead of the input graph).\n\nIf you want to process the first N lines of the update file, use -n N in the args.\n\n### TESTING CORRECTNESS ###\nYou can check the correctness of the index, anytime you doubt. It has the same usage with DGRAIL. It compares the result of each query with the result of the plain DFS search. It halts with an error message if a mismatch occurs, otherwise it terminates with \"Exiting...\" line.\n\nUsage:\n`./correctness -g <grafile> -t <updatefile> -qpu <queriesperupdate> -type mg -dim 2`\n\nIt is better to give high `<queriesperupdate>` value if the number of updates is small...\n\n### GRAPH GENERATION ###\n\nWe have 3 graph generators that can be used to generate million node graphs:\n> `./erGenerator -n <graphsize> -d <avg_degree>       `: generates erdos-renyi\n\n> `./baGenerator -n <graphsize> -d <avg_degree>       `   : generates albert-barabasi (DAG)\n\n> `./baGenerator -n <graphsize> -d <avg_degree>  -bidir`  : generates albert-barabasi (nondag)\n\nThey print some messages to std err to let you know about the progress. erGenerator is fast, but baGenerator takes some time. Default value of average degree is 4. You can set it to another value with -d flag. It picks a random number from 1 to 2\\*avgdeg for each node, and creates that many edges. It outputs the generated gra file in out.gra\n\n### UPDATE FILE GENERATION ###\n\nWe need to generate test file (update file) for testing an index.\n\nUsage:\n\n`./testGenerator -g <grafile> -n <#updates> [-pie | -pin | -pde | -pdn]`\n\nIt creates n lines of update operations on a given graph. By default it generates a mixed workload\n  * 60% : insert edge\n  * 20% : insert node\n  * 15% : delete edge\n  * 5%  : delete node\n\nHowever it is possible to generate pure workloads with the optional flags:\n  * -pie : only edge insertions\n  * -pin : only node insertions\n  * -pde : only edge deletions\n  * -pdn : only node deletions\n\nBy default, edge insertions are preferential attachment. But it can be set to ER if you give \"-imode 0\" to the program. The program outputs to standard output.\n\n### GRAPH EXTRACTORS ###\n\n  * graphExtractorFromPairs\nGiven a timestamp sorted edge lists (each line has 2 nodes), it creates a gra file with first n lines and convert the remaining list into \"add node\" updates.\n\nExample Usage :\n`./graphExtractorFromPairs -g abc.text -n 10000000`\n\nIt will create abc.text.gra with first 10M lines of _abc.text_ and the remaining lines will be converted to update operations written in _abc.text.gra.up_\n\n  * graphExtractor\nGiven an update list, it creates a gra file with first n line.\nExample Usage:\n`./graphExtractor -g abc.text -n 1000 -t outfile.gra`\n\nThe output gra is saved into _outfile.gra_\n", 
  "id": 32625667
}
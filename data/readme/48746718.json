{
  "read_at": 1462550278, 
  "description": "Perceptually Uniform Colour Maps for Julia", 
  "README.md": "PerceptualColourMaps\n====================\n\n[![Build Status](https://travis-ci.org/peterkovesi/PerceptualColourMaps.jl.svg?branch=master)](https://travis-ci.org/peterkovesi/PerceptualColourMaps.jl)\n\nIf the build status indicates an error click on the build link to\nidentify the version of Julia on which tests have failed. It may be\nthat the build is fine for the stable release of Julia, but failed on\nthe nightly release.\n\n--------------------------------------------\n\n![banner image](doc/banner.png)\n\n## Installation\n\nInstall via the package manager\n```\n> Pkg.add(\"PerceptualColourMaps\")\n```\nIf the above does not work try:\n```\n> Pkg.clone(\"https://github.com/peterkovesi/PerceptualColourMaps.jl.git\")\n```\n\n## Summary\n\nThe Perceptual Colour Maps package  provides functions for creating high quality\ncolour maps that have consistent perceptual contrast over their full range.  It\nalso  provides functions for generating colour map test images, functions to\nassist with the correct rendering of data with colour maps, and functions for\ngenerating relief shaded images and perceptually uniform ternary images.\n\nMany colour maps provided by vendors have highly uneven perceptual\ncontrast over their range. Colour maps may have points of locally high\ncolour contrast leading to the perception of false anomalies in your\ndata when there is none. Conversely colour maps may also have 'flat\nspots' of low perceptual contrast that prevent you from seeing\nfeatures in the data.\n\nTo illustrate this the colour maps shown below are rendered on a test\nimage consisting of a sine wave superimposed on a ramp function. The\namplitude of the sine wave is modulated from its full value at the top\nof the image to 0 at the bottom.\n\nWhat we are hoping to see is the sine wave uniformly visible across\nthe image from left to right. We also want the contrast level, the\ndistance down the image at which the sine wave remains discernible,\nto be uniform across the image. At the very bottom of the image, where\nthe sine wave amplitude is 0, we just have a linear ramp which simply\nreproduces the colour map. Given that the underlying data is a\nfeatureless ramp, we should not perceive any identifiable features\nacross the bottom of the image.\n\n![Vendor Colour Map Problem](doc/VendorColourmapProblem.png)\n\nAt the top row of the test image, the sine wave amplitude from peak to\ntrough is 10% of the total data range. It is not unusual for the sine\nwave pattern to completely disappear in parts of some vendor colour\nmaps. On the other hand the perceptually uniform colour maps exhibit\nno false features and the sine wave pattern is uniformly visible\nacross the full width of the test image.\n\nPrevious work that has tried to use CIELAB space for the design of colour maps\nhas had mixed results.  This is because CIELAB space is only perceptually\nuniform for large patches of colour presented at very low spatial frequencies.\nThe key observation is that at fine spatial frequencies perceptual contrast is\ndominated by *lightness* difference; chroma and hue are relatively unimportant.\nThe colour maps generated by `cmap()` are designed to have a lightness gradient of\nconstant magnitude.\n\n\n## cmap()\n\n`cmap()` is the main function you will use.  It provides a library of\nperceptually uniform colour maps.  For a full description of all the\nfunctions in the package, see the [Function reference](doc/index.md).\n\n```\nUsage:  1:  (map, name, desc) = cmap(I, keyword_params ...)\n        2:  cmap(searchStr)\n        3:  cmap()\n\nArguments for Usage 1:\n\n            I - A string label indicating the colour map to be generated or a\n                string specifying a colour map name or attribute to search\n                for.  Type 'cmap()' with no arguments to get a full list of\n                possible colour maps and their corresponding labels.\n\n  labels:  \"L1\" - \"L15\"  for linear maps\n           \"D1\" - \"D12\"  for diverging maps\n           \"C1\" - \"C9\"   for cyclic maps\n           \"R1\" - \"R3\"   for rainbow maps\n           \"I1\" - \"I3\"   for isoluminant maps\n\n Some colour maps have alternate labels for convenience and readability.\n\n   map = cmap(\"L1\")  or map = cmap(\"grey\")  will produce a linear grey map.\n   cmap()  lists all colour maps and labels.\n\n Possible keyword parameter options:\n\n    chromaK::Real - The scaling to apply to the chroma values of the colour map,\n                    0 - 1.  The default is 1 giving a fully saturated colour map\n                    as designed. However, depending on your application you may\n                    want a colour map with reduced chroma/saturation values.\n                    You can use values greater than 1 however gamut clipping is\n                    likely to occur giving rise to artifacts in the colour map.\n           N::Int - Number of values in the colour map. Defaults to 256.\n      shift::Real - Fraction of the colour map length N that the colour map is\n                    to be cyclically rotated, may be negative.  (Should only be\n                    applied to cyclic colour maps!). Defaults to 0.\n    reverse::Bool - If true reverses the colour map. Defaults to false.\ndiagnostics::Bool - If true displays various diagnostic plots. Note the\n                    diagnostic plots will be for the map _before_ any cyclic\n                    shifting or reversing is applied. Defaults to false.\n\nReturns:\n          map - Array of ColorTypes.RGB{Float64,1} giving the rgb colour map\n         name - A string giving a nominal name for the colour map\n         desc - A string giving a brief description of the colour map\n```\nUsage 2 and 3:  `cmap(searchStr)`\n\nGiven the large number of colour maps that this function can create this usage\noption provides some help by listing the numbers of all the colour maps with\nnames containing the string 'str'.  Typically this is used to search for\ncolour maps having a specified attribute: \"linear\", \"diverging\", \"rainbow\",\n\"cyclic\", or \"isoluminant\" etc.  If 'searchStr' is omitted, all colour maps are\nlisted.  \n\n```\n   cmap()              # lists all colour maps\n   cmap(\"diverging\")   # lists all diverging colour maps\n```\nNote the listing of colour maps can be a bit slow because each colour map has to\nbe created in order to determine its full name.\n\n**Using the colour maps:**\n\n```\n> Using PyPlot\n> sr = sineramp();    # Generate the sineramp() colour map test image.\n> imshow(sr);         # Display with matplotlib's default 'jet' colour map.\n                      # Note the perceptual dead spots in the map.\n> set_cmap(ColorMap(cmap(\"L3\")[1])) # Apply the cmap() heat colour map.\n```\nNote above in the call `cmap(\"L3\")[1]`, the `[1]` ensures that just the colour\nmap in the tuple returned by `cmap()` is passed to the `PyPlot.ColorMap`\nconstructor\n\n```\n> Using Winston\n> colormap(cmap(\"R1\")[1]); # Set Winston's colour map to the cmap() rainbow\n                           # colour map first.\n> imagesc(sr);             # Then display the image\n\n```\n\nYou can also apply a colour map to a single channel image to create a\nconventional RGB image. This is recommended if you are using a\ndiverging or cyclic colour map because it allows you to ensure data\nvalues are honoured appropriately when you map them to colours.\n\n```\n  Apply the L4 heat colour map to the test image\n> rgbimg = applycolourmap(sr, cmap(\"L4\")[1]);\n\n  Apply a diverging colour map to the test image using 127 as the\n  value that is associated with the centre point of the diverging\n  colour map\n> rgbimg = applydivergingcolourmap(sr, cmap(\"D1\")[1],127);\n\n  Apply a cyclic colour map to the circlesineramp() test image specifying\n  a data cyclelength of 2*pi.\n> (cr,) = circlesineramp();   # Generate a cyclic colour map test image.\n> rgbimg = applycycliccolourmap(cr, cmap(\"C1\")[1], cyclelength=2*pi);\n\n> ImageView.view(rgbimg)      # Display the image with ImageView\n> PyPlot.imshow(rgbimg)       # or with PyPlot\n```\n*Warning* PyPlot and Tk do not seem to coexist very well (Julia can\ncrash!).  ImageView and Winston use Tk which means that you may have\nto take care which image display functions you choose to use.\n\nThese colour maps can also be passed to the `Plots.ColorGradient` constructor.\nHere's an example using the 'Rainbow 3' diverging colour map for a scatter plot.\n```\n> Using Plots\n> y=rand(100); scatter(y, zcolor=y, marker=ColorGradient(cmap(\"R3\")[1]))\n```\n\n\n## Organisation of the Colour Maps\n\nThe colour maps are organised according to the attributes: Linear,\nDiverging, Rainbow, Cyclic, and Isoluminant.\n\n![Linear Colour Map](doc/linear_kry_5-98_c75_n256.png)\n\n**Linear** colour maps are intended for general use and have colour\nlightness values that increase or decrease linearly over the colour\nmap's range.\n\n![Diverging Colour Map](doc/diverging_bwr_40-95_c42_n256.png)\n\n**Diverging** colour maps are suitable where the data being displayed\nhas a well defined reference value and we are interested in\ndifferentiating values that lie above, or below, the reference\nvalue. The centre point of the colour map will be white, black or\ngrey. `cmap()` provides diverging maps that have endpoints that are\nmatched in both lightness and chroma.  It should be noted that, in\ngeneral, diverging colour maps have a small perceptual flat spot at\nthe centre. The exception being linear-diverging maps which avoid this\nproblem, try `cmap(\"D7\")`.\n\n![Rainbow Colour Map](doc/rainbow_bgyrm_35-85_c71_n256.png)\n\n**Rainbow** colour maps are widely used but often misused. It is\nsuggested that they be avoided because they have reversals in the\nlightness gradient at yellow and red which can upset a viewer's\nperceptual ordering of the colours in the colour map. However, they\nare attractive and perhaps can have a legitimate use where the main\naim is to differentiate data values rather than communicate a data\nordering. I believe the rainbow colour maps generated by `cmap()` (\"R1\"\nor \"R2\") have minimal badness though they do have localised perceptual\nflat spots at yellow and red. `cmap(\"R3\")` is a useful diverging rainbow\ncolour map.\n\n![Cyclic Colour Map](doc/c_cyclic_mygbm_30-95_c78_n256.png)\n\n**Cyclic** colour maps have colours that are matched at each end. They\nare intended for the presentation of data that is cyclic such as\norientation values or angular phase data. They require particular care\nin their design (the standard colour circle is not a good map). `cmap()`\nprovides cyclic maps that partition the circle into four colours,\nsuitable for visualising orientation data (try `cmap(\"C1\")`), and into\ntwo colours for visualising phase data (try `cmap(\"C4\")`).\n\n![Isoluminant Colour Map](doc/isoluminant_cgo_80_c38_n256.png)\n\n**Isoluminant** colour maps are constructed from colours of equal\nperceptual lightness. These colour maps are designed for use with\nrelief shading. On their own these colour maps are not very useful\nbecause features in the data are very hard to discern. However, when\nused in conjunction with relief shading their constant lightness means\nthat the colour map does not induce an independent shading pattern\nthat can interfere with, or even hide, the structures induced by the\nrelief shading. The relief shading provides the structural information\nand the colours provide the data classification information.\n\n## Links\n* [Function reference](doc/index.md)\n* [MATLAB code](http://www.peterkovesi.com/matlabfns/index.html#colour)\nfrom which this Julia code was ported.\n* [A set of perceptually uniform colour map\n  files](http://peterkovesi.com/projects/colourmaps/index.html)\n  prepared for use with a number of standard visualisation packages.\n* Reference: Peter Kovesi. Good Colour Maps: How to Design Them.\n  [arXiv:1509.03700 [cs.GR] 2015](https://arxiv.org/abs/1509.03700)\n", 
  "id": 48746718
}
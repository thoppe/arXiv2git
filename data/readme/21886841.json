{
  "read_at": 1462551003, 
  "description": "Julia package for high-precision quadrature", 
  "README.md": "# DEQuadrature.jl\n\nThe aim of this `Julia` package is to be the fastest general purpose quadrature package in Julia.\nIt supports the canonical interval, and semi-infinite and infinite domains in arithmetic up to\nand including `BigFloat` and provides support for maximizing convergence rates when complex\nsingularities are present near the contour of integration. Since the package can handle integrable\nalgebraic and logarithmic endpoint singularities, and since it allows the user to consider other\ndomains by declaring a new instance of the type `Domain`, the package is general purpose.\n\nThe primary function of this module computes the nodes and weights\nof the trapezoidal rule after a variable transformation induces\ndouble exponential endpoint decay. In addition, the variable transformations\nmaximize the convergence rate despite complex singularities near the solution interval.\n\nThe secondary function of this module computes the parameters of the\nconformal map `h(t)` in Eq. (3.14) of <a href=\"http://dx.doi.org/10.1137/140978363\">[1]</a>.\nThis module requires the use of the Julia package Ipopt for solving the nonlinear program.\n\n```julia\nPkg.clone(\"https://github.com/MikaelSlevinsky/SincFun.jl.git\")\nPkg.clone(\"https://github.com/MikaelSlevinsky/DEQuadrature.jl.git\")\nusing SincFun, DEQuadrature\n```\n\n### Example 4.1 from <a href=\"http://dx.doi.org/10.1137/140978363\">[1]</a>\n\nSuppose we are interested in calculating the integral of:\n\n```julia\nf(x) = exp(1./abs2(x-z[1]))./abs2(x-z[2])\n```\n\non the interval `[-1,1]` with the singularities:\n\n```julia\nz = [complex(-0.5,1.0),complex(0.5,0.5)]\n```\n\nas well as a square root singularity at the left endpoint and a logarithmic singularity at the right endpoint. We use the package function `DEMapValues` to calculate the optimized map and the function `DENodesAndWeights` to calculate nodes and weights. Looping over a geometrically increasing order, we can approximate the integral very accurately:\n\n```julia\nh = DEMapValues(z;domain=Finite(-1.0,1.0,-0.5,0.0,0.0,1.0))\nfor i = 1:6\n\tx,w = DENodesAndWeights(h,2^i;b2factor=0.5,domain=Finite(-1.0,1.0,-0.5,0.0,0.0,1.0))\n\tval = dot(f(x),w)\n\terr = abs(val-parse(Float64,DEQuadrature.example4p1))\n\tprintln(@sprintf(\"Order: %2i Value: %19.16e Relative error: %6.2e\",i,val,err))\nend\n```\n\n### Example 4.2 from <a href=\"http://dx.doi.org/10.1137/140978363\">[1]</a>\n\nThe package has equal support for `BigFloat`s, making high precision calculations a breeze! Suppose we are interested in calculating the integral of:\n\n```julia\nf(x) = exp(10./abs2(x-z[1])).*cos(10./abs2(x-z[2]))./abs2(x-z[3])./abs(x-z[4])\n```\n\non the real line with the singularities:\n\n```julia\nz = [complex(big(-2.0),1.0),complex(-1.0,.5),complex(1.0,0.25),complex(2.0,1.0)]\n```\n\nWe start by setting the `digits` we desire:\n\n```julia\nDEQuadrature.digits(100)\n```\n\nThen, we use the package function `DEMapValues` to calculate the optimized map and the function `DENodesAndWeights` to calculate nodes and weights. Looping over a geometrically increasing order, we can approximate the integral very accurately:\n\n```julia\nh = DEMapValues(z;domain=Infinite1(BigFloat))\nfor i = 1:10\n\tx,w = DENodesAndWeights(h,2^i;domain=Infinite1(BigFloat))\n\tval = dot(f(x),w)\n\terr = abs(val-parse(BigFloat,DEQuadrature.example4p2))\n\tprintln(@sprintf(\"Order: %2i Value: %19.16e Relative error: %6.2e\",i,val,err))\nend\n```\n\n### Example 4.4 from <a href=\"http://dx.doi.org/10.1137/140978363\">[1]</a>\n\nSuppose we are interested in calculating the integral of:\n\n```julia\nf(x) = x./abs(x-z[1])./abs2(x-z[2])./abs2(x-z[3])\n```\n\non `[0,[?])` with the singularities:\n\n```julia\nz = [complex(big(1.0),1.0),complex(2.,.5),complex(3,1//3)]\n```\n\nWe use the package functions `sincpade` and `polyroots` to compute the approximate locations of the singularities adaptively. Then, we use the package function `DENodesAndWeights` to calculate the optimized nodes and weights. Looping over a geometrically increasing order, we can approximate the integral very accurately:\n\n```julia\nx = zeros(BigFloat,5);\nfor i = 1:4\n\tx,w = DENodesAndWeights(Complex{BigFloat}[],2^i;domain=SemiInfinite2(BigFloat))\n\tval = dot(f(x),w)\n\terr = abs(val-parse(BigFloat,DEQuadrature.example4p4))\n\tprintln(@sprintf(\"Order: %2i Value: %19.16e Relative error: %6.2e\",i,val,err))\nend\nfor i = 5:8\n\t(p,q) = sincpade(f(x),x,div(length(x)-1,2),i-2,i+2)\n\trootvec = polyroots(q)\n\tx,w = DENodesAndWeights(convert(Vector{Complex{BigFloat}},rootvec[end-4:2:end]),2^i;domain=SemiInfinite2(BigFloat),Hint=25)\n\tval = dot(f(x),w)\n\terr = abs(val-parse(BigFloat,DEQuadrature.example4p4))\n\tprintln(@sprintf(\"Order: %2i Value: %19.16e Relative error: %6.2e\",i,val,err))\nend\n```\n\n\n# References:\n\n\n   1.\tR. M. Slevinsky and S. Olver. <a href=\"http://dx.doi.org/10.1137/140978363\">On the use of conformal maps\n\t\tfor the acceleration of convergence of the trapezoidal rule\n\t\tand Sinc numerical methods</a>, SIAM J. Sci. Comput., 37:A676--A700, 2015.\n    An earlier version appears here: <a href=\"http://arxiv.org/abs/1406.3320\"> arXiv:1406.3320</a>.\n", 
  "id": 21886841
}
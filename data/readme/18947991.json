{
  "README": "Gobby is a simplified Chubby implemented in Go.\n\nTo be precise, Gobby is a reliable distributed key-value store based on Paxos,\nand can provide coordination service for distributed applications, including\nlocks and notifications.\n\n--------------------------------------------------------------------------------\nRPC Interface for Gobby\n--------------------------------------------------------------------------------\n\nPut(key, value)         ---- assign key-value pair.\nGet(key)                ---- get value.\nAcquire(key)            ---- acquire the lock on the key (every key can be\n                               used as a lock).\nRelease(key)            ---- release the lock on the key.\nWatch(key)              ---- notifies me when the value associated with this\n                               key changes.\nCheckMaster()           ---- check whether this gobby server is the master.\n\n--------------------------------------------------------------------------------\nStructure\n--------------------------------------------------------------------------------\n\nREADME                  ---- this file.\nfmt.sh                  ---- format go code.\nkill_mac.sh             ---- kill all running nodes for mac OS.\nkill_linux.py           ---- kill all running nodes for linux OS.\n\nsrc/command             ---- command struct definition.\nsrc/config              ---- configuration of servers.\nsrc/gobbyclient         ---- gobby client library.\nsrc/gobbyserver         ---- gobby server implementation.\nsrc/lease               ---- PaxosLease manager.\nsrc/logfile             ---- persistent logger for recovery (not used).\nsrc/paxos               ---- Paxos for replicated command log.\nsrc/rpc                 ---- rpc definitions.\n\ngobby_test/             ---- tests for gobby server and client.\npaxos_test/             ---- tests for Paxos on the replicated command log.\nlease_test/             ---- tests for PaxosLease for signing master lease.\n\n\n--------------------------------------------------------------------------------\nTest\n--------------------------------------------------------------------------------\n\nIn each test directory, we offer one run.sh script, which can automatically run\nthe test. Some test cases might not terminate by themselves, and need to kill them\nmanually. We offer scripts to kill all running nodes for mac or linux.\n\ngobby_test/\n  1s1c                  ---- one gobby server and one client, basic functions.\n  3s1c                  ---- three gobby servers and one client.\n  3s3c_normal           ---- three gobby servers and three clients. Three clients \n\t\t\t     want to update a shared variable stored in the gobby\n\t\t\t     storage system, in a atomical way.\n  3s3c_delay            ---- three gobby servers and three clients, and the pkg\n\t\t\t     transfered between paxos nodes are randomly delayed.\n  3s3c_drop             ---- three gobby servers and three clients, and the pkg \n\t\t\t     transfered between paxos nodes are randomly dropped.\n  5s10c_normal          ---- five gobby servers and ten clients. The task is the\n\t\t\t     same as 3s3c_normal.\n  5s10c_drop            ---- the same as the above one, but drop network pkg.\n\npaxos_test/\n  X_normal_test         ---- launch X paxos nodes, and each paxos node replicates\n\t\t\t     a number of commands.\n  X_pause_test          ---- launch X paxos nodes, and cut off one node's network.\n\t\t\t     Then other nodes try to replicate their own commands.\n\t\t\t     After other nodes have consensus on these commands,\n\t\t\t     let the node re-connect the other nodes and try to\n\t\t\t     replicate a command. The node can learn all commands\n\t\t\t     from other nodes.\n  X_pause_test1         ---- launch X paxos nodes, and cut off one node's network.\n\t\t\t     Then other nodes try to replicate their own commands.\n\t\t\t     After other nodes have consensus on these commands,\n\t\t\t     let the node re-connect the other nodes and one other\n\t\t\t     node tries to replicate a command. The node learns\n\t\t\t     (or say catch up) all commands from other nodes.\n  X_random_delay_test   ---- almost the same as X_normal_test. The only difference\n\t\t\t     is the network may randomly delay messages.\n  X_random_drop_test    ---- almost the same as X_normal_test. The only difference\n\t\t\t     is the network may randomly drop messages.\n  X_stress_test         ---- launch X paxos nodes, and each paxos node tries to do\n\t\t\t     replication for a large number of commands.\n  5_pause2_test         ---- launch five paxos nodes, and pause two of them. Other\n\t\t\t     three nodes can work correctly and have consensus on\n\t\t\t     several commands. Then we resume the two nodes, and \n\t\t\t     these two can learn all commands from other nodes.\n\nlease_test/\n  X_normal\t\t---- launch X lease nodes, and one of them can be elected\n\t\t\t     as the master. If we kill the master, a new master \n\t\t\t     will be elected soon, as long as a majority of nodes\n\t\t\t     survive. If we restart some node, it will join the\n\t\t\t     electoin process.\n  X_drop                ---- almost the same as X_normal, but may drop messages\n\n\n--------------------------------------------------------------------------------\nSystem Design\n--------------------------------------------------------------------------------\nGobby is consist of two parts, the client side gobby library and the gobby server.\n\nThe user of gobby will use gobby client library to communicate with the server.\nThe client library offers interface just like local functions, but their implement\nare all based on RPC calls to the remote server. The client library will try to \nconnect each server until it finds the master gobby server, and then it forwards\nall users' requests to the master server. If the master server is no longer master,\nthe library will try to find the new master server automatically.\n\nThe gobby server has two main components, the paxos node, the paxos lease node.\n\nThe paxos node is responsible to make a consensus on a command log. They run paxos\nprotocal and use RPC to communicate between each other. Gobby relies on the paxos\nnode to replicate, serialize and make consensus on commands.\n\nThe paxos lease node is responsible to elect a master for gobby. Our code is based \non the paper \"PaxosLease:Diskless Paxos for Leases\"[1]. It uses a modified paxos\nprotocal to elect a global leader, and makes sure that there is at most one leader\nat any time. Only the leader/master can response requests from clients. The reason\nwe do this is to reduce paxos conflicts by serialize commands before doing paxos\ninstance. At master node, we can serialize commands according to the arriving time.\n\nThe gobby server is mainly build upon the above two components. It handles the \nrequest from client library with a paxos node and a paxos lease node. When master \nreceives a request, it translates the request into one command, which can modify\nthe server's state, and puts the command into a queue. Another go routine fetches \nthe command and pass it to paxos node to replicate the command. A pre-registered \ncallback function is called from the paxos node to notify the gobby server, when\nthe command is successfully replicated. The gobby server can excute the command\non itself(or its inner data structure) as long as there is no gap in the log.\nThe consistency, correctness and no gap is guarantee by the paxos protocal runned\nby the paxos node. After the command has been excuted, the server will generate\nreturn message to the caller.\n\n[1] Trencseni, Marton, Attila Gazso, and Holger Reinhardt. \"PaxosLease: Diskless \nPaxos for Leases.\" arXiv preprint arXiv:1209.4187 (2012).\n", 
  "read_at": 1462550841, 
  "description": "", 
  "id": 18947991
}
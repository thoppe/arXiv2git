{
  "read_at": 1462550730, 
  "description": "Julia package for solving singular integral equations and Riemann\u2013Hilbert problems", 
  "README.md": "# SingularIntegralEquations.jl\n\n[![Build Status](https://travis-ci.org/ApproxFun/SingularIntegralEquations.jl.svg?branch=master)](https://travis-ci.org/ApproxFun/SingularIntegralEquations.jl)\n\nAn experimental Julia package for solving singular integral equations.\n\n\n# Acoustic Scattering\n\n[HelmholtzDirichlet.jl](https://github.com/ApproxFun/SingularIntegralEquations.jl/blob/master/examples/HelmholtzDirichlet.jl) and [HelmholtzNeumann.jl](https://github.com/ApproxFun/SingularIntegralEquations.jl/blob/master/examples/HelmholtzNeumann.jl) calculate the solution to the Helmholtz equation with Dirichlet and Neumann boundary conditions. The essential lines of code are:\n\n```julia\nk = 50 # Set wavenumber and fundamental solution for Helmholtz equation\ng1(x,y) = -besselj0(k*abs(y-x))/2\ng2(x,y) = x == y ? -(log(k/2)+g)/2/p + im/4 : im/4*hankelh1(0,k*abs(y-x)) - g1(x,y).*logabs(y-x)/p\n\nui(x,y) = exp(im*k*(x-y)/sqrt(2))    # Incident plane wave at 45deg\n\ndom = Interval()                     # Set the domain\nsp = Space(dom)                      # Canonical space on the domain\n = DefiniteLineIntegral(dom)        # Line integration functional\nuiG = Fun(t->ui(real(t),imag(t)),sp) # Incident wave on G\n\n# Instantiate the fundamental solution\nG = GreensFun(g1,CauchyWeight(sp[?]sp,0)) + GreensFun(g2,sp[?]sp)\n\n# Solve for the density\n[?]u[?]n = [G]\\uiG\n\n# What is the forward error?\nnorm([G]*[?]u[?]n-uiG)\n\n# Represent the scattered field\nus(x,y) = -logkernel(g1,[?]u[?]n,complex(x,y))-linesum(g2,[?]u[?]n,complex(x,y))\n```\n\nHere is an example with 10 sources at the roots of unity scaled by 2 and scattered by multiple disjoint intervals and circles.\n\n![Helmholtz Scattering](https://github.com/ApproxFun/SingularIntegralEquations.jl/raw/master/images/Helmholtz.gif)\n\n[GravityHelmholtz.jl](https://github.com/ApproxFun/SingularIntegralEquations.jl/blob/master/examples/GravityHelmholtz.jl) calculates the solution to the gravity Helmholtz equation with Dirichlet boundary conditions.\n\n![Gravity Helmholtz Scattering](https://github.com/ApproxFun/SingularIntegralEquations.jl/raw/master/images/GravityHelmholtz.gif)\n\n\n# The Faraday Cage\n\n[Laplace.jl](https://github.com/ApproxFun/SingularIntegralEquations.jl/blob/master/examples/Laplace.jl) calculates the solution to the Laplace equation with the origin shielded by infinitesimal plates centred at the Nth roots of unity. The essential lines of code are:\n\n```julia\nui(x,y) = logabs(complex(x,y)-2)     # Single source at (2,0) of strength 2p\n\nN,r = 10,1e-1\ncr = exp(im*2p*(0:N-1)/N)\ncrl,crr = (1-2im*r)cr,(1+2im*r)cr\ndom = [?](Interval,crl,crr)            # Set the shielding domain\n\nsp = Space(dom)                      # Canonical space on the domain\n = DefiniteLineIntegral(dom)        # Line integration functional\nuiG = Fun(t->ui(real(t),imag(t)),sp) # Action of source on shields\n\n# Instantiate the fundamental solution\nG = GreensFun((x,y)->1/2,CauchyWeight(sp[?]sp,0))\n\n# The first column augments the system for global unknown constant charge ph0\n# The first row ensure constant charge ph0 on all plates\nph0,[?]u[?]n=[0 ;1 [G]]\\Any[0.,uiG]\n\n# Represent the scattered field\nus(x,y) = -logkernel([?]u[?]n,complex(x,y))/2\n```\n\n![Faraday Cage](https://github.com/ApproxFun/SingularIntegralEquations.jl/raw/master/images/FaradayCage.png)\n\n\n# Riemann-Hilbert Problems\n\nSingularIntegralEquations.jl has support for Riemann-Hilbert problems and Wiener-Hopf factorizations.  [Wiener-Hopf.jl](https://github.com/ApproxFun/SingularIntegralEquations.jl/blob/master/examples/Wiener-Hopf.jl) uses the Winer-Hopf factorization to calculate the UL decomposition of a scalar and a block Toeplitz operator.  The essential lines of code in the matrix case are:\n\n```julia\nG=Fun(z->[-1 -3; -3 -1]/z +\n         [ 2  2;  1 -3] +\n         [ 2 -1;  1  2]*z,Circle())\n\nC  = Cauchy(-1)\nV  = V=(I+(I-G)*C)\\(G-I)\n\nL  = ToeplitzOperator(inv(I+C*V))\nU  = ToeplitzOperator(I+V+C*V)\n```\n\n# References\n\nR. M. Slevinsky & S. Olver, <a href=\"http://arxiv.org/abs/1507.00596\">A fast and well-conditioned spectral method for singular integral equations</a>, arXiv:1507.00596, 2015.\n", 
  "id": 19065007
}
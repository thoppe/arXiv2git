{
  "read_at": 1462543097, 
  "description": "C++ code that generates Python code to try to find all the minima of a 1-loop effective potential energy function.", 
  "README.txt": "/*****************************************************************************\\\n * README.txt                                                                *\n *                                                                           *\n *  Created on: Oct 8, 2012                                                  *\n *      Authors: Ben O'Leary (benjamin.oleary@gmail.com)                     *\n *      Copyright 2012 Ben O'Leary                                           *\n *                                                                           *\n *      This file is part of Vevacious, a program designed to find the       *\n *      configuration of vacuum expectation values (VEVs) for the global     *\n *      minimum of a quantum field theory potential energy function.         *\n *                                                                           *\n *      Vevacious is free software: you can redistribute it and/or modify it *\n *      under the terms of the GNU General Public License as published by    *\n *      the Free Software Foundation, either version 3 of the License, or    *\n *      (at your option) any later version.                                  *\n *                                                                           *\n *      Vevacious is distributed in the hope that it will be useful, but     *\n *      WITHOUT ANY WARRANTY; without even the implied warranty of           *\n *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU     *\n *      General Public License for more details.                             *\n *                                                                           *\n *      You should have received a copy of the GNU General Public License    *\n *      (in HoTTMiLC/GNU_public_license.txt ) along with Vevacious. If not,  *\n *      see <http://www.gnu.org/licenses/>.                                  *\n *      A full list of the files of Vevacious is at the end of this file.    *\n\\*****************************************************************************/\n\n Now that the legalese preamble is out of the way, the description of the code\n and how to use it can begin!\n\n Vevacious is a program written in C++ to try to find the global minimum of a\n loop-corrected potential. It is designed to be used in conjuction with SARAH\n by Florian Staub and utilizes HOM4PS2 by Tsung-Lin Lee, Tien-Yien Li, and\n Chih-Hsiung Tsai, PyMinuit by Jim Pivarski, implementing the MINUIT\n algorithms by Fred James, and CosmoTransitions, by Carroll (Max) Wainwright.\n \n Vevacious is an implementation of the process of attempting to find the global\n minimum of a potential as decided upon by the collaboration of\n Jos Eliel Camargo (elielx@gmail.com),\n Ben O'Leary (benjamin.oleary@gmail.com),\n Werner Porod (porod@physik.uni-wuerzburg.de), and\n Florian Staub (florian.staub@googlemail.com). This README file was written by\n Ben O'Leary.\n \n A manual describing the physics and process of Vevacious is available from\n http://arxiv.org/abs/1307.1477 and there is a quickstart guide available from\n http://vevacious.hepforge.org/ following the appropriate link. An rough\n version of the installation instructions is also contained in this README\n file, below the description of the process.\n \n Vevacious runs in 2 stages: first it prepares the tree-level tadpole equation\n system and then solves it with HOM4PS2, and second, it uses the tree-level\n solutions as starting points for minimizing the 1-loop-level potential with\n PyMinuit, including, if a deeper minimum than that desired was found,\n calculating a tunneling time or an upper bound using CosmoTransitions.\n \n The first part writes a system of tadpole equations for a given set of\n parameters (provided in SLHA format, presumably from a version of SPheno\n created by SARAH) for a given model (created by SARAH) using the general form\n of the tree-level tadpole equations in a file provided by SARAH, in the format\n required by HOM4PS2. it then runs HOM4PS2 and parses its output. At this\n stage, the tree-level extrema can be printed out as a file in a\n Mathematica-friendly format (which I hope is also reasonably human-readable).\n In principle the homotopy continutation algorithm finds _all_ the extrema of\n the tree-level potential, but finite-precision and finite-step-size issues\n mean that any algorithm will sometimes miss some extrema. The user should be\n aware of this.\n\n The second part takes the results of HOM4PS2 as the starting points for\n minimizing the loop-corrected potential with PyMinuit. It does this by writing\n a program in Python with the tree-level potential and all the loop corrections\n for the specific values of the Lagrangian parameters found in the SLHA file\n from the general forms taken from a file provided by SARAH for the given\n model. This potential is then minimized by PyMinuit starting from each unique\n extremum found by HOM4PS2 (ignoring solutions with complex roots, because\n SARAH already writes any complex fields as 2 real degrees of freedom, so only\n real roots are valid solutions of the provided system of tadpole equations).\n The deepest minimum thus found is written in the output file in XML, which,\n again, I hope is reasonably human-readable. (The other minimization results\n are available by default in Vevacious_loop-corrected_results.txt in a\n Mathematica-friendly format.)\n There is no guarantee that the loop corrections do _not_ introduce new minima\n beyond the number of minima that the tree-level potential has. By default,\n Vevacious will move the MINUIT object off saddle points in the steepest\n direction and its mirror, so will find minima that develop when a tree-level\n minimum becomes a one-loop-level saddle point (such as the origin for SPS1a'\n in a certain renormalization scheme).\n There is also no guarantee that the MINUIT minimization starting from the\n tree-level extrema will find as many minima as the tree-level potential has,\n regardless of whether the loop corrections introduce more minima. The user\n should be aware that this program tries to find the global minimum of the\n loop-corrected potential, but it could fail to find it if the loop corrections\n are sufficiently large.\n\n So, if the above limitations are not a problem, the following instructions\n should allow a successful installation:\n 1) Download SARAH. The files are available at\n    http://sarah.hepforge.org/\n    (link last checked 2013-08-29). The installation is as simple as unpacking\n    the gzipped tarball.\n 2) Download HOM4PS2. The files are available at\n    http://www.math.nsysu.edu.tw/~leetsung/works/HOM4PS_soft_files/HOM4PS_Linux.htm\n    (link last checked 2013-08-29). The installation is as simple as unpacking\n    the gzipped tarball.\n 3) Ensure that Python is installed. PyMinuit requires at least version 2.4 or\n    later. I shouldn't have to get into any specifics of how to install Python\n    here... Internet search engines are your friends.\n 4) Download and install a Python wrapper for MINUIT. Currently only PyMinuit\n    and IMinuit are supported.\n    a) The instructions for PyMinuit were available at\n       http://code.google.com/p/pyminuit/wiki/HowToInstall\n       (link last checked 2015-11-30), but the project has been abandoned by\n       its author. The installation involves downloading and compiling one of\n       the C++ implementations of MINUIT (such as the standalone version 1.7.9\n       or the CERN ROOT version, both available from\n       http://lcgapp.cern.ch/project/cls/work-packages/mathlibs/minuit/\n       (link last checked 2013-08-29)), then running the PyMinuit setup script\n       (giving the path where the C++ MINUIT code was _built_, *not* installed\n       - it needs the .o object files rather than the .a library file...). The\n       LD_LIBRARY_PATH and PYTHONPATH environment variables then need to be\n       set.\n    b) The instructions for IMinuit are available at\n       https://pypi.python.org/pypi/iminuit (link last checked 2015-11-30), and\n       is a much easier install than that for PyMinuit.\n 5) Download CosmoTransitions. The files are available at\n    http://chasm.uchicago.edu/cosmotransitions/\n    (link last checked 2013-08-29). The installation is as simple as unpacking\n    the zipped file.\n    (CosmoTransitions was previously at http://chasm.ucsc.edu/cosmotransitions/\n    but has since moved. Hosting on HepForge at some point in the future has\n    been suggested, but as of 2013-08-29, it is not there.)\n    Version 2 of CosmoTransitions is hosted on Github:\n    https://github.com/clwainwright/CosmoTransitions\n    (link last checked 2014-04-28) and should also work with Vevacious 1.1 or\n    later.\n 6) Download and compile the LesHouchesParserClasses (LHPC) C++ library. The\n    files are available at\n    http://www.hepforge.org/downloads/lhpc\n    (link last checked 2013-08-29) or\n    https://github.com/benoleary/LesHouchesParserClasses_CPP\n    (link last checked 2013-08-29). The installation should just be\n    downloading, unzipping, and then running make.\n 7) Compile Vevacious. The Makefile should be edited to have the correct paths\n    to the header files and library file of LHPC (these are\n    /path/to/unzipped/LHPC/include/ and /path/to/unzipped/LHPC/lib/ by\n    default). LHPC version 0.8.4 or higher is required.\n\n Once Vevacious is installed, it can be run as is, as long as the paths are set\n correctly. Various parameters for each execution can be specified: for the\n list, see the Vevacious/bin/VevaciousInitialization.xml file, where the\n various tags <XYZ> can be over-ridden by being given as arguments\n (e.g. --XYZ=ABC will over-ride whatever value is given between <XYZ> and\n </XYZ> in the .ini file). A different initialization file can be given with\n the option --input=other_filename as well (and direct arguments will over-ride\n any given in that file too). The XML file shows what paths must be specified.\n\n An executable to perform batch runs on a set of input SLHA files with the same\n model file is provided as VevaciousBatch.exe and takes the same initialization\n file, though it ignores any --slha_file/<slha_file> option, instead looking\n for <input_dir> and <output_dir> (as usual, they can be over-ridden by\n command-line arguments, such as --input_dir=/path/to/input/dir/ and so on).\n Each file in input_dir will be taken as an input SLHA file, and will be\n copied to output_dir with VEVACIOUSRESULTS appended to it once Vevacious has\n finished with that point. While Vevacious is working on the parameter point,\n a placeholder file with the extension \".placeholder\" is left in output_dir.\n This allows multiple cores (each with their OWN COPY of HOM4PS2 and its ENTIRE\n DIRECTORY - this is really important as HOM4PS2 uses temporary files for\n intermediate results, so 2 Vevacious processes running 2 HOM4PS2 processes is\n likely to cause problems as one HOM4PS2 process uses the temporary file\n generated by the other process) to work through input_dir, without\n over-writing the work of other cores. For example, core1 and core2 look at\n example/path/input/ and find example1.spc and example2.spc. If core1 gets\n there 1st, it makes example/path/output/example1.spc.placeholder, and when it\n is finished, it copies example1.spc to example/path/output/ and appends the\n VEVACIOUSRESULTS block, and deletes the placeholder. Meanwhile, core2 looks at\n example1, but finds that example/path/output/example1.spc.placeholder already\n exists, so it moves on to example2. Later, another core comes along, and for\n example finds that example/path/output/example1.spc already exists and\n example/path/output/example2.spc.placeholder also already exists, so it does\n not try to run example1.spc or example2.spc.\n \n The batch executable will probably crash if any other files or any\n subdirectories are in input_dir. Sorry.\n\n \nCHANGELOG:\n * 30th November 2015: version 1.2.00\n - Adapted to use IMinuit as an alternative to PyMinuit. Slight change then in\n   bounding hypersurface for MINUIT: it is now \"softly\" bounded into a\n   hypersphere (not be putting limits on MINUIT directly, but by changing the\n   potential outside the hypersurface to just roll directly back towards the\n   field origin until it hits the hypersurface again) rather than restricting\n   MINUIT to a hypercube of the same length in each field.\n\n * 21st June 2015: version 1.1.03\n - Fixed bug when PyMinuit throws an exception, that the starting point is\n   taken as a panic vacuum candidate without accounting for the shift by the\n   value of the loop corrections at the origin. It has a high chance of missing\n   a good panic vacuum candidate if PyMinuit had gone way outside the bounding\n   hypercube, but there does not seem to be an easy way around that. \n\n * 27th October 2014: version 1.1.02\n - Properly fixed case of DSB evaporation temperature being higher than panic\n   evaporation temperature, tested against \"CNMSSM_wrong_neutral.slha.out\"\n   using \"SARAH-SPhenoNMSSM_RealHiggsAndSingletAndStauAndStopVevs.vin\" from the\n   provided example files (the fix in 1.1.01 did not work).\n - Also decided to change default range of PyMinuit to 20 times the scale,\n   up from 5 times the scale.\n - Changed name of \"SARAH-SPhenoNMSSM_RealHiggsAndSingletStauVevs.vin\" to\n   \"SARAH-SPhenoNMSSM_RealHiggsAndSingletAndStauVevs.vin\" and of\n   \"SARAH-SPhenoNMSSM_RealHiggsAndSingletStauAndStopVevs.vin\" to\n   \"SARAH-SPhenoNMSSM_RealHiggsAndSingletAndStauAndStopVevs.vin\" for\n   consistency, likewise the \"pure_SLHA2_NMSSM...\" versions.\n\n * 25th October 2014: version 1.1.01\n - First fix of a critical bug: fixed silly use of old variable name in warning\n   statement causing Python to crash. The whole calculation had run as\n   intended, but the warning about an exponent for thermal tunneling being\n   capped to stop an overflow error itself caused an error by trying to use a\n   variable that didn't exist. It now correctly prints the warning without\n   crashing the programme.\n - Attempted fix of the second critical bug: The case of a DSB evaporation\n   temperature *higher* than the temperature at which the panic vacuum is\n   higher than the field origin was not correctly handled in 1.1.00 and the\n   lazy dimissal as low_survival_probability was both wrong in general and also\n   incorrectly handled (the optimal tunneling temperature was left at 0.0 and\n   the path deformation crashed because of a division by zero). This should now\n   be fixed, but I don't actually have a concrete example case to test it on.\n   Thus the bug is not yet confirmed to be fixed by this release.\n\n * 21st May 2014: version 1.1.00\n - Put up on HepForge as official release: now awaiting the inevitable\n   appearance of critical bugs...\n - Rearranged example model and SLHA files into what I hope is a better folder\n   structure that will be misunderstood less.\n\n * 6th May 2014: version 1.1.00beta16\n - Changed lnOfThermalIntegrationFactor in default Python to account for\n   incorrectly having used the full Planck mass instead of the reduced Planck\n   mass which was correct in 1.1.00beta14, but the other, more important\n   factor from the co-moving cosmic event horizon volume was correct in\n   1.1.00beta15 and the actual difference is lnOfThermalIntegrationFactor\n   went from 238.553 (1.1.00beta14) to 244.5525 (1.1.00beta15) to\n   244.53 (1.1.00beta15).\n\n * 5th May 2014: version 1.1.00beta15\n - Changed lnOfThermalIntegrationFactor in default Python to account for\n   incorrectly having used the reduced Planck mass instead of the full Planck\n   mass in some factors and to use the co-moving cosmic event horizon volume\n   instead of just the cube of the Hubble length.\n\n * 28th April 2014: version 1.1.00beta14\n - Added code to default Python to correctly identify if CosmoTransitions2 is\n   being used instead of version 1, and to write the code to calculate the\n   action in the correct form for version 2.\n\n * 25th April 2014: version 1.1.00beta13\n - Fixed rather significant bug in the conversion from seconds to 1/GeV which\n   was used for calculating the lifetime of metastable points in the default\n   Python code: it was converting seconds to 1/eV, so was 9 orders of magnitude\n   out. Fortunately this is only a difference of about 20 out of the 400 or so\n   that is the threshold for acceptably long-lived...\n\n * 15th April 2014: version 1.1.00beta12\n - Fixed very minor bug in default Python code that was incorrectly comparing\n   massSquaredMagnitude to ( 1.0E-6 * inverseScaleSquared ) instead of\n   ( 1.0E-6 / inverseScaleSquared ). It was not a problem in the sense that it\n   was a check to avoid division by zero and worked even though it was wrong.\n   It was however possibly calculating m^4 ln( m^2 / Q^2 ) for very small m\n   which would have been a negligible contribution to the corrections. Fixed\n   the comparison to just whether massSquaredMagnitude > 1.0 or not.\n\n * 3rd April 2014: version 1.1.00beta11\n - Fixed bug in default Python code that was incorrectly exluding points based\n   on thermal fluctuations based on the dividing an action by the last\n   temperature in a list rather than on the temperature at which the action was\n   calculated.\n - Fit of direct-path 3-dimensional action in default Python code improved:\n   the fit is only made to the action at temperatures above the evaporation\n   temperature of the DSB minimum.\n\n * 25th March 2014: version 1.1.00beta10\n - Added setThermalSurvivalThreshold functions to VevaciousRunner class.\n - Shifted a lot of code from default Vevacious.py to\n   VevaciousParameterDependent.py, mainly to do with finding the optimal\n   tunneling temperature.\n - Python code to calculate the survival probability against thermal tunneling\n   has been improved: some silly bugs leading to misreporting of the result\n   have been fixed, and now the result \"long-lived_but_thermally_excluded\" is\n   reserved for exclusion by a cautious lower bound on the integrated decay\n   width, while failing to be excluded by this but still being excluded by the\n   old, aggressive algorithm is now \"long-lived_but_maybe_thermally_excluded\".\n   The number code reported in the SLHA block VEVACIOUSRESULTS is -2 for\n   excluded by the cautious calculation, and -3 for exclusion only by the\n   aggressive calculation while not being excluded by the cautious calculation.\n - Default Vevacious.py now also decides the number code for the (0, 0) entry\n   of the SLHA block VEVACIOUSRESULTS, which is communicated back to\n   Vevacious.exe by an XML attribute.\n\n * 14th March 2014: version 1.1.00beta9\n - Added flags to turn off thermal calculations and path deformation more\n   easily:\n   --should_tunnel=True\n   --tunnel_thermally=True\n   --deform_tunnel_paths=True\n   or with \"True\" replaced by \"False\" - note that the case is important! It\n   must be valid Python, so with uppercase initial letters, and the rest\n   lowercase! All values are assumed to be True by default.\n - Included VevaciousBatchRunner.cpp which the Makefile compiles to\n   VevaciousBatch.exe as an executable to run Vevacious on all files in a\n   directory.\n - Removed erroneous whitespace character appearing in <reference> element\n   attribute \"version\" of output XML produced by default Python.\n - Changed default main program to use the VevaciousRunner constructor which\n   takes just a reference to a BOL::ArgumentParser instance.\n\n * 11th March 2014: version 1.1.00beta8\n - Default Python now generates AbsLoopAndThermalCorrectedPotential and\n   FloorLoopAndThermalCorrectedPotential which use the absolute value or 0.0\n   for negative masses-squared respectively in the thermal corrections.\n\n * 4th March 2014: version 1.1.00beta7\n - Default Python now correctly stops if it finds that the point is thermally\n   excluded by a direct path when exploring the temperature dependence of the\n   direct-path thermal action.\n - Default Python now also considers tunneling from the false vacuum to the\n   true vacuum at a given temperature impossible if the true vacuum is now less\n   than 0.1 times its length at zero temperature, as a workaround for PyMinuit\n   sometimes not rolling the DSB minimum close enough to the field origin when\n   it should, breaking the unpatched algorithm for deciding if tunneling is\n   still possible.\n\n * 28th February 2014: version 1.1.00beta6\n - Default parameter-dependent Python now correctly does not deform the path if\n   not necessary.\n\n * 28th February 2014: version 1.1.00beta5\n - Default parameter-dependent Python now correctly reports exclusions in\n   output file (was correctly reporting to terminal, but results file was\n   wrong for some cases).\n\n * 17th February 2014: version 1.1.00beta4\n - Default parameter-dependent Python now loads warning message list in\n   Vevacious object before trying to minimize the DSB minimum, to stop crashes\n   caused by trying to log errors from the minimization of the DSB minimum.\n\n * 14th February 2014: version 1.1.00beta3\n - Fixed default Vevacious.py to properly exclude field configurations\n   that would be the DSB minimum but for numerical effects from the list of\n   possible panic vacua.\n - Put function back in to limit MINUIT to a hypercube in field space in\n   default Vevacious.py code.\n - Improved fit function for guess at temperature dependence of thermal action\n   by direct path in default Python code (now a quadratic divided by the square\n   of the difference from the best guess at the critical temperature).\n\n * 13th February 2014: version 1.1.00beta2\n - Fixed default Vevacious.py to properly report thermal exclusion if found\n   during direct path thermal action calculation.\n - Updated bin/Vevacious.py example to the default created by 1.1.00beta2.\n\n * 11th February 2014: version 1.1.00beta1\n ~ Major update!\n - Added functionality to calculate survival probability against tunneling to\n   panic vacua at non-zero temperatures.\n   -- Default Python program now\n      >> takes tree-level extrema from parsed results of HOM4PS2 as starting\n         points for PyMinuit using the zero-temperature loop-corrected\n         potential\n      >> sorts minima and from those minima deeper than the DSB minimum it\n         chooses the nearest as the panic vacuum\n      >> checks for exclusion based on tunneling time at zero temperature with\n         a direct path between the minima\n      >> finds a temperature between 2^-1/2 & 1 times the critical temperature\n         at which the panic vacuum becomes less deep than the DSB vacuum (or\n         where the DSB vacuum rolls to at the temperature)\n      >> checks for exclusion based on the survival probability against thermal\n         tunneling along a direct path between the minima at this temperature\n         and at half this temperature\n      >> fits a guess at the temperature dependence of the direct-path thermal\n         action based on the actions at the above temperatures and finds the\n         optimal tunneling temperature according to the fitted function\n      >> checks for exclusion based on the survival probability against thermal\n         tunneling along a direct path between the minima at the estimated\n         optimal temperature\n      >> checks for exclusion based on tunneling time at zero temperature with\n         an optimal deformed path between the minima\n      >> checks for exclusion based on the survival probability against thermal\n         tunneling along an optimal deformed path between the minima at the\n         estimated optimal temperature\n      >> stops the above calculation if at any stage the parameter point is\n         excluded\n - Most boilerplate Python code is now in VevaciousParameterDependent.py so\n   that the main Python program (defaulting to Vevacious.py) can be neater.\n - Model files now need that the mass-squared matrices for vectors have the XML\n   element spin=\"vector\" so that thermal corrections can be calculated\n   correctly. All bundled example .vin files have this included, and Florian\n   will incorporate this into the next update of SARAH.\n - The functions VevaciousRunner::setLifetimeForDirectPath and\n   VevaciousRunner::setLifetimeForDeformedPath (both variants of each) have\n   been removed in favor of a single function\n   VevaciousRunner::setLifetimeThreshold which sets a single threshold (because\n   I cannot remember what I was thinking when I set it up so that direct and\n   deformed paths would have separate thresholds).\n - Many static strings in VevaciousRunner and PotentialMinimizer have been\n   removed in favor of just having their values written into the function that\n   writes the Python code.\n - VevaciousRunner::prepareParameterDependentPython and\n   VevaciousRunner::writeDefaultPythonProgram have had bits of the boilerplate\n   Python code swapped around between them, along with\n   PotentialMinimizer::prepareLoopCorrections.\n - Fields are no longer scaled to the energy scale except within the Python, so\n   VevRenamer and SarahInterpreter were changed to reflect that.\n ~ Not ready to be 1.1.00 yet, as VevaciousRunner::appendResultsToSlha needs to\n   be updated to account for thermal results.\n\n * 9th October 2013: version 1.0.11\n - Fixed that default Vevacious.py was using the number of spatial dimensions\n   for a finite-temperature tunneling time calculation rather than the correct\n   zero-temperature calculation number of dimensions.\n - Fixed bug that max_saddle_nudges was being set to 2 if not explicitly given,\n   when it should be however not be used to resize saddle_nudges unless\n   explicitly given.\n - Changed default homotopy_type from 1 (polyhedral) to 2 (linear) as it seems\n   to be faster for SUSY potentials, and thus I reckon that it's better for\n   generic QFT potentials.\n - Removed taken_positive from provided model files, as occasionally it leads\n   to global minima being missed because HOM4PS2 did not find all the sign\n   combinations.\n\n * 13th September 2013: version 1.0.10\n - Fixed bug when trying to use a relative path for the hom4ps2_dir input.\n - Fixed bug that sometimes a point that has a negative value for a VEV that\n   should be positive (as declared by the <taken_positive> element of the\n   <input_vevs> element of the model file) was taken as the global minimum at\n   tree level, leading to misleading warnings about apparent change from\n   metastable to stable going from tree to one loop.\n\n * 11th September 2013: version 1.0.9\n - Default Python program fixed to correctly find the tree-level global minimum\n   for the purposes of checking to see if the basin of attraction of the\n   one-loop minima has moved significantly. (The code was not correctly\n   indented, leading to stuff being evaluated after a loop rather than during\n   the loop.)\n - Added example model file for just Higgs VEVs and stop VEVs (without allowing\n   stau VEVs), though just the SARAH-SPhenoMSSM style of SLHA is expected.\n\n * 9th September 2013: version 1.0.8\n - Example model files where the stop VEVs are allowed to be non-zero have been\n   corrected (unfortunately the D-term from SU(3)_c had been generated wrongly\n   and this carried through into the mass matrices).\n\n * 29th August 2013: version 1.0.7\n - The A factor for calculating the tunneling time has changed to be the fourth\n   power of renormalization scale as given by the SLHA file rather than the old\n   hard-coded (100 GeV)^4 by default, and the default Vevacious.py now\n   explicitly calculates the actions from the tunneling time thresholds. This\n   now allows the user to edit Vevacious.py to change the calculation of the\n   A factor if so desired.\n - CosmoTransitions is now at http://chasm.uchicago.edu/cosmotransitions/ as\n   Dr Wainwright has kindly let me know.\n\n * 21st August 2013: version 1.0.6\n - Makefile fixed so that it works properly (the libraries were in the wrong\n   official order, but some compilers don't mind, such as that which was used\n   to test 1.0.5).\n - Example model files renamed to clarify (a bit) which require non-standard\n   SLHA blocks (by the prefix \"SARAH-SPheno\"), and which can be used with\n   standard flavor-violation-accommodating SLHA2 blocks alone.\n - Example model files that should work with SLHA files adhering just to the\n   SLHA1 conventions have been added.\n - Warning! The website at chasm.uscs.edu does not seem to exist any longer, so \n   it appears to be impossible to get CosmoTransitions officially! Please email\n   Ben O'Leary if Dr C. Wainwright (the author of CosmoTransitions) cannot help\n   you.\n\n * 1st August 2013: version 1.0.5\n - Makefile now makes ./lib/libVevacious.a as a static library as well, which\n   should make it easier to make custom C++ programs that use the Vevacious\n   classes.\n - Default Python now also checks to see if a tree-level analysis of metastable\n   turned into a 1-loop stable result, & if so, doubles the VEVs of the\n   tree-level minimum as a new starting point for PyMinuit, & then compares the\n   point to which PyMinuit rolled from this new starting point to the input\n   minimum (as basins of attraction can sometimes move so far with loop\n   corrections that a tree-level CCB minimum can get caught in the input\n   minimum's basin of attraction).\n - Default Python now also now restricts PyMinuit to a hypercube of each field\n   being within a hundred times the scale of the SLHAfile in magnitude (rather\n   than a thousand).\n\n * 8th July 2013: version 1.0.4\n - Updated citation text, as Vevacious has now got a manual on the arXiv!\n   [arXiv:1307.1477 (hep-ph)]\n - Updated README\n\n * 28th June 2013: version 1.0.3\n - Fixed default Vevacious.py to correctly handle PyMinuit exceptions, and to\n   correctly warn when the input VEVs seem to be giving a saddle point.\n\n * 26th June 2013: version 1.0.2\n - Fixed SARAH-generated example model files to no longer have flavor issue, so\n   now they are as they would be if generated by the current version of SARAH4.\n\n * 26th June 2013: version 1.0.1\n - Fixed \"pure SLHA\" example model files.\n - Updated NMSSM_wrong_neutral example point.\n \n * 17th June 2013: version 1.0.0\n - Release version!\n - Added consistency check that all used SLHA BLOCK scales must be the same,\n   otherwise the program prints an error message and returns EXIT_FAILURE.\n - Updated examples.\n   \n * 5th June 2013: version 0.3.1\n - Added VevaciousRunner::findTreeLevelExtrema(...) as a synonym for\n   VevaciousRunner::overwriteTreeLevelExtrema(...).\n - Changed verdict of results from \"unstable\" for tunneling times below the\n   threshold to \"short-lived\" and from \"metastable\" to \"long-lived\" for those\n   over the threshold.\n - Added example model files in Vevacious/MSSM/ that use purely the SLHA1\n   conventions without requiring the extra HMIX data lines that are assumed by\n   SARAH.\n\n * 17th May 2013: version 0.3.0\n - Vevacious now prints its version and the documentation citation in the\n   results file and also SLHA block.\n - Added NMSSM example model files and a single, metastable example spectrum.\n\n * 14th May 2013: version 0.2.9\n - First version publicly available, but not officially released yet.\n - Slight changes to code calling CosmoTransitions to no longer use\n   quickTunneling = True, on advice from the author of CosmoTransitions, Max\n   Wainwright.\n - saddle_nudges input argument added, to give a list of floating point numbers\n   to be used as the set of nudge sizes for the displacement of MINUIT off\n   saddle points.\n - Default Vevacious.py cleaned up a bit to make it easier to substitute in the\n   tree-level potential as the function to be used for the analysis. PyMinuit\n   also has limits of a thousand times the energy scale for the VEVs now, to\n   avoid it rolling off to infinity.\n   \n * 26th April 2013: version 0.2.8\n - Publicly available on GitHub, but still not officially released!\n - added optional bool argument to VevaciousRunner::appendResultsToSlha\n   which inserts '#' after the doubles of the VEVACIOUSRESULTS block so that\n   SSP can read it without problems, & added argument option to Vevacious.exe\n   so that this can be used by default.\n   \n * 17th April 2013: version 0.2.7\n - Still not even released!\n - Oops, fixed a bug from an undocumented change which was designed to prevent\n   CosmoTransitions from trying to tunnel through an energy barrier that is\n   smaller than its resolution, which was incorrectly deciding based on whether\n   or not the 1st step was absolutely positive, rather than relative to the\n   input VEVs.\n - Tried to add use of BOL::WaitingOnSubprocessExecutor to run Python with\n   intervention to kill the process if it took too long, so that it could be\n   run again without allowing path deformation, but it doesn't work for arcane\n   path-inheritance-for-subprocess issues.\n   \n * 17th April 2013: version 0.2.6\n - Still not even released!\n - Moved appending SLHA blocks to\n   VevaciousRunner::appendResultsToSlha( std::string const& ) const function\n   out of Vevacious.cpp, which now calls this function.\n   \n * 16th April 2013: version 0.2.5\n - Still not even released!\n - Will now format Mathematica-style 123.4e5 into 123.4E+5 so that HOM4PS2 is\n   happy, & other such numbers where 'e' or 'E' is not followed by '+' or '-'.\n   \n * 2nd April 2013: version 0.2.4\n - Still not even released!\n - Fixed bug where exceptions from PyMinuit were not being caught correctly,\n   leading to no results being printed from a parameter point that has a\n   PyMinuit starting point that causes an exception.\n - Changed behavior such that result file is removed before doing any\n   calculation, so that an error does not leave an old result file.\n\n * 29th March 2013: version 0.2.3\n - Still not even released!\n - Fixed bug where PotentialMinimizer::prepareLoopCorrections (and thus\n   VevaciousRunner::prepareLoopCorrections) would only work for the 1st SLHA\n   file given, since I had forgotten to clear the list of mass correction\n   function names.\n - Tidied up by renaming remaining references to tree-level potentials into\n   references to polynomial parts of the potential.\n\n * 27th March 2013: version 0.2.2\n - Still not even released!\n - Updated READMEs & example files.\n \n * 25th March 2013: version 0.2.1\n - Still not even released!\n - Before any .py file is written, Vevacious deletes any pre-existing .pyc\n   version of the file, allowing multiple parameter points to be run per\n   second.\n - In the default Vevacious.py, the minimum found by MINUIT after being rolled\n   from the input VEVs, which is used as the actual input minimum, is made\n   deeper by twice the MINUIT error, so that numerically degenerate minima are\n   not considered as global minimum candidates.\n\n * 22nd March 2013: version 0.2.0\n - Still not even released!\n - Now tries to find blocks with prefixes for \"tree-level\" and \"1-loop-level\"\n   for corresponding parts to be consistent with the renormalization scheme\n   used by SPheno. By default the \"tree-level\" prefix is \"TREE\" and the\n   \"1-loop-level\" prefix is \"LOOP\", but these can be changed in the model file\n   by using the block_prefixes XML element to set the 'tree' and 'loop'\n   attributes (if the element is included in the file, attributes not\n   explicitly written are assumed to be empty strings). The tadpole equations\n   & the mass-squared matrices use \"tree-level values\" if available, and the\n   polynomial part of the potential uses \"1-loop-level\" values if available.\n   E.g. for the mu parameter, given in HMIX[1]: in the tadpole equations,\n   TREEHMIX[1] is used if written in the SLHA file, & if it is not found,\n   HMIX[1] is used; in the polynomial part of the potential, LOOPHMIX[1] is\n   used if found in the SLHA file, HMIX[1] otherwise.\n\n * 15th March 2013: version 0.1.5\n - Still not even released!\n - Now the parameter-dependent Python will be properly written even if HOM4PS2\n   has not been run (was not correctly writing FunctionFromDictionary and other\n   functions that require knowledge of the internal VEV names).\n   \n * 14th March 2013: version 0.1.4\n - Still not even released!\n - Fixed bug where ./Vevacious.py wasn't being written, instead\n   Vevacious.py.stau_VEVs_MSSM was always being written (but that was just a\n   name, its content was completely independent of the model).\n - Now the name of the Python main program to run (by default, ./Vevacious.py)\n   is given by the python_main element of the initialization XML file. If there\n   is no file with that name in existence, the default ./Vevacious.py will be\n   written and run.\n\n * 12th March 2013: version 0.1.3\n - Still not even released!\n - Now allows for a tolerance on the imaginary parts of the HOM4PS2 solutions\n   to be considered valid real solutions.\n - Now appends the warnings to the SLHA file as the VEVACIOUSWARNINGS block.\n\n * 11th March 2013: version 0.1.2\n - Still not even released!\n - Default Vevacious.py no longer tries extrema that are not as deep as the\n   input but happen to have a depth difference within the MINUIT error.\n - Default Vevacious.py now records warnings in the result file.\n - Default Vevacious.py now copes with PyMinuit failing to find a minimum with\n   sufficiently positive Hessian eigenvalues.\n\n * 10th March 2013: version 0.1.1\n - Still not even released! Credits updated.\n - Rewritten such that the tree-level extrema are written to a Python file,\n   and the parameter-point dependent stuff (functions, VEV name maps) are\n   written to another file, and the minimization is performed by running a\n   parameter-point-independent Python program, either supplied by the user or\n   a default program is written. (The intent is that the user can modify the\n   main Python code without having to recompile any C++.)\n\n * 2nd January 2013: version 0.0.1\n - Not even released! Credits updated.\n - Fixed missing factor of (1/(16 pi^2)) from loop corrections.\n\n\nThe C++ files of Vevacious are:\n\n <> headers in Vevacious/include/:\n PotentialMinimizer.hpp\n SarahInterpreter.hpp\n SarahSlhaConverter.hpp\n TadpoleSolver.hpp\n VevaciousRunner.hpp\n VevRenamer.hpp\n\n <> source files in Vevacious/source/:\n PotentialMinimizer.cpp\n SarahInterpreter.cpp\n SarahSlhaConverter.cpp\n TadpoleSolver.cpp\n Vevacious.cpp\n VevaciousRunner.cpp\n VevRenamer.cpp\n\n <> and also:\n Vevacious/Makefile\n and README.Vevacious.txt which describes the package (copied as README.txt).\n The makefile creates a single executable in Vevacious/bin/:\n Vevacious.exe, the executable which performs the full set of steps to try to\n find the global minimum of the loop-corrected potential.\n \n <> Some example files are also given:\n * Vevacious/bin/VevaciousInitialization.xml which is a default initialization\n file, which uses paths that need to be changed.\n * Various files in Vevacious/MSSM/:\n ** MSSM_XYZ.vin is a model file for the MSSM using the VEVs specified by XYZ.\n For example, MSSM_RealHiggsAndStauVevs.vin is a model file for the MSSM\n allowing VEVs for the staus as well as the Higgs, with the assumption that\n they are all real.\n *** MSSM_JustNormalHiggsVevs.vin: just the normal vd and vu are allowed to be\n non-zero.\n *** MSSM_RealHiggsAndStauVevs.vin: in addition to the normal vd and vu, stau_L\n and stau_R are allowed to have non-zero VEVs.\n *** MSSM_RealHiggsAndStauAndStopVevs.vin: as MSSM_RealHiggsAndStauVevs.vin,\n but one color of stop_L and the same color of stop_R are allowed non-zero\n VEVs.\n ** pure_SLHA_XYZ.vin: versions of the above, but allowing pure SLHA2 input\n without requiring the additional information given by SPhenoMSSM.\n ** XYZ.slha.in is an input file for SPhenoMSSM (the SPheno made by SARAH for\n the model MSSM), XYZ.slha.out is an output spectrum from that input.\n *** XYZ = SPS1ap: the CMSSM parameter point SPS1a'\n *** XYZ = CMSSM_CCB: an example charge- and color-breaking global minimum\n CMSSM parameter point (corresponding to the best-fit point of arXiv:1204.4199)\n *** XYZ = NUHM1_CCB: an example charge- and color-breaking global minimum\n NUHM1 (Non-Universal Higgs Mass CMSSM with 1 additional mass for the Higgses,\n rather than 2) parameter point (corresponding to the \"low\" best-fit point of\n arXiv:1207.7315)\n * Various files in Vevacious/NMSSM/:\n As above, but for the NMSSM, though with only one example CNMSSM parameter\n point, corresponding to P1 of arXiv:0801.4321, which has a global minimum with\n the wrong Z mass, but still zero stau and stop VEVs.\n \n", 
  "id": 9619163
}
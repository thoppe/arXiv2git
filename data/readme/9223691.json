{
  "read_at": 1462543090, 
  "description": "Evolutionary optimization of extant software", 
  "README.md": "Genetic Optimization Algorithm (GOA)\n====================================\n\nA post-compilation optimization tool capable of optimizing myriad\naspects of program runtime behavior.  The three required inputs are\n(1) compiled program assembly code, (2) a test workload used to\nexercise candidate optimizations, and (3) a fitness function used to\nscore runtime behavior.  As opposed to compiler optimizations which\nmaintain program semantics and typically target only executable speed\nand size, this technique is capable of addressing any measurable\naspect of runtime behavior and may change program semantics.\n\nAssembler code is modified using generic program transformations,\ntaken from Genetic Programming, yielding candidate optimizations.  The\nfitness of candidates are determined using by running on the workload\nand combining performance metrics with the fitness function.  Due to\nthe inherent mutational robustness of software [1], many of these\nmutations will change the runtime behavior of software without\nchanging the specification to which the software conforms.  Some\ncandidates will have desirable non-functional properties such as\nfaster running times, reduced energy consumption or a smaller\nexecutable size.\n\nModern system emulators and profilers (e.g., Linux perf [2]) allow\nfine-grained monitoring of aspects of program execution.  Fitness\nfunctions combine these measurements to model aspects of program\nexecution such as energy consumption and communication overhead, which\nmay be difficult to predict a-priori.\n\nThis repository supports multiple benchmark suites.  The PARSEC\nbenchmark suite [3] focuses on emerging workloads.  The \"Computer\nLanguage Benchmarks Game\" [4] holds a number of simpler more\ntraditional benchmark programs implemented in multiple languages.\nPartial support is provided for working with the SPEC benchmark suite\n[5] which stresses a system's \"processor, memory subsystem and\ncompiler\".  Currently PARSEC has the most complete support.\n\nRepository Layout\n=================\n\n        README | this file\n         NOTES | working notes and reproduction instructions\n       COPYING | standard GPLV3 License\n    benchmarks | holds benchmark programs, input and output\n           bin | shell scripts to run experiments and collect results\n           etc | miscellaneous support files\n       results | experimental results\n           src | lisp source for main optimization programs\n\nInstallation and Usage\n======================\n\nClone this repository.  To avoid a downloading a large amount of\nhistorical data, use the `--single-branch` option to `git clone` as\nfollows.\n\n    git clone --single-branch git://github.com/eschulte/goa.git\n\nThe evolution toolkit which we'll use to evolve programs is written in\nCommon Lisp.  Each optimized program also requires a shell script test\ndriver, and a test harness (used to limit resources consumed by\nevolved variants) is written in C.  Assuming you already have both\nbash and a C compiler on your system, the following additional tools\nwill need to be installed.\n\n1. Steel Bank Common Lisp (SBCL) [6] or Clozure Common Lisp (CCL) [7].\n\n2. The Quicklisp [8] Common Lisp package manager which will be used to\n   install all of the required lisp packages.  Follow the instructions\n   on the Quicklisp site to install it.\n\n3. Under the directory to which quicklisp has been installed (by\n   default `~/quicklisp`), there will be a `local-projects` directory.\n   Clone the following git repositories into this directory.\n\n        git clone git://github.com/eschulte/software-evolution.git\n        git clone git://github.com/eschulte/delta-debug.git\n\n   You will also need to symlink this repository into your\n   `local-projects` directory.\n\n        ln -s $(pwd) ~/quicklisp/local-projects/\n\n   Finally, ensure Quicklisp has been added to your init file, and\n   then use Quicklisp to register these newly cloned local projects.\n\n        (ql:add-to-init-file)\n        (ql:register-local-projects)\n\n4. Once Quicklisp and these dependencies have all been installed, run\n   the following to install the GOA package and all of its\n   dependencies.\n\n        (ql:quickload :goa)\n\n   It may also be necessary to explicitly load some additional\n   dependencies with the following.\n\n        (ql:quickload :trivial-gray-streams)\n        (ql:quickload :lhstats)\n\n5. Checkout the following tool for the protected execution of shell\n   commands through the file system.  This serves to isolate the\n   evolutionary process from the many errors thrown during extremely\n   long-running optimization runs, the accumulation of which can\n   occasionally stall the lisp process.  From the base of this\n   directory run the following to clone sh-runner.\n\n        git clone git://github.com/eschulte/sh-runner.git\n\n6. At this point it is possible to run program optimization from the\n   lisp REPL as described below.  To build a command line program\n   optimization executable, install buildapp [9] and then run make.\n\n### Make Variables\n\nThe following variables may be used to control the behavior of make.\n\n- The `QUICK_LISP` variable may be set to point to a custom quicklisp\n  installation directory.  The default value is `$HOME/quicklisp/`.\n\n- The `LISP_STACK` variable may be used to set the maximum amount of\n  memory available to the `goa` executable when compiled with SBCL.\n  Large programs, especially when annotated (e.g., with\n  `src/configs/use-annotation.lisp`) may require large amounts of\n  memory.  For example run the following to build the `goa` executable\n  with 30G of memory.\n\n         make bin/goa LISP_STACK=$((30 * 1024))\n\n- The `LISP_LIBS` variable may be used to include additional packages\n  into compiled executables.  For example to compile the `iolib`\n  package into the `goa` executable for socket communication (e.g.,\n  with `src/configs/by-flag.lisp`), run the following.\n\n         make bin/goa LISP_LIBS=iolib\n\nOptimization at the Command Line\n--------------------------------\n\nAt this point everything needed has been installed.  The following\nsteps walk through optimizing `swaptions` from the command line to\nreduce runtime.  To run this example either a `time` executable which\nsupports the `-p` and `-o` options (*not* the shell built in), or\n`perf` is required.\n\n1. Run the `goa` executable once to view all of the optional\n   arguments.  All scripts and executables in the `./bin/` directory\n   print help information in response to the `-h` flag.\n\n        ./bin/goa -h\n\n2. Compile `swaptions` to assembly and generate the test input and\n   oracle output files.  Note, the first time this is run it will\n   download and unpack the PARSEC benchmarks which may take some time.\n\n        ./bin/mgmt output swaptions\n\n3. Run a test of the `swaptions` executable to ensure everything is\n   working and to see the output available to our fitness function.\n   If using `time` run the following,\n\n        ./bin/run swaptions ./benchmarks/swaptions/swaptions -t\n\n   If using `perf` run the following.\n\n        ./bin/run swaptions ./benchmarks/swaptions/swaptions -p\n\n4. Optimize `swaptions` to reduce runtime.  If using `time` run the\n   following.\n\n        ./bin/goa \"./bin/run swaptions ~a -t\" \\\n          benchmarks/swaptions/swaptions.s \\\n          -l g++ -L \"-lm -pthread -DENABLE_THREADS\" \\\n          -F real -f 256 -p 128 -P 64 -t 2 -r swap\n\n    If using `perf` run the following.\n\n        ./bin/goa \"./bin/run swaptions ~a -p\" \\\n          benchmarks/swaptions/swaptions.s \\\n          -l g++ -L \"-lm -pthread -DENABLE_THREADS\" \\\n          -F seconds -f 256 -p 128 -P 64 -t 2 -r swap\n\n   The `-l` option specifies that `g++` should be used as the linker\n   (`gcc` is the default linker), and that the flags `\"-lm -pthread\n   -DENABLE_THREADS\"` should be passed to `g++` during linking.  By\n   passing `real` (or `seconds`) to `-F` we specify that we want our\n   fitness function to minimize the time taken to run this program.\n   The remaining flags specify 256 total fitness evaluations should be\n   run (`-f`), a population of size 128 should be used (`-p`),\n   periodic checkpoints should be written every 64 fitness evaluations\n   (`-P`), optimization should be distributed across 2 threads (`-t`),\n   and results should be saved in a directory named `swap` (`-r`).\n\n5. When repair complete the name of the results directory will be\n   printed.  In this directory the `final-best.store` file holds the\n   optimized program.  This may be compiled to an optimized executable\n   with the following (see the `-h` output of `objread` for more ways\n   to use `.store` files).\n\n        ./bin/objread swap/final-best.store\n\nInteractive Optimization at the REPL\n------------------------------------\n\nSee `src/repl/example.lisp`, which demonstrates how these tools may be\nrun interactively from the common lisp REPL.  The evolving population,\nand many important evolutionary parameters are exposed as global\nvariables for live analysis and modification during interactive runs.\n\nFootnotes\n=========\n\n[1] http://arxiv.org/abs/1204.4224\n\n[2] https://perf.wiki.kernel.org/index.php/Main_Page\n\n[3] http://parsec.cs.princeton.edu/\n\n[4] http://benchmarksgame.alioth.debian.org/\n\n[5] http://www.spec.org/cpu2006/\n\n[6] http://www.sbcl.org/\n\n[7] http://ccl.clozure.com/\n\n[8] http://www.quicklisp.org/beta/\n\n[9] http://www.xach.com/lisp/buildapp/\n", 
  "id": 9223691
}
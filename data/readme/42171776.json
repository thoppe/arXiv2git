{
  "read_at": 1462549063, 
  "description": "Discrete Truncated Wigner Approximation for any spin system", 
  "README.md": "dtwa_quantum_spins\n=============\n\nDynamics of quantum spins with homogeneous fields using the Discrete Truncated Wigner Approximation with Born-Bogoliubov-Green-Kirkwood-Yvon corrections (dTWA-BBGKY) in the dicrete Wigner phase space. There are three (3) sampling schemes used for the Monte Carlo estimate of observables, depending on the choice of phase point operators in the Wigner representation. \n\nIntroduction\n-----\nThe Hamiltonian that has been coded is the general Curie-Weiss - type hamiltonian\n\n![equation](./hamilt.png)\n\nHere, the Pauli SU(2) representation is used, the Roman indices run through the lattice sites, and Greek indices run through the three spatial directions. A lattice in any dimensions and with any layout can be used, as long as the site index counting is flattened to 1d. Note that the initial condition is hard-coded to a fully x-polarized state.\n\nThe relevant terms (from left to right) are:\n\n1. A norm that can be used to control energy divergences in the hopping terms\n\n2. The lattice size (say, L)\n\n3. The hopping amplitudes (3 hoppings for 3 directions embedded in the J - vector)\n\n4. The hopping matrix (the J - matrix. Can be long range)\n\n5. The field vector (3 components for 3 directions embedded in the h - vector)\n\n6. The number of samples to use for the Monte Carlo averaging over the Wigner phase space (say, n_iter)\n\nThe module outputs as a python object the sampled coefficients at different times, as well as arrays containing the following observables (for all times):\n\n![equation](./obs.png)\n\n\nThe code can be used in a single processor environment, or a multiprocessor grid using [mpi4py](http://mpi4py.scipy.org/),  the Python bindings of the MPI standard.\n\nInstallation\n-----\nInstallation involves three steps. Install git, clone this code repository, install python and all dependencies and build/install the python module(s).\n\n1. Installing git: If git is not already installed in your system, [follow the instructions here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git). \n\n2. Cloning this repository: If you are on any unix-like shell environment, whether an actual unix shell (like [bash](https://www.gnu.org/software/bash/) ), a graphical terminal emulator (like [xterm](http://invisible-island.net/xterm/xterm.html), [gnome-terminal](https://help.gnome.org/users/gnome-terminal/stable/), [yakuake](https://yakuake.kde.org/) etc.) on Linux with X-Windows ([Ubuntu](http://www.ubuntu.com/), [Debian](https://www.debian.org/), [OpenSuse](https://www.opensuse.org/en/) etc.) or an environment like [Cygwin](https://www.cygwin.com/) or [MinGW](http://mingw.org/) on Microsoft Windows, just install git if necessary and run\n     ```\n     $ git clone https://github.com/hariseldon99/dtwa-quantum_spins\n     $ echo $PWD\n     ```\nThis causes git clone the repository to the path $PWD/dtwa_quantum_systems.     \nIn other cases, refer to [git setup guide](https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup) and \n[git basics](https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository).\n\n3. Install python and dependencies: If python is not already installed in your system, then refer to [these general instructions](https://wiki.python.org/moin/BeginnersGuide/Download) to download and install python and the dependencies given in the 'External dependencies' section below. Alternatively, install a python distribution like [anaconda](https://store.continuum.io/cshop/anaconda/) and use it's internal package management to install the required dependencies.\n\n4. Build and install the python module(s)\n    ```\n    $ python setup.py build\n    $ python setup.py install\n    ```\n  The first command builds the python module \"dtwa_quantum_spins\", as well as the optimized bbgky. The latter requires a \n  [BLAS](http://www.netlib.org/blas/) library to be installed as a [shared library](http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html). If that has been done already, and is in default paths given by [ldconfig](http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html) or [LD_LIBRARY_PATH](http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html), the build should run correctly. Otherwise, edit the file setup.py and change the variables \"blas_path\" \"blas_headers\" to point to the path where the library and headers are installed.\n\n  \n  If you do not wish to install in root space, run the install with the --user option. Alternatively, don't run the install (just the build), start a python shell (or write a python script) and run\n\n  ```python\n  >>> import sys\n  >>> sys.path.append(\"/path/to/build/directory/\")\n  >>> import dtwa_quantum_spins as dtwa\n  ```\n\nUsage\n-----\nUsage examples in python are shown below.\n\nExample 1: Obtaining Documentation\n```python\n>>> import dtwa_quantum_spins as dtwa\n>>> help(dtwa)\n```\n\nExample 2:\n```python\nimport numpy as np\nfrom mpi4py import MPI\nimport dtwa_quantum_spins as dtwa\n\ncomm = MPI.COMM_WORLD\n\n#Your codes\n#...\n#You'll need to create the hopping matrix.\n#If you don't, then the default is is the dense Jmn hopping matrix with inverse \n#power law decay for periodic boundary conditions.\n#...\n\n#Initiate the parameters for dTWA\np = dtwa.ParamData(hopmat=hopping_matrix,norm=scales_hopmat, latsize=lattice_size,\\\n\t  hx=x_field, hy=y_field, hz=z_field\\\n\t    jx=x_hopping, jy=x_hopping, jz=x_hopping)\n\n#Initiate the DTWA system with the parameters:\n#3. Set 'jac' to True if you want the integrator to use the jacobian of the BBGKY dynamics. Use\n#   sparingly, since the size of the jacobian grows as lattice_size**2.\n\n#This object sets up the truncated wigner only\nd = dtwa.Dtwa_System(p, MPI_COMMUNICATOR, n_t=number_of_sampled_trajectories, verbose=True)\n\n#This object sets up the DTWA system with BBGKY corrections and the parameters and niter\nd = dtwa.Dtwa_BBGKY_System(p, comm, n_t=niter, seed_offset = 0, verbose=True)\n\n#Prepare the times\nt0 = 0.0\nt1 = 1.0\nnsteps = 200\n\n#Get the output dictionary\n#This contains: \n#1. The times,\n#2. The single site observables (x,y and z), and \n#3. All correlation sums (xx, yy, zz, xy, xz and yz).\n\n#You can choose different sampling schemes\ndata = d.evolve((t0, t1, nsteps), sampling=\"spr\")\n\n#Output of data\nif comm.Get_rank() == 0:\n      #Prepare the output files. One for each observable\n      append_all = \"_time_alpha_\" + str(alpha) + \"_N_\"+str(l)+\"_2ndorder.txt\"\n      \n      outfile_magx = \"sx\" + append_all\n      outfile_magy = \"sy\" + append_all\n      outfile_magz = \"sz\" + append_all\n    \n      outfile_sxvar = \"sxvar\" + append_all\n      outfile_syvar = \"syvar\" + append_all\n      outfile_szvar = \"szvar\" + append_all\n\n      outfile_sxyvar = \"sxyvar\" + append_all\n      outfile_sxzvar = \"sxzvar\" + append_all\n      outfile_syzvar = \"syzvar\" + append_all\n      \n      #Dump each observable to a separate file\n      np.savetxt(outfile_magx, \\\n\t    np.vstack((data.t_output, data.sx)).T, delimiter=' ')\n      np.savetxt(outfile_magy, \\\n\t    np.vstack((data.t_output, data.sy)).T, delimiter=' ')\n      np.savetxt(outfile_magz, \\\n\t    np.vstack((data.t_output, data.sz)).T, delimiter=' ')\n      np.savetxt(outfile_sxvar, \\\n\t    np.vstack((data.t_output, data.sxvar)).T, delimiter=' ')\n      np.savetxt(outfile_syvar, \\\n\t    np.vstack((data.t_output, data.syvar)).T, delimiter=' ')\n      np.savetxt(outfile_szvar, \\\n\t    np.vstack((data.t_output, data.szvar)).T, delimiter=' ')\n      np.savetxt(outfile_sxyvar, \\\n\t    np.vstack((data.t_output, data.sxyvar)).T, delimiter=' ')\n      np.savetxt(outfile_sxzvar, \\\n\t    np.vstack((data.t_output, data.sxzvar)).T, delimiter=' ')\n      np.savetxt(outfile_syzvar, \\\n\t    np.vstack((data.t_output, data.syzvar)).T, delimiter=' ')\n      \n      #Alternatively, convert output to discionary and dump to single \n      #file.\n      #Either as a csv file\n      w = csv.writer(open(\"output.csv\", \"w\"))\n      for key, val in vars(data).items():\n\t    w.writerow([key, val])\n      ##Or any other way you want :)\n\n      ##You can also use matplotlib to plot them\n      import matplotlib.pyplot as plt\n      plt.figure(1)\n      plt.subplot(221)\n      plt.plot(t_output, data.sx,label=\"sx\")\n      plt.plot(t_output, data.sy,label=\"sy\")\n      plt.plot(t_output, data.sz,label=\"sz\")\n      plt.title('Single site observables')\n\n\n      plt.subplot(222)\n      plt.plot(t_output, data.sxvar, label = \"x-var\")\n      plt.plot(t_output, data.syvar, label = \"y-var\")\n      plt.plot(t_output, data.szvar, label = \"z-var\")\n      plt.title('Diagonal correlations')\n    \n      plt.subplot(223)\n      plt.plot(t_output, data.sxyvar, label = \"xy-var\")\n      plt.plot(t_output, data.sxzvar, label = \"xz-var\")\n      plt.plot(t_output, data.syzvar, label = \"yz-var\")\n      plt.title('Off - Diagonal Correlations')\n    \n      plt.show()\n\n\n```\n\n\n\nRelevant Literature:\n-----\n\n###Relevant papers:\n* [PRM: arXiv:1510.03768 (2015)](http://arxiv.org/abs/1510.03768)\n* [Wooters: Annals of Physics 176, 1-21 (1987)](http://dx.doi.org/10.1016/0003-4916%2887%2990176-X)\n* [Anatoli : Ann. Phys 325 (2010) 1790-1852](http://arxiv.org/abs/0905.3384)\n* [Mauritz: New J. Phys. 15, 083007 (2013)](http://arxiv.org/abs/1209.3697)\n* [Schachenmayer: Phys. Rev. X 5 011022 (2015)](http://arxiv.org/abs/1408.4441)\n\n###Relevant docs for the bundled version of mpi4py reduce:\n* [GitHub](https://github.com/mpi4py/mpi4py/blob/master/demo/reductions/reductions.py)\n* [readthedocs.org](https://mpi4py.readthedocs.org/en/latest/overview.html#collective-communications)\n* [Google Groups](https://groups.google.com/forum/#!msg/mpi4py/t8HZoYg8Ldc/-erl6BMKpLAJ)\n\n\n###External dependencies:\n1. mpi4py - MPI for Python\n\n    _\\_-MPI (Parallelizes the different samplings of the dtwa)\n\n2. numpy - Numerical Python (Various uses)\n\n3. scipy  - Scientific Python\n\n    _\\_-integrate \n\n    _| \\_-odeint (Integrates the BBGKY dynamics of the sampled state)\n\n    _| \\_-signal \n    \n    _| \\_-fftconvolve (Used for calculating spin correlations)\n\n4. tabulate - Tabulate module \n    \n    _\\_-tabulate (Used for dumping tabular data)\n\n###TODO:\n1. Let the final output be a matrix of spins at end time AND observables. Let the user calculate what he wants and distribute the memory via multiple MPI communicators.\n2. How to handle the MemoryError for large hopping matrices:\n   * Write in README above docs for using np.memmap for the hopping matrix\n3. Lots of work on the docs\n4. Write the site-site correlations as function of time via parallel hdf5\n", 
  "id": 42171776
}
{
  "read_at": 1462554566, 
  "description": "For a data-set comprising a mixture of rare and common populations, density sampling gives equal weights to selected representatives of those distinct populations.", 
  "README.md": "# Density_Sampling\n\nOverview\n--------\n\nFor a data-set comprising a mixture of rare and common populations, density sampling gives equal weights \nto selected representatives of those distinct populations.\n\nDensity sampling is a balancing act between signal and noise. Indeed, while it increases the prevalence of rare populations, it also increases the prevalence of noisy sample points that would happen to have their local densities larger than an outlier density computed by density sampling.\n\nMore specifically, density sampling proceeds as follows:\n* For each sample point of the data-set 'data', estimate a local density in feature space by counting the number of neighboring data-points within a particular region centered around that sample point.\n* The ``i``-th sample point of the data-set is selected by density sampling with a probability given by:\n```\n                                | 0 if outlier_density > LD[i];\n  P(keep the i-th data-point) = | 1 if outlier_density <= LD[i] <= target_density;\n                                | target_density / LD[i] if LD[i] > target_density.\n```                                      \nHere ``LD[i]`` denotes the local density of the ``i``-th sample point of the data-set, whereas ``outlier_density`` and ``target_density`` are computed as particular percentiles of the distribution of local densities.\n\nInstallation and Requirements\n-----------------------------\n\nDensity_Sampling is written in Python 2.7 and requires the following packages, along with a few modules \nfrom the Python Standard Library:\n* NumPy >= 1.9.0\n* scikit-learn\n* setuptools\n\nIt is recommended that you ascertain that those requirements are met and check that the afore-mentioned libraries are up and running, even though the ``pip``command below should automatically handle the installation of those dependencies. \nYou can install Density_Sampling from the Python Package Index (PyPI) in two simple steps:\n* open a terminal emulator window to interact with the Shell (KDE's ``konsole`` or GNOME's ``terminal``); \n* enter the command: ``pip install Density_Sampling``\n\nThis module has been tested on Fedora, OS X and Ubuntu and should work fine on any other member of the Unix-like family of operating systems. \n\nUsage\n-----\n\nMore information on the inner workings of density sampling can be gained from the docstrings associated to the functions making up this module.\n\nThe following few lines illustrate density sampling on the Iris data-set from the UCI Machine Learning repository. Instead of copying those lines into a Python interpreter console, a similar exemple can be run automatically via Python's doctest's functionality. Simply locate the directory holding the file ``Density_Sampling.py``, change it to your current working directory and then type ``python Density_Sampling.py`` at the command line.\n\n```\n>>> from sklearn import datasets\n\n>>> iris = datasets.load_iris()\n>>> Y = iris.target\n\n>>> from sklearn.decomposition import PCA\n\n>>> X_reduced = PCA(n_components = 3).fit_transform(iris.data)\n\n>>> import matplotlib.pyplot as plt\n>>> from mpl_toolkits.mplot3d import Axes3D\n>>> from time import sleep\n\n>>> def plot_PCA(X_reduced, Y, title):\n    fig = plt.figure(1, figsize = (10, 8))\n    ax = Axes3D(fig, elev = -150, azim = 110)\n    \n    ax.scatter(X_reduced[:, 0], X_reduced[:, 1], X_reduced[:, 2], \n               c = Y, cmap = plt.cm.Paired)\n                   \n    ax.set_title('First three PCA direction for {title}'.format(**locals()))\n    ax.set_xlabel('1st eigenvector')\n    ax.w_xaxis.set_ticklabels([])\n    ax.set_ylabel('2nd eigenvector')\n    ax.w_yaxis.set_ticklabels([])\n    ax.set_zlabel('3rd eigenvector')\n    ax.w_zaxis.set_ticklabels([])\n        \n    plt.show(block = False)\n    sleep(3)\n    plt.close()\n    \n>>> plot_PCA(X_reduced, Y, 'the whole Iris data-set')\n\n>>> import Density_Sampling\n>>> sampled_indices = Density_Sampling.density_sampling(X_reduced, \n                        metric = 'euclidean', desired_samples = 50)\n                        \n>>> downsampled_X_reduced = X_reduced[sampled_indices, :]\n>>> downsampled_Y = Y[sampled_indices]\n\n>>> plot_PCA(downsampled_X_reduced, downsampled_Y, \n             'the Iris data-set\\ndown-sampled to about 50 samples')\n```\n\nReference\n---------\n\nGiecold, G., Marco, E., Trippa, L. and Yuan, G.-C.,\n\"Robust Lineage Reconstruction from High-Dimensional Single-Cell Data\". \nArXiv preprint [q-bio.QM, stat.AP, stat.CO, stat.ML]: http://arxiv.org/abs/1601.02748\n", 
  "id": 46739771
}
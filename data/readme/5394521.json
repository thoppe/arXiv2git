{
  "read_at": 1462552219, 
  "description": "Topology and Parameter Evolving Universal Learning Network platform DXNN MK2", 
  "README.txt": "DXNN MK2 Erlang,\nBy Gene Sher\nhttp://DXNN.org\nhttp://DXNNResearch.com\nCorticalComputer@gmail.com\n\nBrief documentation for this package is included in this README file.  \n\n-------------\n1. LICENSE\n-------------\n\nCopyright (C) 2009 by Gene Sher, DXNN Research Group, CorticalComputer@gmail.com\nAll rights reserved.\n\nThis code is licensed under the Apache License, Version 2.0.\nPlease see the LICENSE file that accompanies this project for the terms of use.\n\n---------------------\n2. USAGE and SUPPORT\n---------------------\n\nI hope that this software will be a useful starting point for your own\nexplorations in the creation of Computational Intelligence. The software is provided \nas is; however, I will do my best to maintain it and accommodate\nsuggestions. If you want to be notified of future releases of the\nsoftware or have questions, comments, bug reports or suggestions, send\nan email to CorticalComputer@gmail.com, or request a user account at www.DXNNResearch.com\n\nAlternatively, you may post your questions on dxnn.org or dxnnresearch.com\n\nThe following explains how to use DXNN.\n\nINTRO\n-----\nDXNN is a fully distributed Topology and Weight Evolving Artificial Neural Network system\ncreated and invented by Gene Sher. Originaly introduced in the publication preprint of 2010 \navailable on arXiv:1011.6022v3 The current state of the project is composed of the following:\n\nCortex synchronizes Neurons, Sensors, and Actuators. A population monitor controls a population \nof agents, it is the population_monitor process that spawns agents, waits for them to be evaluated, \nand then performs the selection, replication, and variation (application of various mutation \noperators). Furthermore, due to this being a memetic algorithm based system (although can be \nchanged to genetic, by simply switching max_attempts variable to 1), each NN based agent system \ncomes with an exoself process, which performs the synaptic weight tuning.\n\nScapes are simulations, not necessarily of 3d environments. It is through scapes that problems are \npresented to the agents, and it is the agent's morphology which defines the agent's sensors and \nactuators, and thus defines which scapes it can interface with. The system itself, the mnesia \ndatabase, and the top most system, is called polis (It's Greek for city state).\n\nThis version is 1.0, and it does not have a lot of comments (or any), since I built it primarily \nfor myself. But v2.0, which I will release very soon after this, is better and cleaner implemented.\n Has more functionality, and is fully documented. It is also the version built inside my upcoming \n book: Neuroevolution Through Erlang, to be released towards the end of this year (just recently \n submitted my manuscript to my editor). But if you want to give this version a try (feel free to \n send me an email if you can't get it to work), then by all means go for it. You might find strange \n comments somewhere in the source code, since I did not take out any notes I wrote for myself.\n\nSTARTING POINT\n--------------\nFrom inside Erlang.\n1. %%%%Compilation%%%%\n\tmake:all().\n2. %%%%Initialize All Databases%%%%\n\tFirst create a folder called \"benchmarks\", the system expects it to exist, and writes files to it when performing benchmarks.\n\tpolis:create(). % This creates the database\n3. %%%%Start The Polis Databases%%%%\n\tpolis:start(). % This starts the polis process, the whole thing, the infrastructure (it runs the scapes...)\n4. At this point you can summon NN based agents or populations of agents, construct Sensors and \nActuators and provide them to the NNs... This section will be expanded in future additions.\n\nTo set the population and agents to the preferred sensors and actuators, modify the INIT_CONSTRAINTS \n(in population_monitor module), and use the particular morphology you want (check the morphology \nmodule, different morphologies are for different problems), and then execute population_monitor:start(),\nwhich will create the population of size decided by you of agents using the specified morphology and \nthus the sensors and actuators. If you want the agents to discover and explore the available sensors \nand actuators (perform feature selection in a sense) then modify modular_constructor, ensuring that you \nuse the get_InitSensors() and get_InitActuators() function, instead of the get_Sensors() and get_Actuators() \nfunction used within the module. The get_Init.. starts the population off with the NN based agents using \njust a single sensor and actuator, exploring other available sensors and actuators within the morphology \nas they evolve. You can add new sensors and actuators by specifying those sensors and actuators in the \nmorphology module, and then creating those functions in the sensors and actuators modules. New mutation \noperators, activation functions... all can be added within the records.hrl, as long as those functions are \nrealized/implemented in their respective modules so that they can be executed when called upon.\n", 
  "id": 5394521
}
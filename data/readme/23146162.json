{
  "id": 23146162, 
  "read_at": 1462553361, 
  "README.rst": ".. image:: nstatic/COIN.jpg\n\n\n\ncosmoabc - Likelihood free inference for cosmology\n==================================================\n\n\n``cosmoabc`` is a package which enables parameter inference using an Approximate Bayesian Computation (ABC) algorithm, as described in `Ishida et al., 2015 <http://arxiv.org/abs/1504.06129>`_.\n\nThe code was originally designed for cosmological parameter inference from galaxy clusters number counts based on Sunyaev-Zel'dovich measurements. In this context, the cosmological simulations were performed using the `NumCosmo library <http://www.nongnu.org/numcosmo/>`_ .\n\nNevertheless, the user can easily take advantage of the ABC sampler along with his/her own simulator, as well as  test personalized prior distributions and distance functions. \n\n\nGet it now!\n***********\n\nThe package can be installed using the PyPI and pip::\n\n    $ pip install cosmoabc\n\nOr if the tarball or repository is downloaded, in the cosmoabc directory you can install and test it::\n\n    $ python setup.py install\n\nYou can run a few tests with::\n\n    $ test_ABC_algorithm.py\n\n.. warning::  \n    The  above tests will generate a lot of output data file and a pdf file with their graphical representation. \n    This was chosen to facilitate the identification of errors. \n\n    Make sure to run the tests in their own directory. \n\nThe test outputs a file illustrating the evolution of the posterior.\n\n.. image:: nstatic/results_gaussian_sim.gif\n\nInput Parameter File\n********************\n\nSample input in can be found in ``~cosmoabc/examples``. All example files mentioned in this section are available in that directory. \n\nThe user input file should contain all necessary variables for simulation as well as for the ABC sampler.\n\nA simple example of user input file, using a simulator which takes 3 parameters as input (``mean``, ``std``, ``n``) from which we want to fit only two (``mean``, ``std``), would look like this ::\n\n    path_to_obs\t\t= None   \t           # path to observed data \n\n    param_to_fit \t= mean \tstd  \t           # parameters to fit\n    param_to_sim    \t= mean  std  n\t           # parameters needed for simulation\n\n    prior_func\t        = my_prior flat_prior      # one prior function for each parameter\n                                                   # under consideration\n\n    mean_prior_par_name      = pmin pmax           # parameters for prior distribution  \n    mean_prior_par_val       = -2.0  4.0           # values for prior distribution   \n\n    std_prior_par_name       = pmin  pmax          # parameters for prior distribution\n    std_prior_par_val        =  0.1  5.0           # values for prior distribution\n\t\n    mean_lim                 = -2.0  4.0           # extreme limits for parametes\n    std_lim                  = 0.1  5.0            #\n\t\t           \n    mean\t\t     = 2.0                 # parameters values need for simulation\n    std\t\t= 1.0                              #\n    n\t\t= 1000                             #\n\n    M  \t\t= 100\t\t\t\t   # number of particle in each particle system\n    Mini        = 200                              # number of draws for 1st particle system\n    delta       = 0.25\t\t\t\t   # convergence criteria\n    qthreshold \t= 0.75\t\t\t\t   # quantile in distance threshold \n\n    file_root \t    = toy_model_PS                 # root to output files names \n    screen          = 0\t\t\t           # rather (1) or not (0) to screen outputs\n    ncores          = 1\t\t\t\t   # number of cores\n    split_output    = 1                            # number of intermediate steps written to file\n\n    simulation_func = my_simulation                # simulation function\n    distance_func   = my_distance                     # distance function\n\n\nImportant notes on input parameters\n-----------------------------------\n\n* In the current implementation, it is important  to include a `` # `` symbol preceded and followed by a white space after the definition of each variable in the input file. \n\n* The variable ``path_to_obs`` can be set to ``None``, in this case, ``cosmoabc`` will generate one catalogue from the simulator and consider it as the *observed* catalogue. It will also output this catalogue to a data file, so it can be used for further scrutnity.\n\n* If you are using your own prior function, you are free to name the prior parameters as you wish, you only need to define ``<your_variable>_prior_par_name`` and ``<your_variable>_prior_par_val`` accordingly. If you have doubts about variable names, a quick comparison between the two example input files (toy model and NumCosmo) might help.  \n\n* The parameter ``split_output`` determines how many sub-sets of particles you wish to generate for each particle system. Its goal is to avoid the lost of partial results for an enventual problem when dealing with very complex, and time consuming, simulators. If you are only making a quick test and has no intention to keep partial results, just set ``split_output = 1``. \n\n\nSimulation, distance and prior functions\n****************************************\n\nThe most important ingredients in an ABC analysis are:\n\n* the prior probability distributions (PDF)\n* the simulator\n* the distance function\n\nBuilt-in options for priors PDF are:\n\n* Gaussian\n* flat\n* beta\n\nBuilt-in option for simulations is:\n\n* NumCosmo simulation\n\nBuilt-in options for distance functions are:\n\n* Quantile-based distance with number of objects criteria\n* Gaussian Radial Basis Function distance (as descrived in Appendix B of `Ishida et al., 2015 <http://arxiv.org/abs/1504.06129>`_)\n\nMoreover, ``cosmoabc`` is also able to handle user defined functions for all three elements. \nYou will find example files which will help you tailor your functions for the ABC sampler. \n\nOnce all the function definitions are determined, the ABC sampler can be called from the command line::\n\n    $ run_ABC.py -i <user_input_file>  -f <user_function_file>\n\nThis will run the algorithm until the convergence criteria is reached. A pdf file containing graphical representation of the results for each particle system is \ngiven as output, as well as numerical data files. \n\nIf the achieved result is not satisfactory, or if for some reason the calculation was stopped before reaching the convergence criteria, it is possible to run the ABC sampler beginning from the last completed particle system ``N``. \n\nFrom the command line::\n\n    $ continue_ABC.py -i <user_input_file> -f <user_function_file> -p N\n\nIn case the convergence criteria was achieved but you wish to continue the run, remember to decrease the convergence criteria ``delta`` in the ``<user_input_file>`` before continuing. \n\nAt any time it is possible to plot the outcomes from ``N`` particle systems, whose calculations were completed, using::\n\n    $ plot_ABC.py -i <user_input_file> -p N\n\nIt is also possible to use it interactively.\nConsidering we are using built-in simulation, prior and distance functions, \n\n.. code-block:: python \n\n    from cosmoabc.priors import flat_prior\n    from cosmoabc.ABC_sampler import ABC\n    from cosmoabc.plots import plot_2D\n    import numpy as np\n     \n    #user input file\n    filename = 'my_input.dat'\n\n    #read  user input\n    Parameters = read_input(filename)\n\n    #initiate ABC sampler\n    sampler_ABC = ABC(params=Parameters) \n\n    #build first particle system\n    sys1 = sampler_ABC.BuildFirstPSystem()\n\n    #update particle system until convergence\n    sampler_ABC.fullABC()\n\n    #plot results\n    plot_2D( sampler_ABC.T, 'results.pdf' , params)\n\n\nIf you are using your own distance function, remember to determine the dimension of its output manually,\n\n.. code-block:: python\n\n    from cosmoabc.priors import flat_prior\n    from cosmoabc.ABC_sampler import ABC\n    import numpy as np\n\n    from my_functions import my_distance\n     \n    #user input file\n    filename = 'my_input.dat'\n\n    #read  user input\n    Parameters = read_input(filename)\n\n    #calculate distance between 2 catalogues\n    dtemp = my_distance(Parameters['dataset1'], Parameters)\n    #determine dimension of distance output\n    Parameters['dist_dim'] = len(dtemp)\n\n    #initiate ABC sampler\n    sampler_ABC = ABC(params=Parameters) \n\n    #build first particle system\n    sys1 = sampler_ABC.BuildFirstPSystem()\n\n    #update particle system until convergence\n    sampler_ABC.fullABC()\n\n.. warning:: \n    | When using your own **distance function** remember that it must take as input:\n    | - a catalogue and \n    | - a dictionary of input parameters\n    |\n    | When using your own **prior function**, it must take as input:\n    | - a dictionary of input parameters\n    | - a boolean variable ``func`` (optional):\n    |  if ``func`` is ``False`` returns one sampling of the underlying distribution\n    |  if ``func`` is ``True`` returns the PDF itself\n\n\nNumCosmo simulations\n--------------------\n\nIn order to reproduce the results of `Ishida et al., 2015 <http://arxiv.org/abs/1504.06129>`_, first you need to make sure the NumCosmo library is running smoothly. \nInstructions for complete installation and tests can be found at the  `NumCosmo website <http://www.nongnu.org/numcosmo/>`_.\n\nAn example of input file for NumCosmo simulations is provided in the corresponding directory.\nOnce the simulator is installed run the complete ABC sampler + NumCosmo cluster simulations from the command line::\n\n    $ run_ABC_NumCosmo.py -i <user_input_file>\n\n\nThis will run the complete analysis presented in the above paper.\n\nAnalogously to what is available for the user defined simulations, we can also continue a NumCosmo calculation from particle system ``N`` with::\n\n    $ continue_ABC_NumCosmo.py -i <user_input_file> -p N\n\nIf we want to run the NumCosmo simulation with a different prior or distance function, we should define it in a separate file and run::\n\n    $ run_ABC_NumCosmo.py -i <user_input_file> -f <user_function_file>\n\nPlots are generated exactly as explained above for the user defined functions.\n\nTesting Distances\n*****************\n\nIf you are using a personalized distance, make sure that it applies to the particular problem you are facing. \nYou need to be sure that the distance definition you adpoted yields increasingly larger distances for increasingly different catalogues. \n\n``cosmoabc`` has a built-in script which allows you to visually test the performances of your choices. \nIn order to use it, prepare an appropriate user input and function files and, from the command line, do::\n\n    $ test_ABC_distance.py -i <user_input_file> -f <user_function_file> -o <output_filename>\n\nHere, ``<output_filename>`` is where the distance behaviour for different set of parameter values will be plotted. \n\nAs always, the ``<user_input_file>`` must be provided. \nIf you are using built-in ``cosmoabc`` functions, the ``-f`` option is not necessary and in case you forget to give an output filename, ``cosmoabc`` will ask you for it. \nIt will also ask you to input the number of points to be drawn from the parameter space in order to construct a grid. \n\nHere is an example from using the built-in tool to check the suitability of the distance function described in section 3.1 of the paper::\n\n    $ test_ABC_distance.py -i user_input_file.dat -f user_function_file.dat \n    $ Distance between identical cataloges = [ 0.]\n    $ New parameter value = [ 0.41054026  0.6364732 ]\n    $ Distance between observed and simulated data = [804.38711094885957]\n    $ Enter number of draws in parameter grid: 5000            \n    $ Particle index: 1\n    $ Particle index: 2\n    $ Particle index: 3\n    $ Particle index: 4\n    $ ...\n    $ Particle index: 5000\n    $ Figure containing distance results is stored in output.pdf\n\nThe output file will contain a plot like this:\n\n.. image:: nstatic/distance_toy_model.png\n \n\nThe example above corresponds to a perfect distance definition, since it gets close to zero as parameters ``mean`` and ``std`` approaches the fiducial values and sharply increases for further values.\n\nThis is what one should aim for in constructing a distance function. \nHow large a deviation from this is acceptable should be decided based on each particular problem and goal. \n\nBibtex entry \n************\n\nIf you use ``cosmoabc`` in you research, we kindly ask you to cite the original paper.\nThe code includes a built-in citation function which outputs the bibtex entry\n\n.. code-block:: python\n\n    import cosmoabc\n    \n    cosmoabc.__cite__()\n\nthis will return::\n\n    @ARTICLE{2015arXiv150406129I,\n    author = {{Ishida}, E.~E.~O. and {Vitenti}, S.~D.~P. and {Penna-Lima}, M. and\n              {Cisewski}, J. and {de Souza}, R.~S. and {Trindade}, A.~M.~M. and\n              {Cameron}, E. and {V.~C.~Busti}},\n    title = \"{cosmoabc: Likelihood-free inference via Population Monte Carlo Approximate Bayesian Computation}\",\n    journal = {ArXiv e-prints},\n    archivePrefix = \"arXiv\",\n    eprint = {1504.06129},\n    keywords = {Astrophysics - Cosmology and Nongalactic Astrophysics, Astrophysics - Instrumentation and Methods for Astrophysics},\n    year = 2015,\n    month = apr,\n    adsurl = {http://adsabs.harvard.edu/abs/2015arXiv150406129I},\n    adsnote = {Provided by the SAO/NASA Astrophysics Data System}\n    }\n\n        \n\n\nRequirements\n************\n\n* Python 2.7\n* numpy >=1.8.2\n* scipy >= 0.14.0\n* statsmodels >= 0.5.0\n* matplotlib >= 1.3.1     \n* argparse >= 1.1\n* multiprocessing >= 0.70a1\n\n\n\nOptional\n--------\n\n* `NumCosmo <http://www.nongnu.org/numcosmo/>`_\n\n\nLicense\n********\n\n* GNU General Public License (GPL>=3)\n\n\nThe Cosmostatistics Initiative (COIN)\n*************************************\n\nThe IAA Cosmostatistics Initiative (`COIN <https://asaip.psu.edu/organizations/iaa/iaa-working-group-of-cosmostatistics>`_) is a non-profit organization whose aim is to nourish the synergy between astrophysics, cosmology, statistics and machine learning communities. \nThis work is a product of the first COIN Summer Residence Program, Lisbon, August/2014.\n\nOther projects developed under COIN can be found in the `COINtoolbox <http://cointoolbox.github.io/>`_\n\nAcknowledgements\n****************\n\nIn order to give proper credit to the online sources used in the development of this work, we list bellow the main  websites, foruns and blogs which were used in different parts of its development. **We deeply thank everyone who contributes to open learning plataforms**.\n\n`Multiprocessing and KeyboarInterrupt <http://bryceboe.com/2010/08/26/python-multiprocessing-and-keyboardinterrupt/>`_\n\n`Ordering gif <http://stackoverflow.com/questions/12339330/defining-the-file-order-for-imagemagick-convert>`_\n\n`Plotting <http://nbviewer.ipython.org/gist/tillahoffmann/f844bce2ec264c1c8cb5>`_\n\n`Remembering git commands <https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init>`_\n\n", 
  "description": ""
}
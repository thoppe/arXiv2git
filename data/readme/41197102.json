{
  "read_at": 1462546031, 
  "description": "FMDummy text indexes library", 
  "README.md": "# FMDummy text indexes library\n\n##What is it?\nThe FMDummy text indexes are fast variants of the FM-index, a well-known compressed full-text index by Ferragina and Manzini (2000). We focus more on search speed than space use. One of the novelties is a rank solution with 1 cache miss in the worst case, which (to our knowledge) was not used earlier elsewhere.\n\nThe current version handles only the count query (i.e., returns the number of occurrences of the given pattern).\n\n##Requirements\nThe FMDummy text indexes require:\n- C++11 ready compiler such as g++ version 4.7 or higher\n- a 64-bit operating system\n- text size is limited to (FMDummy2 limitations are the worst cases for incompressible text, usually they are not so strong):\n    - 4GB for FMDummy1, FMDummy3 and FMDummyWT\n    - 0.8GB for FMDummy2 with SCBO schema and 3 bitsPerChar\n    - 1.2GB for FMDummy2 with SCBO schema and 4 bitsPerChar\n    - 1.1GB for FMDummy2 with CB schema and 3 bitsPerChar\n    - 1.5GB for FMDummy2 with CB schema and 4 bitsPerChar\n\n\n##Installation\nTo download and build the library use the following commands:\n```\ngit clone https://github.com/mranisz/fmdummy.git\ncd fmdummy\nmake\n```\n\n##Usage\nTo use the FMDummy library:\n- include \"fmdummy/fmdummy.h\" to your project\n- compile it with \"-std=c++11 -O3 -mpopcnt\" options and link it with libraries:\n  - fmdummy/libfmdummy.a\n  - fmdummy/libs/libaelf64.a (linux) or fmdummy/libs/libacof64.lib (windows)\n- use \"fmdummy\" namespace\n\n##API\nThere are several functions you can call on each of the FMDummy text index:\n- **build** the index using the text:\n```\nvoid build(unsigned char* text, unsigned int textLen);\n```\n- **save** the index to file called fileName:\n```\nvoid save(const char *fileName);\n```\n- **load** the index from file called fileName:\n```\nvoid load(const char *fileName);\n```\n- **free** memory occupied by index:\n```\nvoid free();\n```\n- get the **index size** in bytes (size in memory):\n```\nunsigned int getIndexSize();\n```\n- get the size in bytes of the text used to build the index:\n```\nunsigned int getTextSize();\n```\n- get the result of **count** query:\n```\nunsigned int count(unsigned char *pattern, unsigned int patternLen);\n```\n- set **verbose** mode:\n```\nvoid setVerbose(bool verbose);\n```\n\n##FMDummy1\nFMDummy1 can be built for up to 16 selected characters from text.\n\nParameters:\n- indexType:\n      - FMDummy1::TYPE_256 (default) - using 256b blocks: 64b of rank data and 192b of text data\n      - FMDummy1::TYPE_512 - using 512b blocks: 64b of rank data and 448b of text data\n- selectedChars:\n      - up to 16 ordinal character values, e.g. {'A','C','G','T'}\n      - {} (default) - all characters from the text\n\nConstructors:\n```\nFMDummy1();\nFMDummy1(FMDummy1::IndexType indexType, vector<unsigned char> selectedChars);\n```\n\n##FMDummy1-hash\nFMDummy1-hash is FMDummy1 with hashed k-symbol prefixes of suffixes from suffix array to speed up searches (k >= 2). This variant is particularly efficient in speed for short patterns (not much longer than k).\n\nParameters:\n- indexType:\n      - FMDummy1::TYPE_256 - using 256b blocks: 64b of rank data and 192b of text data\n      - FMDummy1::TYPE_512 - using 512b blocks: 64b of rank data and 448b of text data\n- selectedChars:\n      - up to 16 ordinal character values, e.g. {'A','C','G','T'}\n      - {} (default) - all characters from the text\n- k - length of prefixes of suffixes from suffix array (k >= 2)\n- loadFactor - hash table load factor (0.0 < loadFactor < 1.0)\n\nLimitations: \n- pattern length >= k (patterns shorter than k are handled by standard variant of FMDummy1 index)\n\nConstructors:\n```\nFMDummy1(FMDummy1::IndexType indexType, vector<unsigned char> selectedChars, unsigned int k, double loadFactor);\n```\n\n##FMDummy2\n\nParameters:\n- indexType:\n      - FMDummy2::TYPE_256 (default) - using 256b blocks: 64b of rank data and 192b of encoded text data\n      - FMDummy2::TYPE_512 - using 512b blocks: 64b of rank data and 448b of encoded text data\n- schema:\n      - FMDummy2::SCHEMA_SCBO (default) - using SCBO encoding (A. Farina, G. Navarro, J. Parama. Boosting text compression with word-based statistical encoding. The Computer Journal, 55(1):111-131, 2012)\n      - FMDummy2::SCHEMA_CB - using CB encoding\n- bitsPerChars:\n      - FMDummy2::BITS_4 (default) - using 4 bits to store the encoded symbol\n      - FMDummy2::BITS_3 - using 3 bits to store the encoded symbol\n\nConstructors:\n```\nFMDummy2();\nFMDummy2(FMDummy2::IndexType indexType, FMDummy2::Schema schema, FMDummy2::BitsPerChar bitsPerChar);\n```\n\n##FMDummy2-hash\nFMDummy2-hash is FMDummy2 with hashed k-symbol prefixes of suffixes from suffix array to speed up searches (k >= 2). This variant is particularly efficient in speed for short patterns (not much longer than k).\n\nParameters:\n- indexType:\n      - FMDummy2::TYPE_256 - using 256b blocks: 64b of rank data and 192b of encoded text data\n      - FMDummy2::TYPE_512 - using 512b blocks: 64b of rank data and 448b of encoded text data\n- schema:\n      - FMDummy2::SCHEMA_SCBO - using SCBO encoding (A. Farina, G. Navarro, J. Parama. Boosting text compression with word-based statistical encoding. The Computer Journal, 55(1):111-131, 2012)\n      - FMDummy2::SCHEMA_CB - using CB encoding (Sz. Grabowski, M. Raniszewski, S. Deorowicz. FM-index for dummies. arXiv:1506.04896, 2015)\n- bitsPerChars:\n      - FMDummy2::BITS_4 (default) - using 4 bits to store the encoded symbol\n      - FMDummy2::BITS_3 - using 3 bits to store the encoded symbol\n- k - length of prefixes of suffixes from suffix array (k >= 2)\n- loadFactor - hash table load factor (0.0 < loadFactor < 1.0)\n\nLimitations: \n- pattern length >= k (patterns shorter than k are handled by standard variant of FMDummy2 index)\n\nConstructors:\n```\nFMDummy2(FMDummy2::IndexType indexType, FMDummy2::Schema schema, FMDummy2::BitsPerChar bitsPerChar, unsigned int k, double loadFactor);\n```\n\n##FMDummy3\nFMDummy3 is intended for DNA sequences (it searches only for patterns consisting of the symbols A, C, G, T).\n\nParameters:\n- indexType:\n      - FMDummy3::TYPE_512 (default) - using 512b blocks: 128b of rank data and 384b of text data\n      - FMDummy3::TYPE_1024 - using 1024b blocks: 128b of rank data and 896b of text data\n\nConstructors:\n```\nFMDummy3();\nFMDummy3(FMDummy3::IndexType indexType);\n```\n\n##FMDummy3-hash\nFMDummy3-hash is FMDummy3 with hashed k-symbol prefixes of suffixes from suffix array to speed up searches (k >= 2). This variant is particularly efficient in speed for short patterns (not much longer than k).\n\nParameters:\n- indexType:\n      - FMDummy3::TYPE_512 - using 512b blocks: 128b of rank data and 384b of text data\n      - FMDummy3::TYPE_1024 - using 1024b blocks: 128b of rank data and 896b of text data\n- k - length of prefixes of suffixes from suffix array (k >= 2)\n- loadFactor - hash table load factor (0.0 < loadFactor < 1.0)\n\nLimitations: \n- pattern length >= k (patterns shorter than k are handled by standard variant of FMDummy3 index)\n\nConstructors:\n```\nFMDummy3(FMDummy3::IndexType indexType, unsigned int k, double loadFactor);\n```\n\n##FMDummyWT\n\nParameters:\n- wtType:\n      - FMDummyWT::TYPE_WT2 (default) - using binary Huffman-shaped wavelet tree\n      - FMDummyWT::TYPE_WT4 - using 4-ary Huffman-shaped wavelet tree\n      - FMDummyWT::TYPE_WT8 - using 8-ary Huffman-shaped wavelet tree\n- indexType:\n      - FMDummyWT::TYPE_512 (default) - using 512b blocks: 64b of rank data and 448b of encoded text data\n      - FMDummyWT::TYPE_1024 - using 1024b blocks: 64b of rank data and 960b of encoded text data\n\nConstructors:\n```\nFMDummyWT();\nFMDummyWT(FMDummyWT::WTType wtType, FMDummyWT::IndexType indexType);\n```\n\n##FMDummyWT-hash\nFMDummyWT-hash is FMDummyWT with hashed k-symbol prefixes of suffixes from suffix array to speed up searches (k >= 2). This variant is particularly efficient in speed for short patterns (not much longer than k).\n\nParameters:\n- wtType:\n      - FMDummyWT::TYPE_WT2 - using binary Huffman-shaped wavelet tree\n      - FMDummyWT::TYPE_WT4 - using 4-ary Huffman-shaped wavelet tree\n      - FMDummyWT::TYPE_WT8 - using 8-ary Huffman-shaped wavelet tree\n- indexType:\n      - FMDummyWT::TYPE_512 - using 512b blocks: 64b of rank data and 448b of encoded text data\n      - FMDummyWT::TYPE_1024 - using 1024b blocks: 64b of rank data and 960b of encoded text data\n- k - length of prefixes of suffixes from suffix array (k >= 2)\n- loadFactor - hash table load factor (0.0 < loadFactor < 1.0)\n\nLimitations: \n- pattern length >= k (patterns shorter than k are handled by standard variant of FMDummyWT index)\n\nConstructors:\n```\nFMDummyWT(FMDummyWT::WTType wtType, FMDummyWT::IndexType indexType, unsigned int k, double loadFactor);\n```\n\n##FMDummy1 usage example\n```\n#include <iostream>\n#include <stdlib.h>\n#include \"fmdummy/shared/common.h\"\n#include \"fmdummy/shared/patterns.h\"\n#include \"fmdummy/fmdummy.h\"\n\nusing namespace std;\nusing namespace fmdummy;\n\nint main(int argc, char *argv[]) {\n\n\tunsigned int queriesNum = 1000000;\n\tunsigned int patternLen = 20;\n\tunsigned char* text = NULL;\n\tunsigned int textLen;\n\tFMDummy1 *FMD1;\n\tconst char *textFileName = \"dna\";\n\tconst char *indexFileName = \"dna-fm1.idx\";\n\tvector<unsigned char> selectedChars = {'A', 'C', 'G', 'T'};\n\n\tif (fileExists(indexFileName)) {\n\t\tFMD1 = new FMDummy1();\n\t\tFMD1->load(indexFileName);\n\t} else {\n\t\tFMD1 = new FMDummy1(FMDummy1::TYPE_256, selectedChars);\n\t\tFMD1->setVerbose(true);\n\t\ttext = readText(textFileName, textLen, 0);\n\t\tFMD1->build(text, textLen);\n\t\tFMD1->save(indexFileName);\n\t}\n\n\tdouble indexSize = (double)FMD1->getIndexSize();\n\tcout << \"Index size: \" << indexSize << \"B (\" << (indexSize / (double)FMD1->getTextSize()) << \"n)\" << endl << endl;\n\n\tPatterns *P = new Patterns(textFileName, queriesNum, patternLen, selectedChars);\n\tunsigned char **patterns = P->getPatterns();\n\n\tfor (unsigned int i = 0; i < queriesNum; ++i) {\n\t\tcout << \"Pattern |\" << patterns[i] << \"| occurs \" << FMD1->count(patterns[i], patternLen) << \" times.\" << endl;\n\t}\n\n\tif (text != NULL) delete[] text;\n\tdelete FMD1;\n\tdelete P;\n}\n```\nUsing other FMDummy indexes is analogous.\n\n##External resources used in FMDummy project\n- Suffix array building by Yuta Mori (sais)\n- A multi-platform library of highly optimized functions for C and C++ by Agner Fog (asmlib)\n- A very fast hash function by Yann Collet (xxHash)\n\n##Authors\n- Szymon Grabowski\n- [Marcin Raniszewski](https://github.com/mranisz)\n- Sebastian Deorowicz\n", 
  "id": 41197102
}
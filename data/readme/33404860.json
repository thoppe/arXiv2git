{
  "read_at": 1462511954, 
  "description": "Molecular Dynamics Simulation on a Sphere", 
  "README.md": "# Molecular Dynamics Simulation on a Sphere\n\nTim Scheffler, 2015.\n\nThis is a Python/C project to demonstrate molecular dynamics \nsimulation on a sphere. The particles interact via a cutoff Coulomb potential.\nA damping force proportional to the relative velocities of interacting\nparticles will be used to dissipate energy and to cool down the system in\norder to approach a configuration of minimal energy. This ground state\nshould then give the optimal packing of N particles on a sphere. \n\n\n\n##  Dependencies\n\n* Python 2.7\n* A C-Compiler\n* SciPy\n* PyOpenGL\n\nTested on OS X 10.10.2 and Linux Mint 17.1 Cinnamon 64-Bit.\n\n## Building\n\n`$ python setup.py build_ext -i`\n\n## Usage\n\nStart the simulation with \n\n`$ python davis.py`\n\nParameters (like e.g. number of particles or the number of used CPU cores) \nare setup as global variables at the top of `davis.py`.\n\nWith focused OpenGL window you can drag the mouse (while clicking)\nto rotate the sphere. Use the following keys to control the simulation:\n\n* \"g\": start/pause the simulation\n* \"q\": quit\n\nThe simulation writes a a file `davis_observables.csv` containing\nin each row the following data:\n\n* number of steps\n* potential energy\n* number of particles with 6 nearest neighbours \n* number of particles with less than 6 nearest neighbours \n* number of particles with more than 6 nearest neighbours \n\nThis `csv`-File can be plotted with\n\n`$ python plot.py davis_observables.csv`\n\nPlease be aware, that there is no error handling in the C part. If something bad\nhappens, like malloc can not get enough memory or there is a negative \nargument for the `sqrt` function, the program crashes hard.  In that case\ntry a simulation with less particles or smaller time step.\n\n\n## Simulation technique\n\nThis is a molecular dynamics simulation using\nthe _velocity verlet algorithm_[1] for time integration. We make the\nlookup of interacting particles more efficient with a _linked list cell algorithm_[1]. Keeping\nthe particles constrained to the surface of the sphere is done via\nthe _RATTLE algorithm_[2], which can be solved analytically for this simple constraint.\n\nThe simulation is purely three-dimensional: all particles have 3d vectors\nfor position, velocity and acceleration. In principle, as the particles\nare constrained to the surface of the sphere, the system is two-dimensional,\nbut simulating the two-dimensional manifold is more complicated[3] than just\nusing the embedding three-dimensional space for simulation. Doing so\nwe can also use the simple 3d linked cell algorithm for neighbour lookup, although\nmost of the 3d cells will be empty. Additionally, \nwe could use this code for simulation of other constraining surfaces.\n\nThe particle interaction is a cutoff Coulomb potential of the form: \n\n    V(r) = 1/r + r/r_c^2 - 2/r_c   for r < r_c\n           0                       otherwise\n\nwhere `r` is the distance between interacting particles and `r_c`\nis the cutoff-distance. The coulomb force is three-dimensional, meaning\n`r` is just the euclidean distance `r = sqrt(dx^2 + dy^2 + dz^2)` between\ntwo particles.\n\nThe forces between the particles are always repelling, but this is \nnot a problem as the system is confined to the surface of the sphere.\nIn the ground state the overall distance of the particles would reach\na maximum. This would yield in a flat geometry a perfect hexagonal lattice,\nmeaning that each particle would have exactly six nearest neighbours.\n\nIn a non-flat two-dimensional space, like the surface of the sphere, a \nperfect hexagonal lattice cannot be established and there are particles\nwith more or less than six nearest neighbours. (See: _Euler Poincare_ relation.)\n\nDuring the simulation we will observe a system cooling down and \n(hopefully) approaching the ground state. In order to measure the \ndevelopment we will count the number of particles, that have exactly six neighbours.\nFor this we use the [qhull](http://www.qhull.org/) implementation from \n[scipy](http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html#scipy.spatial.ConvexHull). \n\nIn the OpenGL window all particles having six neighbours are coloured **green**, \nparticles having less than six neighbours are coloured **blue**, more than six **red**.\n\nFor the initial configuration it is important, that the particles are not\ntoo close, because the Coulomb potential can become so large, that the\nsimulation gets unstable. Therefore we use the method of [Fibonacci spheres](https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/26127012#26127012) for a good first configuration.\n\nFor more information about Coulomb particles on curved surfaces, please see\nthe talk by Paul Chaikin [\"Classical Wigner Crystals on flat and curved surfaces\"](https://www.youtube.com/watch?v=Wko67TCla74).\n\n## External sources\n\nThe basis for the OpenGL visualisation is taken from [\"Adventures in OpenCL\"](https://github.com/enjalot/adventures_in_opencl/tree/master/python/part2) tutorial series by Ian Johnson. \n\n\n## License\n\nMIT license\n\nCopyright(c) 2015 Tim Scheffler\n\nSome of the code is\ntaken from other sources, and there should be a link to the original source.\n\n## Example Simulation\n\nWe have N = 40000 particles.\n\nInitial configuration after placing 40000 particles with the \n[Fibonacci spheres](https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/26127012#26127012) method:\n\n![Initial condition](./Pictures/steps_0.png \"Initial condition\")\n\n(Particles having six neighbours are coloured **green**, \nparticles having less than six neighbours are coloured **blue**, more than six **red**.)\n\nAfter 660 simulation steps. The global structure of the initial configuration breaks apart:\n\n![Steps = 660](./Pictures/steps_660.png \"Steps = 660\")\n\nAfter 2317 simulation steps:\n\n![Steps = 2317](./Pictures/steps_2317.png \"Steps = 2317\")\n\nAfter 13020 simulation steps:\n\n![Steps = 13020](./Pictures/steps_13020.png \"Steps = 13020\")\n\nConfiguration after 29918 simulation steps:\n\n![Steps = 29918](./Pictures/steps_29918.png \"Steps = 29918\")\n\nAfter comparison of the last two configurations one sees, that the\nnumber of single islands is reduced and the strings become more flat.\nStrings (\"scars\") like these are discussed in the talk by \n[Paul Chaikin](https://www.youtube.com/watch?v=Wko67TCla74).\n\nIf we now plot the development of the number of particles with \nsix nearest neighbours against time, we get the following plot\n\n![Development of NN counts](./Pictures/figure_1.png \"Development of NN counts\")\n\nHere we see, that initially after placing the particles with the \nFibonacci spheres method the distribution is already quite good. After\nstarting the dynamics the global structure from the Fibonacci spheres is \ndestroyed and we temporarily get a configuration with worse NN (Nearest Neighbour) \ndistribution. But after that, the system slowly approaches the optimal configuration\nas it cools down. Hereby the approach to the ground state gets slower and slower.\n\n\n\n## References\n\n[1]: M.P. Allen, D.J. Tildesley,\n_\"Computer Simulation of Liquids\"_,\n(Oxford Scientific Publications, 1987)\n\n[2]: H.C. Andersen, \n_\"Rattle: A 'Velocity' Version of the Shake Algorithm for Molecular Dynamics Calculations\"_,\nJournal of Computational Physics **52**, (1983) 24\n\n[3]: See for example the appendix A of J.-P. Vest, G. Tarjus, P. Viot,\n_\"Dynamics of a monodisperse Lennard-Jones system on a sphere\"_,\narXiv:1401.7168v1 [cond-mat.stat-mech]\n", 
  "id": 33404860
}
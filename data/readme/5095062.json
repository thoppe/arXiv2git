{
  "README": "\nOctober 2015\n\n-------------------\nGENERAL INFORMATION\n-------------------\n\nIMPORTANT: please see the guidelines on preprocessing, incremental solving and\nAPI usage below.\n\nThis is version 5.0 of the search-based QBF solver DepQBF. Version 5.0\nincludes blocked clause elimination (QBCE) as a pre- and inprocessing\ntechnique and as a novel dynamic approach (enabled by default) where QBCE is\ninterleaved with the search process. The QBCE variants are currently available\nonly in non-incremental mode. The novel dynamic QBCE approach is described in\nthe following paper (proceedings of LPAR 2015):\n\nF. Lonsing, F. Bacchus, A. Biere, U. Egly, and M. Seidl: \"Enhancing\nSearch-Based QBF Solving by Dynamic Blocked Clause Elimination\". In\nProceedings of LPAR 2015, LNCS, Springer, 2015.\n\nDepQBF provides an API for incremental solving based on clause groups. A\nclause group is a set of clauses which is incrementally added to and removed\nfrom a formula. A description of the API can be found in the following tool\npaper (proceedings of SAT 2015):\n\nF. Lonsing and U. Egly: \"Incrementally Computing Minimal Unsatisfiable Cores\nof QBFs via a Clause Group Solver API\". In Proceedings of SAT 2015, volume\n9340 of LNCS, Springer, 2015. Preprint: http://arxiv.org/abs/1502.02484\n\nThis release also includes DepQBF4J, a Java interface to DepQBF which\nallows to call DepQBF as a library from Java programs. Please see the README\nfile in the subdirectory './DepQBF4J-0.2' for further information and usage\nexamples. DepQBF4J is based on the Java Native Interface (JNI) and was\nimplemented by Martin Kronegger and Andreas Pfandler.\n\nPLEASE SEE the header file 'qdpll.h', the examples in the subdirectory\n'examples', and the command line documentation (call './depqbf -h') for\nfurther information on using DepQBF and its library.\n\nThe example './examples/basic-api-example2.c' demonstrates the basic use of\nthe API and, in particular, the 'qdpll_gc' function. The clause group API is\nillustrated by './examples/basic-clause-groups-api-example.c'\n\nMany thanks to Robert Koenighofer, Adria Gascon, Thomas Krennwallner, Martin\nKronegger, Andreas Pfandler, and Simon Cruanes for valuable feedback.\n\n--------\nFEATURES\n--------\n\nGeneral features of DepQBF:\n\n- Since version 5.0: pre- and inprocessing by blocked clause elimination\n  (QBCE) and dynamic QBCE (enabled by default). See also './depqbf -h' for\n  configuration options. The QBCE variants are currently available only in\n  non-incremental mode.\n\n- The solver can be used as a library. The API is declared in file 'qdpll.h'\n  and the examples in the subdirectory 'examples' demonstrate its basic use.\n\n- Incremental solving: Incremental solving can be beneficial in applications\n  where a sequence of closely related formulae must be solved. This way, the\n  solver does not have to solve each formula from scratch but tries to reuse\n  information learned from previously solved formulae. DepQBF supports\n  incremental solving by a push/pop API and a clause group API. The push/pop\n  API allows to add and remove sets of clauses in a stack-based way. The\n  clause group API is more general and supports addition and deletion of\n  arbitrary sets of clauses.\n\n- Extraction of unsatisfiable cores: for unsatisfiable formulas, an\n  unsatisfiable core (i.e. subset of clauses) can be extracted via the clause\n  group API in a convenient way.\n\n- Solving under assumptions: assumptions are fixed variable assignments from\n  the leftmost quantifier block of a QBF. Assumptions can be added through the\n  solver API. In forthcoming calls, the solver tries to solve the formula\n  under the assignments given by the added assumptions.\n\n- Long-distance resolution for clause and cube learning: traditional\n  Q-resolution explicitly rules out the generation of tautological\n  resolvents. In contrast to that, long-distance resolution admits certain\n  tautological resolvents. It was first implemented in the QBF solver\n  'quaffle' and is now also available in DepQBF.\n\n- Advanced clause and cube learning based on QBF Pseudo Unit Propagation as\n  presented in the following paper: \"Florian Lonsing, Uwe Egly, Allen Van\n  Gelder: Efficient Clause Learning for Quantified Boolean Formulas via QBF\n  Pseudo Unit Propagation. In Proc. SAT 2013.\"\n\n  NOTE: by default, this version of DepQBF applies a lazy variant of\n  QPUP-based QCDCL where no resolution steps are carried out. The traditional\n  approach to QCDCL which was implemented in earlier versions of DepQBF is\n  still available by command line option '--traditional-qcdcl'. Please see\n  also the command line documentation by calling './depqbf -h'.\n\n- Generation of QDIMACS output (partial certificate): if the outermost\n  (i.e. leftmost) quantifier block of a satisfiable QBF is existentially\n  quantified, then DepQBF can print an assignment to the variables of this\n  block (and dually for unsatisfiable QBFs and universal variables from the\n  outermost block, if that block is universally quantified). To enable QDIMACS\n  output generation, run DepQBF with parameter '--qdo'. Note that the\n  assignment printed by DepQBF can be partial, i.e. not all variables are\n  necessarily assigned. In this case, the variables for which no value was\n  printed can be assigned arbitrarily.\n\n- Trace generation (contributed by Aina Niemetz): DepQBF can produce traces in\n  QRP format (ASCII and binary version of the QRP format are supported; see\n  also the command line documentation). If called with the '--trace' option,\n  the solver prints *every* resolution step during clause and cube learning to\n  <stdout>. The output format is QRP (\"Q-Resolution Proof\"). For example, the\n  call './depqbf --trace input-formula.qdimacs > trace.qrp' dumps the trace\n  for the QBF 'input-formula.qdimacs' to the file 'trace.qrp'. The generated\n  trace file can be used to extract a certificate of (un)satisfiability of the\n  given formula using additional tools. See also the website\n  'http://fmv.jku.at/qbfcert/' and the related tool paper published at SAT'12.\n\n  NOTE: tracing is currently not supported in incremental solving and must be\n  combined with the trivial dependency scheme (i.e. the linear quantifier\n  prefix ordering) by option '--dep-man=simple'. Further, to enable tracing\n  for QPUP-based QCDCL, '--no-lazy-qpup' must be specified.\n\nDepQBF consists of a dependency manager (file 'qdpll_dep_man_qdag.c') and a\ncore QDPLL solver (file 'qdpll.c'). During a run the solver queries the\ndependency manager to find out if there is a dependency between two variables,\nsay 'x' and 'y'. Given the original quantifier prefix of a QBF, there is such\ndependency if 'x' is quantified to the left of 'y' and 'x' and 'y' are\nquantified differently. In contrast to that simple approach, DepQBF (in\ngeneral) is able to extract more sophisticated dependency information from the\ngiven QBF. It computes the so-called 'standard dependency scheme' which is\nrepresented as a compact graph by the dependency manager.\n\nIf you are interested only in the core solver based on QDPLL then it is\nprobably best not to look at the code of the dependency manager in file\n'qdpll_dep_man_qdag.c' at all but only consider file 'qdpll.c'.\n\n-------\nLICENSE\n-------\n\nDepQBF is free software released under GPLv3:\n\nhttps://www.gnu.org/copyleft/gpl.html\n\nSee also the file COPYING.\n\n------------\nINSTALLATION\n------------\n\nThe latest release is available from http://lonsing.github.io/depqbf/\n\nUnpack the sources into a directory and call 'make'. This produces optimized\ncode without assertions (default).\n\nIf you want to use the solver as a library in your own applications, then link\nagainst 'libqdpll.a'.\n\nNote: set the flag 'FULL_ASSERT' in file 'qdpll_config.h' from 0 to 1 to\nswitch on *expensive* assertions (recommended only for debugging). The solver\nwill run *substantially* slower in this case. As usual, using the compiler\nflag 'DNDEBUG' removes all assertions from the code, regardless from the value\nof 'FULL_ASSERT'.\n\n-----------------------\nCONFIGURATION AND USAGE\n-----------------------\n\nCall './depqbf -h' to display usage information. Further, undocumented command\nline parameters can be found in function 'qdpll_configure(...)' in file\n'qdpll.c'. These parameters are mostly experimental.\n\nThe solver returns exit code 10 if the given instance was found satisfiable\nand exit code 20 if the instance was found unsatisfiable. Any other exit code\nindicates that the instance was not solved.\n\nParameter '-v' enables basic verbose mode where the solver prints information\non restarts and backtracks to <stderr>. More occurrences of '-v' result in\nheavy verbose mode where information on individual assignments is\nprinted. This can slow down the solver considerably and should be used for\ndebugging only.\n\nTrace generation can be enabled by parameter '--trace'. Note that printing the\ntracing information causes I/O overhead and might slow down the\nsolver. Writing traces in binary QRP format (enabled by parameter\n'--trace=bqrp') usually produces smaller traces, as far as byte size is\nconcerned.\n\nCalling DepQBF without command line parameters results in default behaviour\nwhich was tuned on instances from QBFLIB. For performance comparisons with\nother solvers it is recommended not to pass any command line parameters to\nDepQBF.\n\nBy default, statistical output is disabled. To enable statistics, set the flag\n'COMPUTE_STATS' in file 'qdpll_config.h' from 0 to 1. Similarly, time\nstatistics can be enabled by setting flag 'COMPUTE_STATS'.\n\n-------------------------------\nIMPORTANT NOTE ON PREPROCESSING\n-------------------------------\n\nVersion 5.0 includes blocked clause elimination (QBCE) as a pre- and inprocessing\ntechnique and as a novel dynamic approach (enabled by default) where QBCE is\ninterleaved with the search process. The QBCE variants are currently available\nonly in non-incremental mode.\n\nDepending on your application, preprocessors such as Bloqqer [1] and/or QxBF [2], for\nexample, may improve the performance of DepQBF further.\n\nHOWEVER: depending on the given instance, preprocessing by Bloqqer may be\nharmful to the performance of DepQBF version 5.0 in its default configuration\n(using dynamic QBCE).\n\n[1] http://fmv.jku.at/bloqqer/ \n\n[2] http://fmv.jku.at/qxbf/\n\n----------------------------------------------------\nIMPORTANT NOTES ON INCREMENTAL SOLVING AND API USAGE\n----------------------------------------------------\n\nPlease see the header file 'qdpll.h' for some documentation of the API\nfunctions.\n\nWhen using the API of the solver (versions 3.0 or later), it is HIGHLY\nRECOMMENDED to first add all the variables to the quantifier prefix and then\nall the clauses of the formula rather than adding variables and clauses in\ninterleaved fashion. In the latter case, runtime overhead will occur for large\nformulas. Many thanks to Mathias Preiner for pointing out this problem.\n\nIn applications which involve a very large number of incremental calls, the\noverhead of maintaining the internal data structures in this release of DepQBF\nmight become non-negligible. In this case, please contact Florian Lonsing;\nyour feedback is highly appreciated.\n\nIncremental solving must be enabled by calling the API function\n'qdpll_configure' with the parameters '--dep-man=simple' and\n'--incremental-use', respectively. Please see also the example programs in the\nsubdirectory 'examples'.\n\nThe push/pop API allows to add and remove clauses in a stack-based\nway. Therefore, clauses which are shared between many formulas to be solved\nshould be pushed onto the stack first. Clauses which have to be removed soon\nshould be added last so that they can be popped from the stack easily.\n\nIn general, it is beneficial for the performance of the solver to avoid\nneedless push operations. For example, if you know that certain clauses will\nnever be removed from the formula then it is not necessary to call\n'qdpll_push' before adding these clauses.\n\nThe clause group API generalizes the push/pop API in that it allows sets of\nclauses to be added and removed arbitrarily. It is recommended to use the\npush/pop API instead of the clause group API for applications which naturally\ncan be encoded by push and pop operations, that is, where the formulas to be\nsolved incrementally are modified in a rather uniform way.\n\nIf assumptions are passed to the solver using 'qdpll_assume' AND clauses are\nadded later to the formula, then the API function 'qdpll_configure' must be\ncalled with the parameters '--dep-man=simple' and '--incremental-use' after\nthe solver object has been created by 'qdpll_create'. Otherwise, if no clauses\nare added, then the aforementioned calls of the API function 'qdpll_configure'\ncan be omitted.\n\n-------\nCONTACT\n-------\n\nFor comments, questions, bug reports etc. related to DepQBF, please do not\nhesitate to contact Florian Lonsing:\n\nhttp://www.kr.tuwien.ac.at/staff/lonsing/ \n\nhttp://lonsing.github.io/depqbf/\n", 
  "read_at": 1462551202, 
  "description": "DepQBF, a solver for quantified boolean formulae (QBF).", 
  "id": 5095062
}
{
  "read_at": 1462543133, 
  "description": "A simple C library for compressing lists of integers using binary packing", 
  "README.md": "The SIMDComp library\n====================\n[![Build Status](https://travis-ci.org/lemire/simdcomp.png)](https://travis-ci.org/lemire/simdcomp)\n\nA simple C library for compressing lists of integers using binary packing and SIMD instructions.\nThe assumption is either that you have a list of 32-bit integers where most of them are small, or a list of 32-bit integers where differences between successive integers are small. No software is able to reliably compress an array of 32-bit random numbers.\n\nThis library can decode at least 4 billions of compressed integers per second on most\ndesktop or laptop processors. That is, it can decompress data at a rate of 15 GB/s.\nThis is significantly faster than generic codecs like gzip, LZO, Snappy or LZ4.\n\nOn a Skylake Intel processor, it can decode integers at a rate 0.3 cycles per integer,\nwhich can easily translate into more than 8 decoded billions integers per second.\n\nContributors: Daniel Lemire, Nathan Kurz, Christoph Rupp, Anatol Belski, Nick White and others\n\nWhat is it for?\n-------------\n\nThis is a low-level library for fast integer compression. By design it does not define a compressed\nformat. It is up to the (sophisticated) user to create a compressed format.\n\nRequirements\n-------------\n\n- Your processor should support SSE4.1 (It is supported by most Intel and AMD processors released since 2008.)\n- It is possible to build the core part of the code if your processor support SSE2 (Pentium4 or better)\n- C99 compliant compiler (GCC is assumed)\n- A Linux-like distribution is assumed by the makefile\n\nFor a plain C version that does not use SIMD instructions, see https://github.com/lemire/LittleIntPacker\n\nUsage\n-------\n\nCompression works over blocks of 128 integers.\n\nFor a complete working example, see example.c (you can build it and\nrun it with \"make example; ./example\").\n\n\n\n1) Lists of integers in random order.\n\n```C            \nconst uint32_t b = maxbits(datain);// computes bit width\nsimdpackwithoutmask(datain, buffer, b);//compressed to buffer, compressing 128 32-bit integers down to b*32 bytes\nsimdunpack(buffer, backbuffer, b);//uncompressed to backbuffer\n```\n\nWhile 128 32-bit integers are read, only b 128-bit words are written. Thus, the compression ratio is 32/b.\n\n2) Sorted lists of integers.\n\nWe used differential coding: we store the difference between successive integers. For this purpose, we need an initial value (called offset).\n\n```C            \nuint32_t offset = 0;\nuint32_t b1 = simdmaxbitsd1(offset,datain); // bit width\nsimdpackwithoutmaskd1(offset, datain, buffer, b1);//compressing 128 32-bit integers down to b1*32 bytes\nsimdunpackd1(offset, buffer, backbuffer, b1);//uncompressed\n```\n\nGeneral example for arrays of arbitrary length:\n```C\nint compress_decompress_demo() {\n  size_t k, N = 9999;\n  __m128i * endofbuf;\n  uint32_t * datain = malloc(N * sizeof(uint32_t));\n  uint8_t * buffer;\n  uint32_t * backbuffer = malloc(N * sizeof(uint32_t));\n  uint32_t b;\n\n  for (k = 0; k < N; ++k){        /* start with k=0, not k=1! */\n    datain[k] = k;\n  }\n\n  b = maxbits_length(datain, N);\n  buffer = malloc(simdpack_compressedbytes(N,b)); // allocate just enough memory\n  endofbuf = simdpack_length(datain, N, (__m128i *)buffer, b);\n  /* compressed data is stored between buffer and endofbuf using (endofbuf-buffer)*sizeof(__m128i) bytes */\n  /* would be safe to do : buffer = realloc(buffer,(endofbuf-(__m128i *)buffer)*sizeof(__m128i)); */\n  simdunpack_length((const __m128i *)buffer, N, backbuffer, b);\n\n  for (k = 0; k < N; ++k){\n    if(datain[k] != backbuffer[k]) {\n      printf(\"bug\\n\");\n      return -1;\n    }\n  }\n  return 0;\n}\n```\n\n\n3) Frame-of-Reference \n\nWe also have frame-of-reference (FOR) functions (see simdfor.h header). They work like the bit packing\nroutines, but do not use differential coding so they allow faster search in some cases, at the expense\nof compression.\n\nSetup\n---------\n\n\nmake\nmake test\n\nand if you are daring:\n\nmake install\n\nGo\n--------\n\nIf you are a go user, there is a \"go\" folder where you will find a simple demo.\n\nOther libraries\n----------------\n\n* Fast decoder for VByte-compressed integers https://github.com/lemire/MaskedVByte\n* Fast integer compression in C using StreamVByte https://github.com/lemire/streamvbyte\n* FastPFOR is a C++ research library well suited to compress unsorted arrays: https://github.com/lemire/FastPFor\n* SIMDCompressionAndIntersection is a C++ research library well suited for sorted arrays (differential coding)\nand computing intersections: https://github.com/lemire/SIMDCompressionAndIntersection\n* TurboPFor is a C library that offers lots of interesting optimizations. Well worth checking! (GPL license) https://github.com/powturbo/TurboPFor\n* Oroch is a C++ library that offers a usable API (MIT license) https://github.com/ademakov/Oroch\n\n\nReferences\n------------\n\n* Daniel Lemire, Leonid Boytsov, Nathan Kurz, SIMD Compression and the Intersection of Sorted Integers, Software Practice & Experience 46 (6) 2016. http://arxiv.org/abs/1401.6399\n* Daniel Lemire and Leonid Boytsov, Decoding billions of integers per second through vectorization, Software Practice & Experience 45 (1), 2015.  http://arxiv.org/abs/1209.2137 http://onlinelibrary.wiley.com/doi/10.1002/spe.2203/abstract\n* Jeff Plaisance, Nathan Kurz, Daniel Lemire, Vectorized VByte Decoding, International Symposium on Web Algorithms 2015, 2015. http://arxiv.org/abs/1503.07387\n* Wayne Xin Zhao, Xudong Zhang, Daniel Lemire, Dongdong Shan, Jian-Yun Nie, Hongfei Yan, Ji-Rong Wen, A General SIMD-based Approach to Accelerating Compression Algorithms, ACM Transactions on Information Systems 33 (3), 2015. http://arxiv.org/abs/1502.01916\n* T. D. Wu, Bitpacking techniques for indexing genomes: I. Hash tables, Algorithms for Molecular Biology 11 (5), 2016. http://almob.biomedcentral.com/articles/10.1186/s13015-016-0069-5\n", 
  "id": 16556373
}
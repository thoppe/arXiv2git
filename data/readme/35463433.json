{
  "read_at": 1462559001, 
  "description": "", 
  "README.md": "# README #\r\n\r\nSLAMBench Release Candidate 1.1\r\n\r\n  Copyright (c) 2014 University of Edinburgh, Imperial College, University of Manchester.\r\n\r\n  Developed in the PAMELA project, EPSRC Programme Grant EP/K008730/1\r\n\r\n## What is it for? ##\r\n\r\n* A SLAM performance benchmark that combines a framework for quantifying quality-of-result with instrumentation of execution time and energy consumption. \r\n* It contains a KinectFusion (http://research.microsoft.com/pubs/155378/ismar2011.pdf) implementation in C++, OpenMP, OpenCL and CUDA (inspired by https://github.com/GerhardR).\r\n* It offers a platform for a broad spectrum of future research in jointly exploring the design space of algorithmic and implementation-level optimisations. \r\n* Target desktop, laptop, mobile and embedded platforms. Tested on Ubuntu, OS X and Android (on Android only the benchmark application has been ported, see later). \r\n\r\nIf you use SLAMBench in scientific publications, we would appreciate citations to the following paper (http://arxiv.org/abs/1410.2167):\r\n\r\nL. Nardi, B. Bodin, M. Z. Zia, J. Mawer, A. Nisbet, P. H. J. Kelly, A. J. Davison, M. Lujan, M. F. P. O'Boyle, G. Riley, N. Topham, and S. Furber. Introducing SLAMBench, a performance and accuracy benchmarking methodology for SLAM. In IEEE Intl. Conf. on Robotics and Automation (ICRA), May 2015. arXiv:1410.2167.\r\n\r\nBibtex entry:\r\n\r\n```\r\n#!latex\r\n\r\n@inproceedings{Nardi2015,\r\n    author={Nardi, Luigi and Bodin, Bruno and Zia, M. Zeeshan and Mawer, John and Nisbet, Andy and Kelly, Paul H. J. and Davison, Andrew J. and Luj\\'an, Mikel and O'Boyle, Michael F. P. and Riley, Graham and Topham, Nigel and Furber, Steve},\r\n    title = \"{Introducing SLAMBench, a performance and accuracy benchmarking methodology for SLAM}\",\r\n    booktitle = \"{IEEE Intl. Conf. on Robotics and Automation (ICRA)}\",\r\n    year = {2015},\r\n    month = {May},\r\n    NOTE = {arXiv:1410.2167}\r\n    } \r\n\r\n```\r\n\r\n## How do I get set up on Ubuntu? ##\r\nIf you want to set up for OS X go to the relevant section. \r\n\r\n### Dependencies ###\r\n\r\n#### Required ####\r\n\r\n* TooN: maths library.\r\n* CMake 2.8+ : building tool.\r\n\r\n##### Install TooN and CMake#####\r\n\r\n```\r\n#!shell\r\ngit clone git://github.com/edrosten/TooN.git\r\ncd TooN\r\n./configure\r\nsudo make install\r\nsudo apt-get install cmake\r\n\r\n```\r\n+(with Ubuntu, you might need to install the  build-essential package using ```sudo apt-get update && sudo apt-get install build-essential```)\r\n \r\n\r\n#### Optional ####\r\n\r\n* OpenMP : for the OpenMP version\r\n* CUDA : for the CUDA version\r\n* OpenCL : for the OpenCL version (OpenCL 1.1 or greater)\r\n\r\n* OpenGL / GLUT : used by the graphical interface\r\n* OpenNI : for the live mode, and for `oni2raw` tool (which convert an OpenNI file to the SLAMBench internal format)\r\n* Freenect Drivers : In order to use the live mode.\r\n* PkgConfig / Qt5 (using OpenGL) : used by the Qt graphical interface (not fully required to get a graphical interface)\r\n* Python (numpy) : use by benchmarking scripts (`mean`, `max`, `min` functions)\r\n\r\n##### Installation of Qt5 with an ARM board (ie. Arndale, ODROID,...) #####\r\n\r\nOn ARM board, the default release of Qt5 was compile using OpenEGL, to use the Qt interface, you will have to compile Qt :\r\n\r\n```\r\n#!\r\ncd ~\r\nwget http://download.qt-project.org/official_releases/qt/5.2/5.2.1/single/qt-everywhere-opensource-src-5.2.1.tar.gz\r\ntar xzf qt-everywhere-opensource-src-5.2.1.tar.gz\r\ncd ~/qt-everywhere-opensource-src-5.2.1\r\n./configure -prefix ~/.local/qt/ -no-compile-examples  -confirm-license  -release   -nomake tests   -nomake examples\r\nmake\r\nmake install\r\n```\r\n\r\n### Compilation of SLAMBench ###\r\n\r\nThen simply build doing: \r\n\r\n```\r\n#!\r\nmake\r\n```\r\n\r\nTo use qt, if you compile the source as explained above, you should need to specify the Qt install dir :\r\n```\r\n#!\r\nCMAKE_PREFIX_PATH=~/.local/qt/ make\r\n```\r\n\r\n### Running SLAMBench ###\r\n\r\nThe compilation builds 3 application modes which act like wrappers (the kernels are the same for all applications): \r\n\r\n1. benchmark: terminal user interface mode for benchmarking purposes\r\n2. main: GLUT GUI visualisation mode\r\n3. qmain: Qt GUI visualisation mode\r\n\r\nEach application mode is also declined in 4 different builds/implementations:\r\n\r\n* C++ (*./build/kfusion/kfusion-main-cpp*) \r\n* OpenMP (*./build/kfusion/kfusion-main-openmp*)\r\n* OpenCL (*./build/kfusion/kfusion-main-cpp*) \r\n* CUDA (*./build/kfusion/kfusion-main-cuda*) \r\n\r\nThe Makefile will automatically build the executable with satisfied dependencies, e.g. the OpenCL application version will be built only if the OpenCL tool kit is available on the system and so on for CUDA, OpenMP and Qt.\r\n\r\nAll application modes and implementations share the same set of arguments:\r\n\r\n```\r\n#!plain\r\n-c  (--compute-size-ratio)       : default is 1   (same size)      \r\n-d  (--dump-volume) <filename>   : Output volume file   \r\n-f  (--fps)                      : default is 0\r\n-i  (--input-file) <filename>    : Input camera file               \r\n-k  (--camera)                   : default is defined by input     \r\n-l  (--icp-threshold)        : default is 1e-05\r\n-o  (--log-file) <filename>      : default is stdout               \r\n-m  (--mu)                       : default is 0.1               \r\n-p  (--init-pose)                : default is 0.5,0.5,0     \r\n-q (--no-gui)                    : disable any gui used by the executable\r\n-r  (--integration-rate)         : default is 1     \r\n-s  (--volume-size)              : default is 2,2,2      \r\n-t  (--tracking-rate)            : default is 1     \r\n-v  (--volume-resolution)        : default is 256,256,256    \r\n-y  (--pyramid-levels)           : default is 10,5,4 \r\n-z  (--rendering-rate)   : default is 4\r\n```\r\n\r\nSLAMBench supports several input streams (how to use these inputs is described later): \r\n\r\n* ICL-NUIM dataset (http://www.doc.ic.ac.uk/~ahanda/VaFRIC/iclnuim.html)\r\n* RGB-D camera like Microsoft Kinect or other PrimeSense cameras using the OpenNI interface\r\n* OpenNI pre-recorded file\r\n* Raw format\r\n\r\n\r\n#### 1. benchmark mode ####\r\n\r\nUse this mode for benchmarking proposes. The output is: \r\n\r\n* frame          : ID number of the current frame\r\n* acquisition    : input data acquisition elapsed time (file reading)\r\n* preprocessing  : pre-processing elapsed time (includes kernels mm2meters bilateralFilter)\r\n* tracking       : tracking elapsed time (includes kernels halfSample, depth2vertex vertex2normal, track,  reduce and solve)\r\n* integration    : integration elapsed time (includes kernel integrate)\r\n* raycast          : raycast elapsed time (include kernel raycast)\r\n* rendering      : rendering elapsed time (includes kernels renderDepth renderTrack and renderVolume)\r\n* computation  : pre-processing + tracking + integration + raycast. This is the total elapsed time for processing a frame but not including the acquiring and the visualisation kernels\r\n* total  : computation + acquisition + rendering. This is the total elapsed time for processing one frame (including the acquiring and the visualisation kernels)\r\n* X,Y,Z  : estimation of the camera position (tracking result)\r\n* tracked : this boolean indicates if for the current frame we have not lost the tracking of the camera (1 = tracking, 0 = tracking lost)\r\n* integrated : this boolean indicates if the integration step occurs for the current frame (depending of the tracking result and of the integration rate)\r\n\r\n\r\n##### How to use the benchmark mode with the ICL-NUIM dataset #####\r\n\r\nSLAMBench provides an interface to the ICL-NUIM dataset. \r\nThis enables the accuracy evaluation on a SLAM implementation via the ICL-NUIM ground truth. \r\nICL-NUIM provides 4 trajectories, we pick trajectory 2 and show how to use the dataset (for the download of each trajectory we recommend 2 GB of space available on the system):\r\n\r\n```\r\n#!plain\r\nmkdir living_room_traj2_loop\r\ncd living_room_traj2_loop\r\nwget http://www.doc.ic.ac.uk/~ahanda/living_room_traj2_loop.tgz\r\ntar xzf living_room_traj2_loop.tgz\r\ncd ..\r\n```\r\n\r\nYou can use the ICL-NUIM dataset in its native format or in a RAW format (with the latter acquiring speed increases). \r\nRAW is the format to be used for benchmarking purposes, to generate the RAW file: \r\n\r\n```\r\n#!plain\r\n./build/kfusion/thirdparty/scene2raw living_room_traj2_loop living_room_traj2_loop.raw\r\n```\r\n\r\nRun SLAMBench:\r\n\r\n```\r\n#!plain\r\n./build/kfusion/kfusion-benchmark-cuda -i living_room_traj2_loop.raw  -s 4.8 -p 0.34,0.5,0.24 -z 4 -c 2 -r 1 -k 481.2,480,320,240  > benchmark.log\r\n```\r\nYou can replace *cuda* by *openmp*, *opencl* or *cpp*.\r\n\r\nIn order to check the accuracy of your tracking compared to the ground truth trajectory, first download the ground truth trajectory file: \r\n```\r\n#!plain\r\nwget http://www.doc.ic.ac.uk/~ahanda/VaFRIC/livingRoom2.gt.freiburg\r\n```\r\nAnd then use the following tool:\r\n```\r\n#!plain\r\n./kfusion/thirdparty/checkPos.py benchmark.log livingRoom2.gt.freiburg \r\nGet slambench data. \r\nslambench result        : 882 positions.\r\nNUIM  result        : 880 positions.\r\nWorking position is : 880\r\nRuntimes are in seconds and the absolute trajectory error (ATE) is in meters.\r\nThe ATE measure accuracy, check this number to see how precise your computation is.\r\nAcceptable values are in the range of few centimeters.\r\n\r\n            tracking \tMin : 0.005833 \tMax : 0.046185 \tMean : 0.020473 \tTotal : 18.05721755\r\n         integration \tMin : 0.003629 \tMax : 0.041839 \tMean : 0.021960 \tTotal : 19.36882799\r\n           rendering \tMin : 0.018242 \tMax : 0.022144 \tMean : 0.018486 \tTotal : 16.30500085\r\n       preprocessing \tMin : 0.000633 \tMax : 0.002064 \tMean : 0.000719 \tTotal : 0.63432674\r\n         computation \tMin : 0.010156 \tMax : 0.075946 \tMean : 0.043152 \tTotal : 38.06037227\r\n           total     \tMin : 0.028520 \tMax : 0.094302 \tMean : 0.061724 \tTotal : 54.44080794\r\n                 ATE \tMin : 0.000000 \tMax : 0.044235 \tMean : 0.018392 \tTotal : 16.18503741\r\n         acquisition \tMin : 0.000069 \tMax : 0.000404 \tMean : 0.000086 \tTotal : 0.07543481\r\n```\r\n\r\n#### 2. main mode ####\r\n\r\nThis is a GUI mode which internally uses GLUT for the visualisation step. \r\nWe do not suggest to use this mode for benchmarking purposes because the visualisation step can interfere with the computation elapsed time (see http://arxiv.org/abs/1410.2167 for more information).  \r\n\r\nAn example of use of the main application is: \r\n\r\n```\r\n#!plain\r\n./build/kfusion/kfusion-main-cpp -i ~/Downloads/living_room_traj2_loop/\r\n\r\n```\r\n\r\n#### 3. mainQt mode ####\r\n\r\nThis is a GUI mode which internally uses Qt for the visualisation step. \r\nWe do not suggest to use this mode for benchmarking purposes because the visualisation step can interfere with the computation elapsed time (see http://arxiv.org/abs/1410.2167 for more information).  \r\n\r\nAn example of use of the mainQt application is: \r\n```\r\n#!plain\r\n./build/kfusion/kfusion-qt-cpp -i ~/Downloads/living_room_traj2_loop/\r\n\r\n```\r\n## Kernel timings ##\r\n\r\n### CPP ###\r\n```\r\n#!plain\r\nKERNEL_TIMINGS=1 ./build/kfusion/kfusion-benchmark-cpp -s 4.8 -p 0.34,0.5,0.24 -z 4 -c 2 -r 1 -k 481.2,480,320,240 -i  living_room_traj2_loop.raw -o  benchmark.2.cpp.log 2> kernels.2.cpp.log\r\n```\r\n\r\n### OpernMP ###\r\n```\r\n#!plain\r\nKERNEL_TIMINGS=1 ./build/kfusion/kfusion-benchmark-openmp -s 4.8 -p 0.34,0.5,0.24 -z 4 -c 2 -r 1 -k 481.2,480,320,240 -i  living_room_traj2_loop.raw -o  benchmark.2.openmp.log 2> kernels.2.openmp.log\r\n```\r\n\r\n### OpenCL ###\r\n\r\nIt is possible to profile OpenCL kernels using an OpenCL wrapper from the thirdparty folder : \r\n```\r\n#!plain\r\nLD_PRELOAD=./build/kfusion/thirdparty/liboclwrapper.so ./build/kfusion/kfusion-benchmark-opencl -s 4.8 -p 0.34,0.5,0.24 -z 4 -c 2 -r 1 -k 481.2,480,320,240 -i  living_room_traj2_loop.raw -o benchmark.2.opencl.log 2>  kernels.2.opencl.log\r\n```\r\n\r\n### CUDA ###\r\n\r\nThe CUDA profiling takes advantage of the NVIDIA nvprof profiling tool. \r\n```\r\n#!plain\r\nnvprof --print-gpu-trace ./build/kfusion/kfusion-benchmark-cuda -s 4.8 -p 0.34,0.5,0.24 -z 4 -c 2 -r 1 -k 481.2,480,320,240 -i  living_room_traj2_loop.raw -o  benchmark.2.cuda.log 2> tmpkernels.2.cuda.log || true\r\ncat  tmpkernels.2.cuda.log | kfusion/thirdparty/nvprof2log.py >   kernels.2.cuda.log\r\n```\r\n\r\n## Automatic timings ##\r\n\r\nWhen using the ICL-NUIM dataset, it is possible to generate the timings using only one command. \r\nIf the living room trajectory files (raw + trajectory ground truth) are not in the directory they will be automatically downloaded. \r\n \r\nIn the following command, we use trajectory 2 and we generate the timings for the OpenCL version only: \r\n```\r\nmake 2.opencl.log\r\n```\r\n\r\nIn order to use all the available languages and for all the available trajectories do the following: \r\n```\r\nmake 0.cpp.log 0.opencl.log 0.openmp.log 0.cuda.log\r\nmake 1.cpp.log 1.opencl.log 1.openmp.log 1.cuda.log\r\nmake 2.cpp.log 2.opencl.log 2.openmp.log 2.cuda.log\r\nmake 3.cpp.log 3.opencl.log 3.openmp.log 3.cuda.log\r\n```\r\n\r\n\r\n## Parameters for different dataset trajectories (Living Room) ##\r\n\r\nThese parameters are also present in the Makefile and can be used with the command above, see Automatic timings section. \r\n\r\nTrajectory 0 : offset = 0.34,0.5,0.24,  voxel grid size = 5.0m (max ATE = 0.1m,    mean ATE = 0.01m)\r\n\r\nTrajectory 1 : offset = 0.485,0.5,0.55, voxel grid size = 5.0m (max ATE = 0.06m,   mean ATE = 0.028m)\r\n\r\nTrajectory 2 : offset = 0.34,0.5,0.24,  voxel grid size = 4.8m (max ATE = 0.044m,  mean ATE = 0.02m)\r\n\r\nTrajectory 3 : offset = 0.2685,0.5,0.4, voxel grid size = 5.0m (max ATE = 0.292m,  mean ATE = 0.117m)\r\n\r\n\r\n## File organization ##\r\n\r\n\r\n```\r\n#!Plain\r\n\r\nSlamBench\r\n   +-- (build)      :  will content the compilation and test result.\r\n   +-- cmake        :  cmake module file \r\n   +-- kfusion      :  kfusion test case.\r\n       +-- include  : common files (including the tested kernel prototypes) \r\n       +-- src\r\n       |   +-- cpp      : C++/OpenMP implementation\r\n       |   +-- opencl   : OpenCL implementation\r\n       |   +-- cuda    : CUDA implementation\r\n       +-- thridparty    : Includes several tools use by Makefile and 3rd party headers.\r\n```\r\n \r\n\r\n###Power measurement ###\r\nCurrently  power measurement is only implemented on Hardkernel boards implementing power monitoring using on board sensors, ODROID-XUE and ODROID-XU3.  When executing on these platforms a file power.rpt is produced at the end of each run, this will contain a frame by frame analysis of mean power and time for each frame.  The power is separated between, the Cortex-A7, Cortex-A15, GPU and DRAM.\r\n\r\nRunning kfusion/thirdparty/processPowerRpt <power.rpt> will produce total energy used by each resource during  the processing of the sequence.  \r\n\r\nIn the Qt interface power is monitored and graphed on a frame by frame basis, the graphing will only be visible on a suitably equipped board.  The power monitor, and indeed all statistics logging, is on a per sequence basis i.e. if you open/restart a scene/file the  logging will restart.  The statistics for a run can be saved by selecting File->Save power from the main menu when the run has been completed, statistics are only recorded when frames are processing, pausing the sequence should not impact on the final statistics.\r\n\r\nIn the future we propose to add support for power estimation using on chip counters where available, this should be included in a future release.\r\n\r\n## Set up on OS X ##\r\n\r\n**Warning**: SLAMBench is widely tested and fully supported on Ubuntu. The OS X version may result instable. We reckon to use the Ubuntu version. \r\n\r\nInstall Homebrew:\r\n\r\n```\r\n#!bash\r\n\r\nruby -e \"$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)\"\r\n\r\n```\r\n\r\nInstall and change the default to gcc and g++ (only clang/LLVM available otherwise):\r\n\r\n```\r\n#!bash\r\nbrew tap homebrew/versions\r\nbrew install gcc48\r\nsudo mv /usr/bin/gcc /usr/bin/gccORIG\r\nsudo ln -s /usr/local/bin/gcc-4.8 /usr/bin/gcc\r\nsudo mv /usr/bin/g++ /usr/bin/g++ORIG\r\nsudo ln -s /usr/local/bin/g++-4.8 /usr/bin/g++\r\nsudo mv /usr/bin/c++ /usr/bin/c++ORIG\r\nsudo ln -s /usr/local/bin/g++-4.8 /usr/bin/c++\r\n\r\n```\r\n\r\nOpenCL is already installed out-of-the-box no need to install. \r\nInstall CUDA ( guide here: http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-mac-os-x/#axzz3L7QjZMEC)\r\n\r\nInstall Qt:\r\n\r\n```\r\n#!bash\r\nbrew install qt\r\n\r\n\r\n```\r\n\r\nAdd to your ~/.bashrc:\r\n\r\n\r\n```\r\n#!bash\r\n\r\nexport PATH=/usr/local/opt/qt5/bin/:$PATH\r\n\r\n```\r\n\r\nInstall OpenNI and dependencies (needs MacPorts already installed https://www.macports.org/install.php):\r\nDownload OpenNI [here](http://structure.io/openni) and try to run the Samples/Bin/SimpleViewer program to check if the camera is working.\r\n\r\n```\r\n#!bash\r\n\r\nsudo port install libtool\r\nsudo port install libusb + universal\r\n\r\ncd OpenNI\r\n./install.sh\r\n\r\n```\r\n\r\nIn SLAMBench, modify cmake/FindOpenNI.cmake adding to the lib path:\r\n\r\n/Users/lnardi/sw/OpenNI-MacOSX-x64-2.2/Samples/Bin\r\n\r\nAnd to the include path:\r\n\r\n/Users/lnardi/sw/OpenNI-MacOSX-x64-2.2/Include\r\n\r\nAdd to your ~/.bashrc:\r\n\r\n\r\n```\r\n#!bash\r\n\r\nexport DYLD_LIBRARY_PATH=/Users/lnardi/sw/OpenNI-MacOSX-x64-2.2/Samples/Bin:$DYLD_LIBRARY_PATH\r\n```\r\n\r\n\r\n\r\n##Known Issues ##\r\n* ** Failure to track using OpenCL on AMD **  -Some issues have been reported on AMD platforms, we will look into this\r\n* **Visualisation using QT**  - may be offset on some platforms - notably ARM\r\n* **Build issues using QT on ARM ** - Visualisation requires opengl but Qt on ARM is often built using GLES, including packages obtained from distribution repo.  Building from source with opengl set to desktop resolves this. \r\n* ** Frame rates on QT GUI appear optimistic** -  The rate shown in the status bar is by default the computation time to process the frame and render any output, it excludes the time take by the QT interface to display the rendered images and acquire frame\r\n* ** performance difference between CUDA/OpenCL** - This is a known issue that we are investigating. It's mainly cause by a difference of global work-group size between the both version and a major slowdown of CUDA in the rendering kernels is cause by the use of float3 instead of float4 which result by an alignment issue. this alignment issue doesn't appear in OpenCL as cl_float3 are the same as cl_float4.\r\n* ** CUDA nvprof slows down the performance on some platforms** - the nvprof instrumentation has a 2x slowdown on MAC OS for the high-level KFusion building blocks. So if we run using make 2.cuda.log we will not measure the maximum speed of the machine for the high-level building blocks. It is questionable then if we should keep measuring the CUDA high-level and low-level performance at the same time or in order to be more accurate it is better to run the two measurements in two separate runs. \r\n* ** OS X version has not been widely tested ** \r\n\r\n## Release history ##\r\n\r\nRelease candidat 1.1 (17 Mar 2015)  \r\n  * Bugfix : Move bilateralFilterKernel from preprocessing to tracking\r\n  * Bugfix : Wrong interpretation of ICP Threshold parameter.\r\n  * Esthetic : Uniformisation of HalfSampleRobustImage kernel\r\n  * Performance : Change float3 to float4 for the rendering kernels (No effect on OpenCL, but high performance improvement with CUDA)\r\n  * Performance : Add a dedicated buffer for the OpenCL rendering\r\n  * Feature : Add OSX support\r\n \r\nRelease candidat 1.0 (12 Nov 2014)\r\n  * First public release", 
  "id": 35463433
}
{
  "read_at": 1462511557, 
  "description": "Nervana\u2122 library for GPUs", 
  "README.md": "# NervanaGPU library\n\n## Deprecated\n\nNervanaGPU is now maintained as a backend inside of the [neon](https://github.com/NervanaSystems/neon) project. This repository remains for reference only and is no longer updated.\n\n## Introduction\n\n**nervanagpu** is a Python module for deep learning. It includes,\n\n- matrix-multiply (GEMM), convolution, and pooling kernels optimized using a custom [assembler](https://github.com/NervanaSystems/maxas),\n- element-wise and broadcast operations that automatically compound into efficient kernels,\n- a simple but powerful array class, leveraging and with code partially borrowed from pycuda<sup>[1](#refs)</sup>,\n- layer classes for building networks for benchmarking,\n- full assembler source to encourage contributions from the community.\n\n#### Design goals\n\n**nervanagpu** grew out of a tool Nervana uses for internal hardware efforts. It's been repackaged for use by the community. The goals for **nervanagpu** are to provide,\n\n- near **theoretical peak performance**,\n- numpy functionality for **ease-of-use**,\n- convolution kernel features and arguments identical to cuDNN<sup>[2](#refs)</sup>,\n- integration into [neon](https://github.com/NervanaSystems/neon), Nervana's full-featured deep learning library,\n- a tool for algorithmic explorations using alternative numerical formats,\n- a seemless transition path to Nervana hardware,\n- ease of integration into other deep learning frameworks.\n\nOnly NVIDIA Maxwell and future architectures are supported. Older architectures are not well-suited for assembler level optimizations used here.\n\n#### Numerical formats\n\nSupported numerical formats currently include,\n\n- **fp32**: standard 32-bit floating point,\n- **fp16**: 16-bit floating point memory format with underlying operations in 32 bits.\n- **int8** and **uint8**: in elementwise and as input to the first convolutional layer.\n\nwith more to come (eg. like [this](https://github.com/NervanaSystems/nervana-lib-gpu-performance-preview)).\n\n#### Extra features\n\nOur kernels have some additional useful features:\n\n- 3D convolutions and 4D pooling (including output feature map dim)\n- optional ReLu is builtin to GEMM and convolution operations,\n- stochastic rounding support for **fp16**<sup>[3](#refs)</sup>,\n- instrumented to return statistics useful for avoiding numerical issues (coming soon),\n- support for matrix sizes common in deep learning, significantly out performing cuBLAS\n\nSmall optimizations like these can result in significant speed and performance improvements.\n\n## Prerequisites\n\nPyCUDA release 2015.1 is necessary in order to run **nervanagpu**.\n\n## Usage\n\n**nervanagpu** includes a factory class `NervanaGPU` and a numpy-like array class `GPUTensor`. Memory layout for tensors and gemm ops is **row-ordered**. Below are examples on how they are used.\n\n### Matrix multiplication example\n\nHere is full example of doing a basic GEMM operation using 16-bit float:\n\n```python\nimport numpy as np\nimport pycuda.autoinit\nfrom nervanagpu import NervanaGPU\n\n# initialize factory class\nng = NervanaGPU(stochastic_round=False)\n\nm, n, k  = 10, 20, 10\ndtype = np.float16\n\n# create matrices on host\ncpuA = np.random.randn(k,m)\ncpuB = np.random.randn(k,n)\n\n# transfer to device\ndevA = ng.array(cpuA, dtype=dtype)\ndevB = ng.array(cpuB, dtype=dtype)\ndevC = ng.empty((m,n), dtype=dtype)\n\n# do GEMM operation\nng.dot(devA.T, devB, devC, relu=False)\n\n# get from device\ncpuC = devC.get()\n```\n\n### Element-wise operations\n\n**nervanagpu** compiles tensor arithmetic expressions into efficient CUDA kernels which are lazily evaluated upon assignment. For example, computing variance along an axis consists of a set of element-wise, reduction and broadcast operations that compiles to a single kernel (this code is also provided by the ng.var operator):\n\n```python\n# import and initialize NervanaGPU, transfer matrix from cpu to dev as above\n\ndevC[:] = ng.mean(ng.square(devA - ng.mean(devA, axis=1)), axis=1)\n\n```\n\nBatch normalization can be done by computing mean and variance across the batch (n) dimension and automatically taking advantage of broadcasting to subtract and divide the original data.\n\n```python\n# import and initialize NervanaGPU as above\n\neps  = .001 # for avoiding division by zero\nA    = ng.empty((128, 32), dtype=np.float16)\nA[:] = ng.rand() # generate uniform random on device between 0 and 1\n\n# Normalize batch data by batch mean and variance,\nA[:] = (A - ng.mean(A, axis=1)) / ng.sqrt(ng.var(A, axis=1) + eps)\n\n```\nThe last expression above is automatically collapsed into a single gpu kernel. There are two mean(A,axis=1) operations embedded in that expression (one in the numerator and one inside the variance operation).  One of them is automatically optimized away, leading to the most efficient kernel possible.\n\n## Building\n\n**nervanagpu** comes with full assembler code for kernels. To build the kernels, install [**maxas**](https://github.com/NervanaSystems/maxas), Nervana's assembler for NVIDIA Maxwell. The module can then be built by running:\n\n    make kernels      # build the kernels\n    make python       # build python bindings\n    make test         # run nosetests\n    make doc          # build sphinx docs\n\nA simple `make` will perform the first two steps.\n\nDocumentation and tests are currently sparse. Please contribute.\n\n## Performance\n\n**nervanagpu** comes with a set of benchmark scripts under `nervanagpu/benchmarks`. Also included are scripts to validate kernel results against cuBLAS and cuDNN.\n\nHere is a sample run of `benchmarks/convnet-benchmarks.py` using the networks listed on Soumith Chintala's [benchmarking page](https://github.com/soumith/convnet-benchmarks).  Run on a single TitanX with default clocks and power limit:\n\n    ---------------------------------------------\n    Alexnet (dtype=float16, N=128) Results:\n    ---------------------------------------------\n    Avg(10) fprop:   28.341 msecs 6290.357 gflops\n    Avg(10) bprop:   60.768 msecs 5867.390 gflops\n    Avg(10) total:   89.109 msecs 6001.914 gflops\n    ---------------------------------------------\n    Alexnet (dtype=float32, N=128) Results:\n    ---------------------------------------------\n    Avg(10) fprop:   29.332 msecs 6077.931 gflops\n    Avg(10) bprop:   66.216 msecs 5384.625 gflops\n    Avg(10) total:   95.548 msecs 5597.458 gflops\n\n    ---------------------------------------------\n    Overfeat (dtype=float16, N=128) Results:\n    ---------------------------------------------\n    Avg(10) fprop:  107.401 msecs 6667.444 gflops\n    Avg(10) bprop:  236.339 msecs 6059.859 gflops\n    Avg(10) total:  343.741 msecs 6249.698 gflops\n    ---------------------------------------------\n    Overfeat (dtype=float32, N=128) Results:\n    ---------------------------------------------\n    Avg(10) fprop:  117.611 msecs 6088.632 gflops\n    Avg(10) bprop:  268.379 msecs 5336.422 gflops\n    Avg(10) total:  385.990 msecs 5565.621 gflops\n\n    ---------------------------------------------\n    VGG (dtype=float16, N=64) Results:\n    ---------------------------------------------\n    Avg(10) fprop:  153.939 msecs 6298.629 gflops\n    Avg(10) bprop:  337.443 msecs 5746.783 gflops\n    Avg(10) total:  491.382 msecs 5919.665 gflops\n    ---------------------------------------------\n    VGG (dtype=float32, N=64) Results:\n    ---------------------------------------------\n    Avg(10) fprop:  165.948 msecs 5842.816 gflops\n    Avg(10) bprop:  389.139 msecs 4983.337 gflops\n    Avg(10) total:  555.087 msecs 5240.286 gflops\n\n    ---------------------------------------------\n    VGG_E (dtype=float16, N=64) Results:\n    ---------------------------------------------\n    Avg(10) fprop:  396.107 msecs 6332.999 gflops\n    Avg(10) bprop:  854.090 msecs 5874.195 gflops\n    Avg(10) total: 1250.197 msecs 6019.560 gflops\n    ---------------------------------------------\n    VGG_E (dtype=float32, N=64) Results:\n    ---------------------------------------------\n    Avg(10) fprop:  435.622 msecs 5758.533 gflops\n    Avg(10) bprop:  971.928 msecs 5162.000 gflops\n    Avg(10) total: 1407.550 msecs 5346.621 gflops\n\n\n#### Acknowledgements\n\nThanks to Erich Elsen and Bryan Catanzaro of Baidu, Matthieu Courbariaux and Frederic Bastien of the Bengio lab, Vincent Vanhoucke of Google, and Soumith Chintala of Facebook for feedback on early versions of this library. Thanks to Andreas Klockner for help with interfacing to his PyCUDA library.  We'd also like to thank NVIDIA for generously providing us with several TitanXs for benchmarking.\n\n\n#### References <a name=\"refs\"></a>\n\n1. Andreas Klockner, Nicolas Pinto, Yunsup Lee, Bryan Catanzaro, Paul Ivanov, Ahmed Fasih.\n[*PyCUDA and PyOpenCL: A scripting-based approach to GPU run-time code generation*](http://arxiv.org/abs/0911.3456)\nParallel Computing, Volume 38, Issue 3, March 2012, Pages 157-174.\n\n2. Chetlur, Sharan, Cliff Woolley, Philippe Vandermersch, Jonathan\nCohen, John Tran, Bryan Catanzaro, and Evan Shelhamer.\n[*cuDNN: Efficient primitives for deep learning.*](http://arxiv.org/abs/1410.0759)\narXiv preprint arXiv:1410.0759 (2014).\n\n3. Gupta, Suyog, Ankur Agrawal, Kailash Gopalakrishnan, and Pritish Narayanan. [*Deep Learning with Limited Numerical Precision.*](http://arxiv.org/abs/1502.02551) arXiv preprint arXiv:1502.02551 (2015).\n\n", 
  "id": 33341244
}
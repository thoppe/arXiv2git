{
  "read_at": 1462553363, 
  "description": "Haskell code associated to the \"Testing Noninterference, Quickly\" paper. The associated Coq proofs are in a separate repository: https://github.com/QuickChick/IFC", 
  "README.md": "\nCode for Testing Noninterference\n================================\n\n### Description\n\n- Haskell code associated to the following paper:\n  - Catalin Hritcu, Leonidas Lampropoulos, Antal Spector-Zabusky, Arthur Azevedo de Amorim, Maxime Denes, John Hughes, Benjamin C. Pierce, and Dimitrios Vytiniotis. Testing Noninterference, Quickly. arXiv:1409.0393. Submitted to Special Issue of Journal of Functional Programming for ICFP 2013. September 2014. (http://arxiv.org/abs/1409.0393)\n- The associated Coq proofs are in a separate repository: https://github.com/QuickChick/IFC\n\n### Prerequisites\n\n- GHC 7.4.x-7.8.x (known to work with 7.4.1, 7.6.3, and 7.8.3)\n- Haskell packages (available with 'cabal install package-name'):\n  - QuickCheck 2.7.x (known to work with 2.7.3)\n  - CmdArgs >0.9.5\n  - concurrent-extra\n- UNIX utilities like make, echo, rm, etc.\n\n### Building\n\nRun \"make\" in the top directory\n\n### Using ghci\n\nAll you need to do is invoke ghci (e.g. C-c C-l in Emacs if using\nhaskell-mode default key bindings) and the .ghci files will take care\nof the rest.\n\nOn Linux you might have permission problems (you might see \"WARNING:\n.ghci is writable by someone else, IGNORING!\" when starting ghci), in\nwhich case you need to make sure that this dir, its subdirs and the\n.ghci files inside are not group readable. A command like\n\n    chmod -R g-w .\n\nshould usually solve the problem.\n\n### Contents\n\n    Makefile\n    Makefile.common\n\n    stack/    -- Simple information-flow stack machine\n\n        Machine.hs     : definition of the abstract machine\n        Generation.hs  : random program generation\n        Driver.hs      : experiment set up, top level properties, main\n        Flags.hs       : various flags configuration of a machine\n        Instr.hs       : instruction set architecture\n        Labels.hs      : label models and observations\n        Observable.hs  : observable classes\n        ObservableInst.hs : observable classes and shrinking variations\n        ...\n\n    register/ -- Information-flow register machine with advanced features\n        ...\n\n    common/ -- Common definitions, and helpers\n        Aggregate.hs\n        Machine.hs              : common definitions for generic \"machines\"\n        Pretty.hs               : pretty printing\n        Trace.hs                : execution traces\n        Util.hs                 : misc. helpers\n        ...\n\n### Old description for stack machine code (TODO: bring this up to date)\n\n#### Running the test driver from command line\n\nYou may run the test driver from the command line with:\n\n     ./Driver\n\nThis will run with the default configuration, shown in Flags.hs\nHowever you may override one of the options manually as well -- for\ninstance:\n\n    ./Driver --gen-strategy=GenNaive --tests=10000\n\nor\n\n    ./Driver --gen-strategy=GenByExec --tests=30000\n\nAll values (and names for named options) are specified in Flags.hs. Finally,\nyou may run:\n\n    ./Driver --help\n\nto see a list of available options.\n\n#### Basic profiling of test generation\n\nTMUDriver contains flags that can profile tests for some\nbasic statistics. Namely, the\n\n    --prop-test=PropJustProfileLengths\n\nand\n\n    --prop-test=PropJustProfileWF\n\nrun profiling on tests with the current configuration. The former is\nprofiling execution lenghts, the latter is profiling the reasons for\ntermination. You may use --tests to determine the number of tests,\nor --gen-strategy to determine under which strategy you want to profile, etc.\n\n#### Bulk testing and profiling\n\nSome new options have been introduced that help profile/test in the bulk.\n\nNamely, you may want to give a string argument to --ifc-semantics, e.g.:\n\n    --ifc-semantics=\"[IfcBugAddNoTaint,IfcBugStoreNoTaint]\"\n\nwhich will iterate over these two buggy behaviors. The --ifc-semantics\nflag stands for a list of behaviours you would like to test. For convenience\nthere exists a wildcard value:\n\n    --ifc-semantics=\"*\"\n\nwhich you may use to iterate over all bugs.\n\nWhen testing you may want to suppress printing information from the\nactual counterexample, which you can do with:\n    --show-counterexamples=False\n\nHere is an example usage:\n\n    ./Driver --ifc-semantics=\"*\"\n             --gen-strategy=GenByExec\n             --show-counterexamples=False\n\nIterates over all bugs using GenByExec, not showing\ncounterexamples. It will print out average results in some format\n[DV:TODO]\n\n#### Coding syntax rules\n\nThe rationale for these rules is that they make refactoring easier.\n\nIn ghci, warnings will be raised:\n- if a top-level declaration is missing a type signature\n- if a tab is present\n- if a do block uses a value of type m A, for A [?] (), without binding\n  it to a value\n- if you have an incomplete set of pattern matches\n\nFor instance,\n\n    Prelude> let j (Just a) = a\n    <interactive>:2:5:\n      Warning: Pattern match(es) are non-exhaustive\n        In an equation for `j': Patterns not matched: Nothing\n\nAt compile-time, these warnings are errors: you're forced to stick to\nthese coding standards.\n", 
  "id": 23193927
}
{
  "read_at": 1462543038, 
  "description": "Coupled Cell Networks", 
  "README.md": "Algorithm to find balanced equivalence relations and lattices\n=============================================================\n\nCopyright 2010-2012 by Hiroko Kamei & Peter Cock.  All rights reserved.\nThis script was provided as a supplementary file for the manuscript:\n\nHiroko Kamei and Peter Cock (2013) \"Computation of Balanced Equivalence\nRelations and their Lattice for a Coupled Cell Network\", SIAM Journal on\nApplied Dynamical Systems (SIADS) 12(1), pp. 352-382.\nhttp://dx.doi.org/10.1137/100819795\nhttp://arxiv.org/abs/1211.6334\n\nYou are welcome to use and modify this code provided this copyright notice\nis retained (see the open source license for full details), however we\nrequest you cite this manuscript in any scientific publications using it.\n\nThis code and any public updates to it are available on GitHub, at:\nhttps://github.com/peterjc/ccn\n\n\nHistory\n-------\n\n| Version | Description                                                      |\n|---------|------------------------------------------------------------------|\n| v1.0.0  | - Supported Python 2.4, 2.5, 2.6, 2.7 directly, and worked under |\n|         |   Python 3 via the 2to3 conversion script.                       |\n| v1.0.1  | - Dropped support for Python 2.4 and 2.5, but now runs unmodifed |\n|         |   on Python 2.6, 2.7 and Python 3.2, 3.3 and 3.4.                |\n| v1.0.2  | - Made the Python script executable; fixed typo.                 |\n| v1.0.3  | - Minor coding style updates.                                    |\n|         | - Can use pydot_ng as Python 3 alternative to pydot.             |\n|         | - Fix for graphical output under Python 3.                       |\n\n\nRequirements\n------------\n\nThis script requires Python. Python is pre-installed on Apple Mac OS X, and on\nLinux distributions is easily installable via the package manager. For Windows\nuse one of the installers available from http://www.python.org\n\nWhile it originally supported older versions of Python, this script has been\nupdated to work unmodified on Python 2.6, 2.7, and Python 3.2, 3.3, 3.4 (and\nis expected to work on future Python 3 releases).\n\nIt requires NumPy (Numerical Python), available from http://numpy.scipy.org\nThis is used for array support, in particular matrix multiplication. This\nshould work with NumPy 1.6 or later.\n\nIn order to draw the graphs or lattices, it requires the free tool GraphViz\navailable from http://www.graphviz.org and a small python library to call\nGraphViz called pydot from https://github.com/erocarrera/pydot which in turn\nrequires pyparsing from http://sourceforge.net/projects/pyparsing/\n\nCurrently pydot has not been updated to work on Python 3, instead you can\ninstall pydot_ng https://github.com/pydot/pydot-ng\n\n\nUsage\n-----\n\nAt the command prompt (terminal window), assuming the Python script has been\nsaved as graphs.py in the current directory, on Mac or Linux you would run\nthis code by typing:\n\n    python graphs.py\n\nOn Windows, assuming you have installed Python 2.7 in the default location,\nyou would use the following in the command prompt (also called a \"DOS box\"\nor terminal window):\n\n    C:\\Python27\\python graphs.py\n\nThe script should then run, printing output to the screen, and (assuming the\nGraphViz requirements are installed) also generate a number of image files.\n\nThe structure of the script is as follows:\n 1. An introduction (partly duplicated in this README.md file)\n 2. A few key functions\n 3. A few classes\n 4. Code for self testing\n 5. User editable section, as provided this computes the balanced equivalence\n    relations and lattices for the graphs in the manuscript. Please copy or edit\n    these entries to look at other graphs of interest.\n\n\nTesting\n-------\n\nThe graphs.py script includes its own basic self tests, run automatically when\nyou execute `python graphs.py` on your computer.\n\n[![Build Status](https://secure.travis-ci.org/peterjc/ccn.png?branch=master)](https://travis-ci.org/peterjc/ccn)\n\nThese tests are also run automatically whenever changes are uploaded to this\nrepository using TravisCI, a continuous testing service.\n\n\nIntroduction\n------------\n\nThe file includes a number of embedded examples (which double as self-tests\nusing the Python doctest facility). These start with >>> which represents the\nPython prompt, and ... for continued lines. If you are not already familiar\nwith Python and the interactive Python prompt for simplicity we recommend\nsimply modifying this file and running it as shown above.\n\nAs a simple example, consider this regular network with just one edge type\n(Graph #7 in the manuscript):\n\n    *---------------------------*\n    |                           |\n    |  (5) <--- (1) <--- (4)    |\n    |            |       /|\\    |\n    |            |        |     |\n    |           \\|/       |     |\n    |           (2) ---> (3)    |\n    |                           |\n    *---------------------------*\n\nTo enter this topology, just one integer edge matrix is required, which can\nbe typed as a nested list of integers:\n\n    >>> network7 = CoupledCellNetwork([[0,0,0,1,0],\n    ...                                [1,0,0,0,0],\n    ...                                [0,1,0,0,0],\n    ...                                [0,0,1,0,0],\n    ...                                [1,0,0,0,0]])\n    >>> print network7\n    0 0 0 1 0 node 1\n    1 0 0 0 0 node 2\n    0 1 0 0 0 node 3\n    0 0 1 0 0 node 4\n    1 0 0 0 0 node 5\n\nThe printed output shows the adjacency matrix on the left (5 by 5) with the\nnode captions on the right.\n\nTo handle typical usage there is a go() function provided which will print the\nmatrix, draw it (if GraphViz is setup), compute the lattice, print it, and\ndraw it. Just pass a CoupledCellNetwork object to the go function with a name\n(a string), e.g. go(network7, \"n7\")\n\nWe will now briefly explain some of the details here, in case you want to\nmodify this.  To obtain the network as an image file, assuming GraphViz etc is\nsetup, use network7.plot(filename), where the filename can end with \".png\",\n\".pdf\", etc. For instance, network7.plot(\"n7.pdf\")\n\nThe network object has a method to calculate those cell partitions which are\nbalanced equivalence relations (balanced colourings):\n\n    >>> for p in network7.partitions():\n    ...     print \"%r or %s\" % (p, cyclic_partition(p))\n    [0, 0, 0, 0, 0] or (12345)\n    [0, 0, 0, 0, 1] or (1234)(5)\n    [0, 1, 0, 1, 1] or (13)(245)\n    [0, 1, 0, 1, 2] or (13)(24)(5)\n    [0, 1, 2, 3, 1] or (1)(25)(3)(4)\n    [0, 1, 2, 3, 4] or (1)(2)(3)(4)(5)\n\nSimilar methods allow access to the associated quotient networks instead or as\nwell. There is also a method which uses the balanced equivalence relations to\nbuild a lattice:\n\n    >>> lattice7 = network7.lattice()\n    >>> print lattice7\n    0 0 0 0 0 0 (12345)\n    1 0 0 0 0 0 (1234)(5)\n    1 0 0 0 0 0 (13)(245)\n    0 1 1 0 0 0 (13)(24)(5)\n    0 0 1 0 0 0 (1)(25)(3)(4)\n    0 0 0 1 1 0 (1)(2)(3)(4)(5)\n\nThe lattice is printed using a directed graph adjacency matrix (here with\nsix nodes, listed on the right of the output in cyclic notation) which is\nshown on the left as a lower triangular matrix. Rather than being drawn as a\ndirected graph with arrows, it is conventional to use lattice diagrams with\nundirected edges with the directionality of the partition cover relationship\nimplicit in the vertical placement of the nodes. To obtain the lattice diagram\nas an image file, assuming GraphViz etc is setup, use lattice7.plot(filename),\ne.g lattice7.plot(\"n7_lattice.pdf\") for a PDF file. Here is a simple text\ngraphic of this lattice diagram:\n\n    *--------------------------------------*\n    |                                      |\n    | Rank 1:          (12345)             |\n    |                  /     \\             |\n    |                 /       \\            |\n    | Rank 2:    (1234)(5)  (13)(245)      |\n    |                |     /   |           |\n    |                |    /    |           |\n    | Rank 3:  (13)(24)(5)     |           |\n    |                \\         |           |\n    |                 \\        |           |\n    | Rank 4:          \\  (1)(25)(3)(4)    |\n    |                   \\     /            |\n    |                    \\   /             |\n    | Rank 5:       (1)(2)(3)(4)(5)        |\n    |                                      |\n    *--------------------------------------*\n\nFor a multiple edge type example, consider this inhomogeneous version of the\nprevious network, with two edge types (Graph #3 in the manuscript), where edge\ntype one (single thickness) arrows run from node 1 to 5, 1 to 2 and 3 to 4,\nand edge type two (dotted) arrows run from node 4 to 1 and from 2 to 3.\n\n    *---------------------------*\n    |                           |\n    |  [5] <--- (1) <... [4]    |\n    |            |       /|\\    |\n    |            |        |     |\n    |           \\|/       |     |\n    |           [2] ...> (3)    |\n    |                           |\n    *---------------------------*\n\nTo enter this topology, two integer edge matrices are required (for the two\nedge types):\n\n    >>> network3 = CoupledCellNetwork([[0,0,0,0,0],\n    ...                                [1,0,0,0,0],\n    ...                                [0,0,0,0,0],\n    ...                                [0,0,1,0,0],\n    ...                                [1,0,0,0,0]],\n    ...                               [[0,0,0,1,0],\n    ...                                [0,0,0,0,0],\n    ...                                [0,1,0,0,0],\n    ...                                [0,0,0,0,0],\n    ...                                [0,0,0,0,0]])\n    >>> print network3\n    (0,0) (0,0) (0,0) (0,1) (0,0) node 1\n    (1,0) (0,0) (0,0) (0,0) (0,0) node 2\n    (0,0) (0,1) (0,0) (0,0) (0,0) node 3\n    (0,0) (0,0) (1,0) (0,0) (0,0) node 4\n    (1,0) (0,0) (0,0) (0,0) (0,0) node 5\n\nWhen printed as shown above, the network adjacency matrix is represented as a\nsingle combined matrix where each element shows the edge types, e.g. (1,0) for\none edge of the first type, no edges of the second type. Internally however\nthe data remains as two separate matrices. The network object works just the\nsame as before, for example notice how there are only 4 balanced equivalence\nrelations (compared to the regular network #7 used above with 6):\n\n    >>> for p in network3.partitions():\n    ...     print \"%r or %s\" % (p, cyclic_partition(p))\n    [0, 1, 0, 1, 1] or (13)(245)\n    [0, 1, 0, 1, 2] or (13)(24)(5)\n    [0, 1, 2, 3, 1] or (1)(25)(3)(4)\n    [0, 1, 2, 3, 4] or (1)(2)(3)(4)(5)\n\nTaking the second of these partitions gives a three cell quotient network:\n\n    >>> print network3.quotient([0, 1, 0, 1, 2])\n    (0,0) (0,1) (0,0) node 1+3\n    (1,0) (0,0) (0,0) node 2+4\n    (1,0) (0,0) (0,0) node 5\n\nAnd using the balanced equivalence relations to build the lattice:\n\n    >>> lattice = network3.lattice()\n    >>> print lattice\n    0 0 0 0 (13)(245)\n    1 0 0 0 (13)(24)(5)\n    1 0 0 0 (1)(25)(3)(4)\n    0 1 1 0 (1)(2)(3)(4)(5)\n\nThe lattice is an undirected graph (here with four nodes, listed on the right\nof the output in cyclic notation) which is represented on the left as a lower\ntriangular matrix. Graphically:\n\n    *--------------------------------------*\n    |                                      |\n    | Rank 1:    (no nodes at rank one)    |\n    |                                      |\n    |                                      |\n    | Rank 2:        (13)(245)             |\n    |                 /    \\               |\n    |                /      \\              |\n    | Rank 3:  (13)(24)(5)   \\             |\n    |                \\        \\            |\n    |                 \\        \\           |\n    | Rank 4:          \\   (1)(25)(3)(4)   |\n    |                   \\      /           |\n    |                    \\    /            |\n    | Rank 5:       (1)(2)(3)(4)(5)        |\n    |                                      |\n    *--------------------------------------*\n\nThe idea is you can edit the examples in last section of the graphs.py file to\nrun this program on particular networks of interest. In the long term if the\ntool is extended, restructuring this into a typical Python library would be\nsensible. For now however, a single self contained Python file was simplest.\n", 
  "id": 1107384
}
{
  "read_at": 1462551103, 
  "description": "A better compressed bitset in Java", 
  "README.md": "RoaringBitmap\n=============\n\n[![Build Status](https://travis-ci.org/RoaringBitmap/RoaringBitmap.png)](https://travis-ci.org/RoaringBitmap/RoaringBitmap)\n[![][maven img]][maven]\n[![][license img]][license]\n[![docs-badge][]][docs]\n[![Coverage Status](https://coveralls.io/repos/github/RoaringBitmap/RoaringBitmap/badge.svg?branch=master)](https://coveralls.io/github/RoaringBitmap/RoaringBitmap?branch=master)\n\nBitsets, also called bitmaps, are commonly used as fast data structures.\nUnfortunately, they can use too much memory. To compensate, we often use\ncompressed bitmaps.\n\nRoaring bitmaps are compressed bitmaps which tend to outperform conventional\ncompressed bitmaps such as WAH, EWAH or Concise. In some instances, roaring bitmaps can\nbe hundreds of times faster and they often offer significantly better compression.\nThey can even be faster than uncompressed bitmaps.\n\nThis library is used by\n* Apache Spark (http://spark.apache.org/),\n* Apache Kylin (http://kylin.io) and\n* Druid (http://druid.io/).\n\n\nApache Lucene (http://lucene.apache.org/) uses  Roaring bitmaps, though they have their own [independent implementation](https://svn.apache.org/viewvc/lucene/dev/branches/branch_5x/lucene/core/src/java/org/apache/lucene/util/RoaringDocIdSet.java?view=markup&pathrev=1629606). Derivatives of Lucene such as Solr and Elastic also use Roaring bitmaps.\nOther platforms such as Whoosh (https://pypi.python.org/pypi/Whoosh/) also use Roaring bitmaps with\ntheir own implementations.\n\n\n(c) 2013-2016 Daniel Lemire, Owen Kaser, Samy Chambi, Jon Alvarado, Rory Graves, Bjorn Sperber, Seth Pellegrino, Borislav Ivanov, Gregory Ssi-Yan-Kai, Galderic Punti, Navis Ryu, Jerven Bolleman, Keuntae Park, Olaf Krische, George Kankava, Junyuan Zheng\n\n\nThis code is licensed under Apache License, Version 2.0 (ASL2.0).\n\n\n\nWhen should you use a bitmap?\n===================================\n\n\nSets are a fundamental abstraction in\nsoftware. They can be implemented in various\nways, as hash sets, as trees, and so forth.\nIn databases and search engines, sets are often an integral\npart of indexes. For example, we may need to maintain a set\nof all documents or rows  (represented by numerical identifier)\nthat satisfy some property. Besides adding or removing\nelements from the set, we need fast functions\nto compute the intersection, the union, the difference between sets, and so on.\n\n\nTo implement a set\nof integers, a particularly appealing strategy is the\nbitmap (also called bitset or bit vector). Using n bits,\nwe can represent any set made of the integers from the range\n[0,n): it suffices to set the ith bit is set to one if integer i is present in the set.\nCommodity processors use words of W=32 or W=64 bits. By combining many such words, we can\nsupport large values of n. Intersections, unions and differences can then be implemented\n as bitwise AND, OR and ANDNOT operations.\nMore complicated set functions can also be implemented as bitwise operations.\n\nWhen the bitset approach is applicable, it can be orders of\nmagnitude faster than other possible implementation of a set (e.g., as a hash set)\nwhile using several times less memory.\n\n\nWhen should you use compressed bitmaps?\n===================================\n\nAn uncompress BitSet can use a lot of memory. For example, if you take a BitSet\nand set the bit at position 1,000,000 to true and you have just over 100kB. That's over 100kB\nto store the position of one bit. This is wasteful  even if you do not care about memory:\nsuppose that you need to compute the intersection between this BitSet and another one\nthat has a bit at position 1,000,001 to true, then you need to go through all these zeroes,\nwhether you like it or not. That can become very wasteful.\n\nThis being said, there are definitively cases where attempting to use compressed bitmaps is wasteful.\nFor example, if you have a small universe size. E.g., your bitmaps represent sets of integers\nfrom [0,n) where n is small (e.g., n=64 or n=128). If you are able to uncompressed BitSet and\nit does not blow up your memory usage,  then compressed bitmaps are probably not useful\nto you. In fact, if you do not need compression, then a BitSet offers remarkable speed.\n\n\nHow does Roaring compares with the alternatives?\n==================================================\n\n\nMost alternatives to Roaring are part of a larger family of compressed bitmaps that are run-length-encoded\nbitmaps. They identify long runs of 1s or 0s and they represent them with a marker word.\nIf you have a local mix of 1s and 0, you use an uncompressed word.\n\nThere are many formats in this family:\n\n* Oracle's BBC is an obsolete format at this point: though it may provide good compression,\nit is likely much slower than more recent alternatives due to excessive branching.\n* WAH is a patented variation on BBC that provides better performance.\n* Concise is a variation on the patented WAH. It some specific instances, it can compress\nmuch better than WAH (up to 2x better), but it is generally slower.\n* EWAH is both free of patent, and it is faster than all the above. On the downside, it\ndoes not compress quite as well. It is faster because it allows some form of \"skipping\"\nover uncompressed words. So though none of these formats are great at random access, EWAH\nis better than the alternatives.\n\n\n\nThere is a big problem with these formats however that can hurt you badly in some cases: there is no random access. If you want to check whether a given value is present in the set, you have to start from the beginning and \"uncompress\" the whole thing. This means that if you want to intersect a big set with a large set, you still have to uncompress the whole big set in the worst case...\n\nRoaring solves this problem. It works in the following manner. It divides the data into chunks of 2<sup>16</sup> integers\n(e.g., [0, 2<sup>16</sup>), [2<sup>16</sup>, 2 x 2<sup>16</sup>), ...). Within a chunk, it can use an uncompressed bitmap, a simple list of integers,\nor a list of runs. Whatever format it uses, they all allow you to check for the present of any one value quickly\n(e.g., with a binary search). The net result is that Roaring can compute many operations much faster that run-length-encoded\nformats like WAH, EWAH, Concise... Maybe surprisingly, Roaring also generally offers better compression ratios.\n\n\n\nAPI docs\n---------\n\nhttp://www.javadoc.io/doc/org.roaringbitmap/RoaringBitmap/\n\nScientific Documentation\n--------------------------\n\n-  Samy Chambi, Daniel Lemire, Owen Kaser, Robert Godin,\nBetter bitmap performance with Roaring bitmaps,\nSoftware: Practice and Experience Volume 46, Issue 5, pages 709-719, May 2016\nhttp://arxiv.org/abs/1402.6407 This paper used data from http://lemire.me/data/realroaring2014.html\n- Daniel Lemire, Gregory Ssi-Yan-Kai, Owen Kaser, Consistently faster and smaller compressed bitmaps with Roaring, Software: Practice and Experience (accepted in 2016, to appear) http://arxiv.org/abs/1603.06549\n\n\nCode sample\n-------------\n\n```java        \nimport org.roaringbitmap.RoaringBitmap;\n\npublic class Basic {\n\n  public static void main(String[] args) {\n        RoaringBitmap rr = RoaringBitmap.bitmapOf(1,2,3,1000);\n        RoaringBitmap rr2 = new RoaringBitmap();\n        rr2.add(4000L,4255L);\n\n        RoaringBitmap rror = RoaringBitmap.or(rr, rr2);// new bitmap\n        rr.or(rr2); //in-place computation\n        boolean equals = rror.equals(rr);// true\n        if(!equals) throw new RuntimeException(\"bug\");\n        // number of values stored?\n        long cardinality = rr.getLongCardinality();\n        System.out.println(cardinality);\n        // a \"forEach\" is faster than this loop, but a loop is possible:\n        for(int i : rr) {\n          System.out.println(i);\n        }\n  }\n}\n```\n\nPlease see the examples folder for more examples.\n\nWorking with memory-mapped bitmaps\n---------------------------------------\n\nIf you want to have your bitmaps lie in memory-mapped files, you can\nuse the org.roaringbitmap.buffer package instead.\n\nThe following code sample illustrates how to create an ImmutableRoaringBitmap\nfrom a ByteBuffer. In such instances, the constructor only loads the meta-data\nin RAM while the actual data is accessed from the ByteBuffer on demand.\n\n```java\n        import org.roaringbitmap.buffer.*;\n\n        //...\n\n        MutableRoaringBitmap rr1 = MutableRoaringBitmap.bitmapOf(1, 2, 3, 1000);\n        MutableRoaringBitmap rr2 = MutableRoaringBitmap.bitmapOf( 2, 3, 1010);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        DataOutputStream dos = new DataOutputStream(bos);\n        // If there were runs of consecutive values, you could\n        // call rr1.runOptimize(); or rr2.runOptimize(); to improve compression\n        rr1.serialize(dos);\n        rr2.serialize(dos);\n        dos.close();\n        ByteBuffer bb = ByteBuffer.wrap(bos.toByteArray());\n        ImmutableRoaringBitmap rrback1 = new ImmutableRoaringBitmap(bb);\n        bb.position(bb.position() + rrback1.serializedSizeInBytes());\n        ImmutableRoaringBitmap rrback2 = new ImmutableRoaringBitmap(bb);\n```\n\nOperations on an ImmutableRoaringBitmap such as and, or, xor, flip, will\ngenerate a RoaringBitmap which lies in RAM. As the name suggest, the\nImmutableRoaringBitmap itself cannot be modified.\n\nThis design was inspired by Druid.\n\nOne can find a complete working example in the test file TestMemoryMapping.java.\n\nNote that you should not mix the classes from the org.roaringbitmap package with the classes\nfrom the org.roaringbitmap.buffer package. They are incompatible. They serialize to the same output however.\n\nPrerequisites\n-------------\n\n - Version 0.6.x requires JDK 7 or better\n - Version 0.5.x requires JDK 6 or better\n\nTo build the project you need maven (version 3).\n\n\nDownload\n---------\n\nYou can download releases from the Maven repository:\nhttp://central.maven.org/maven2/org/roaringbitmap/RoaringBitmap/\n\nor from github:\nhttps://github.com/RoaringBitmap/RoaringBitmap/releases\n\nMaven repository\n----------------\nIf your project depends on roaring, you  can  specify the dependency in the Maven \"pom.xml\" file:\n\n```xml\n        <dependencies>\n          <dependency>\n            <groupId>org.roaringbitmap</groupId>\n            <artifactId>RoaringBitmap</artifactId>\n            <version>[0.6,)</version>\n          </dependency>\n        </dependencies>\n```\n\nwhere you should replace the version number by the version you require.\n\nUsage\n------\n\n* Get java\n* Get maven 3\n\n* ``mvn compile`` will compile\n* ``mvn test`` will run the basic unit tests\n* ``mvn package`` will package in a jar (found in target)\n* ``mvn checkstyle:check`` will check that you abide by the code style\n*  To run our complete testing routine (it takes a long time), execute ``mvn clean test && mvn clean install -DskipTests -Dgpg.skip=true && mvn -f real-roaring-dataset/pom.xml clean install && mvn -f ./jmh/pom.xml test``. Be warned that our testing is very thorough.\n\nA convenient command to build the code is :\n\n             mvn clean install -DskipTests -Dgpg.skip=true\n\nContributing\n------------\n\nContributions are invited. We enforce the Google Java style.\nPlease run  ``mvn checkstyle:check`` on your code before submitting\na patch.\n\nFAQ\n----\n\n1. I am getting an error about a bad cookie. What is this about?\n\nIn the serialized files, part of the first 4 bytes are dedicated to a \"cookie\"\nwhich serves to indicate the file format.\n\nIf you try to deserialize or map a bitmap from data that has an\nunrecognized \"cookie\", the code will abort the process and report\nan error.\n\nThis problem will occur to all users who serialized Roaring bitmaps\nusing versions prior to 0.4.x as they upgrade to version 0.4.x or better.\nThese users need to refresh their serialized bitmaps.\n\n\n\n2. How big can a Roaring bitmap get?\n\n\nGiven N integers in [0,x), then the serialized size in bytes of\na Roaring bitmap should never exceed this bound:\n\n`` 8 + 9 * ((long)x+65535)/65536 + 2 * N ``\n\nThat is, given a fixed overhead for the universe size (x), Roaring\nbitmaps never use more than 2 bytes per integer. You can call\n``RoaringBitmap.maximumSerializedSize`` for a more precise estimate.\n\nBenchmark\n-----------\n\nTo run JMH benchmarks, use the following command:\n\n         $ ./jmh/run.sh\n\nYou can also run specific benchmarks...\n\n         $ ./jmh/run.sh org.roaringbitmap.aggregation.and.identical.*\n\nTo run memory benchmarks, use the following command:\n\n         $ ./memory/run.sh\n\n\nFunding\n----------\n\nThis work was supported by NSERC grant number 26143.\n\n\n\n[maven img]:https://maven-badges.herokuapp.com/maven-central/org.roaringbitmap/RoaringBitmap/badge.svg\n[maven]:http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.roaringbitmap%22%20\n\n[license]:LICENSE-2.0.txt\n[license img]:https://img.shields.io/badge/License-Apache%202-blue.svg\n\n[docs-badge]:https://img.shields.io/badge/API-docs-blue.svg?style=flat-square\n[docs]:http://www.javadoc.io/doc/org.roaringbitmap/RoaringBitmap/\n", 
  "id": 10746583
}
{
  "README": "=PHAT (Persistent Homology Algorithm Toolbox), v1.4.0=\nCopyright 2013, 2014 IST Austria\n\n==Project Founders:==\n\nUlrich Bauer, Michael Kerber, Jan Reininghaus\n\n==Contributors:==\n\nHubert Wagner, Primoz Skraba\n\n==Downloads:==\n  * [https://drive.google.com/uc?id=0B7Yz6TPEpiGEMGFNQ3FPX3ltelk&export=download PHAT, v1.3.0]\n  * [https://drive.google.com/uc?id=0B7Yz6TPEpiGENE9KUnhUSFdFQUk&export=download PHAT, v1.2.1]\n  * [https://drive.google.com/uc?id=0B7Yz6TPEpiGERGZFbjlXaUt1ZWM&export=download benchmark data]\n\n==Description:==\n\nThis software library contains methods for computing the persistence pairs of a \nfiltered cell complex represented by an ordered boundary matrix with Z<sub>2</sub> coefficients. \nFor an introduction to persistent homology, see the textbook `[1]`. This software package\ncontains code for several algorithmic variants:\n\n  * The \"standard\" algorithm (see `[1]`, p.153)\n  * The \"row\" algorithm from `[2]` (called pHrow in there)\n  * The \"twist\" algorithm, as described in `[3]` (default algorithm)\n  * The \"chunk\" algorithm presented in `[4]` \n\nThe last two algorithms exploit the special structure of the boundary matrix\nto take shortcuts in the computation. The chunk algorithm makes use of multiple \nCPU cores if it is compiled with OpenMP support.\n\nAll algorithms are implemented as functor classes that manipulate a given {{{boundary_matrix}}} (to be defined below) object to reduced form. \nFrom this reduced form one can then easily extract the persistence pairs. \nAlternatively, one can use the {{{compute_persistence_pairs function}}} which takes an algorithm as a template parameter, reduces the given {{{boundary_matrix}}} and stores the resulting pairs in a given {{{persistence_pairs}}} object.\n\nThe {{{boundary_matrix class}}} takes a \"Representation\" class as template parameter. This representation defines\nhow columns of the matrix are represented and how low-level operations \n(e.g., column additions) are performed. The right choice of the representation\nclass can be as important for the performance of the program as choosing the\nalgorithm. We provide the following choices of representation classes:\n\n  * {{{vector_vector}}}: Each column is represented as a sorted {{{std::vector}}} of integers, containing the indices of the non-zero entries of the column. The matrix itself is a {{{std::vector}}} of such columns.\n  * {{{vector_heap}}}: Each column is represented as a heapified {{{std::vector}}} of integers, containing the indices of the non-zero entries of the column. The matrix itself is a {{{std::vector}}} of such columns.\n  * {{{vector_set}}}: Each column is a {{{std::set}}} of integers, with the same meaning as above. The matrix is stored as a {{{std::vector}}} of such columns.\n  * {{{vector_list}}}: Each column is a sorted {{{std::list}}} of integers, with the same meaning as above. The matrix is stored as a {{{std::vector}}} of such columns.\n  * {{{sparse_pivot_column}}}: The matrix is stored as in the vector_vector representation. However, when a column is manipulated, it is first  converted into a {{{std::set}}}, using an extra data field called the \"pivot column\".  When another column is manipulated later, the pivot column is converted back to  the {{{std::vector}}} representation. This can lead to significant speed improvements when many columns  are added to a given pivot column consecutively. In a multicore setup, there is one pivot column per thread.\n  * {{{heap_pivot_column}}}: The same idea as in the sparse version. Instead of a {{{std::set}}}, the pivot column is represented by a {{{std::priority_queue}}}. \n  * {{{full_pivot_column}}}: The same idea as in the sparse version. However, instead of a {{{std::set}}}, the pivot column is expanded into a bit vector of size n (the dimension of the matrix). To avoid costly initializations, the class remembers which entries have been manipulated for a pivot column and updates only those entries when another column becomes the pivot.\n  * {{{bit_tree_pivot_column}}} (default representation): Similar to the {{{full_pivot_column}}} but the implementation is more efficient. Internally it is a bit-set with fast iteration over nonzero elements, and fast access to the maximal element. \n  \nThere are two ways to interface with the library:\n\n  * using files: \n    # write the boundary matrix / filtration into a file \"input\" (see below for the file format). \n    # compile {{{src/phat.cpp}}} and run it:\n    {{{\n    phat [--ascii] input output\n    }}} \n    # read the resulting persistence pairs into your program \n\n  * using the C++ library interface:\n    # include all headers found in {{{src/phat.cpp}}}\n    # define a boundary matrix object, e.g. \n{{{\nphat::boundary_matrix< bit_tree_pivot_column > boundary_matrix;\n}}}\n    # set the number of columns:\n{{{\nboundary_matrix.set_num_cols(...);\n}}}\n    # initialize each column using \n{{{\nboundary_matrix.set_col(...)\nboundary_matrix.set_dim(...)\n}}}\n    # define an object to hold the result:\n{{{\nphat::persistence_pairs pairs;\n}}}\n    # run an algorithm like this:\n{{{\nphat::compute_persistence_pairs< phat::twist_reduction >( pairs, boundary_matrix );\n}}}\n    # examine the result: \n{{{\npairs.get_num_pairs()\npairs.get_pair(...)\n}}} \n \t\n    A simple example that demonstrates this functionality can be found in {{{src/simple_example.cpp}}}\n\n==File Formats:==\n\nThe library supports input and output in ascii and binary format\nthrough the methods {{{[load|save]_[ascii|binary]}}} in the classes {{{boundary_matrix}}} \nand {{{persistence_pairs}}}. The file formats are defined as follows:\n\n{{{boundary_matrix}}} - ascii:\n\tThe file represents the filtration of the cell complex, containing one cell \n\tper line (empty lines and lines starting with \"#\" are ignored). A cell is given by \n\ta sequence of integers, separated by spaces, where the first integer denotes the\n\tdimension of the cell, and all following integers give the indices\n\tof the cells that form its boundary (the index of a cell is its position \n\tin the filtration, starting with 0). \n\tA sample file {{{single_triangle.dat}}} can be found in the examples folder.\n\n{{{boundary_matrix}}} - binary:\n\tIn binary format, the file is simply interpreted as a sequence of 64 bit signed integer \n\tnumbers. The first number is interpreted as the number of cells of the complex. The \t\n\tdescriptions of the cells is expected to follow, with the first number representing the \n\tdimension of the cell, the next number, say N, representing the size of the boundary, \n\tfollowed by N numbers denoting the indices of the boundary cells. \n\tA sample file {{{single_triangle.bin}}} can be found in the examples folder.\n\n{{{persistence_pairs}}} - ascii: \n\tThe file contains the persistence pairs, sorted by birth index. The first integer in the\n\tfile is equal to the number of pairs. It is followed by pairs of integers encode the \n\trespective birth and death indices. \n\tA sample file {{{single_triangle_persistence_pairs.dat}}} can be found in the examples folder.\n\n{{{persistence_pairs}}} - binary: \n\tSame as ascii format, see above. Only now the integers are encoded as 64bit signed integers.\n\tA sample file {{{single_triangle_persistence_pairs.bin}}} can be found in the examples folder.\n\n==Supported Platforms:==\n  * Visual Studio 2008 and 2012 (2010 untested)\n  * GCC version 4.4. and higher\n\n==References:==\n\n  # H.Edelsbrunner, J.Harer: Computational Topology, An Introduction. American Mathematical Society, 2010, ISBN 0-8218-4925-5\n  # V.de Silva, D.Morozov, M.Vejdemo-Johansson: Dualities in persistent (co)homology. Inverse Problems 27, 2011\n  # C.Chen, M.Kerber: Persistent Homology Computation With a Twist. 27th European Workshop on Computational Geometry, 2011.\n  # U.Bauer, M.Kerber, J.Reininghaus: Clear and Compress: Computing Persistent Homology in Chunks. [http://arxiv.org/pdf/1303.0477.pdf arXiv:1303.0477]", 
  "read_at": 1462550379, 
  "description": "Automatically exported from code.google.com/p/phat", 
  "id": 48422721
}
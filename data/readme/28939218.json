{
  "id": 28939218, 
  "read_at": 1462551622, 
  "README.rst": "Roaring Bitmap in Cython\n========================\n\nA roaring bitmap is an efficient compressed datastructure to store a set\nof integers. A Roaring bitmap stores a set of 32-bit integers in a series of\narrays and bitmaps, whichever takes the least space (which is always\n``2 ** 16`` bits or less).\n\nThis datastructure is useful for storing a large number of integers, e.g., for\nan inverted index used by search engines and databases. In particular, it is\npossible to quickly compute the intersection of a series of sets, which can be\nused to implement a query as the conjunction of subqueries.\n\nThis implementation is based on the Java and C implementations at\nhttps://github.com/lemire/RoaringBitmap\nand https://github.com/lemire/CRoaring\n\nAn additional feature of this implementation is that it uses arrays not only\nwhen a block contains less than ``2 ** 12`` elements, but also when it contains\nmore than ``2 ** 32 - 2 ** 12`` elements; i.e., blocks that are mostly full are\nstored just as compactly as blocks that are mostly empty. Other blocks are\nencoded as bitmaps of fixed size. This trick is based on the implementation in\nLucene, cf. https://issues.apache.org/jira/browse/LUCENE-5983\n\nLicense, requirements\n---------------------\nThe code is licensed under GNU GPL v2, or any later version at your option.\n\n- Python 2.7+/3.3+  http://www.python.org (headers required, e.g. python-dev package)\n- Cython 0.20+      http://www.cython.org\n\nInstallation, usage\n-------------------\n\n::\n\n    $ git clone https://github.com/andreasvc/roaringbitmap.git\n    $ cd roaringbitmap\n    $ make\n\n(or ``make py2`` for Python 2)\n\nA ``RoaringBitmap()`` can be used as a replacement for a normal (mutable)\nPython set containing (unsigned) 32-bit integers:\n\n.. code-block:: python\n\n    >>> from roaringbitmap import RoaringBitmap\n    >>> RoaringBitmap(range(10)) & RoaringBitmap(range(5, 15))\n    RoaringBitmap({5, 6, 7, 8, 9})\n\nA sequence of immutable RoaringBitmaps can be stored in a single file and\naccessed efficiently with ``mmap``, without needing to copy or deserialize:\n\n.. code-block:: python\n\n    >>> from roaringbitmap import MultiRoaringBitmap\n    >>> mrb = MultiRoaringBitmap([range(n, n + 5) for n in range(10)], filename='index')\n\n    >>> mrb = MultiRoaringBitmap.fromfile('index')\n    >>> mrb[5]\n    ImmutableRoaringBitmap({5, 6, 7, 8, 9})\n\nFor API documentation cf. http://roaringbitmap.readthedocs.io\n\nBenchmarks\n----------\nOutput of ``$ make bench``::\n\n    small sparse set\n    100 runs with sets of 200 random elements n s.t. 0 <= n < 40000\n                    set()  RoaringBitmap()    ratio\n    init         0.000838          0.00231    0.362\n    initsort     0.000847          0.00126    0.675\n    and           0.00104         0.000141     7.36\n    or            0.00172         0.000188     9.13\n    xor           0.00152         0.000235     6.46\n    sub          0.000956         0.000172     5.57\n    iand         1.29e-05         3.46e-06     3.72\n    ior          9.63e-06          3.6e-06     2.67\n    ixor         9.07e-06          3.7e-06     2.45\n    isub         7.09e-06         3.22e-06      2.2\n    eq           0.000451         1.13e-05     40.1\n    neq          6.32e-06         8.54e-06     0.74\n    jaccard       0.00278         0.000155       18\n\n    medium load factor\n    100 runs with sets of 59392 random elements n s.t. 0 <= n < 118784\n                    set()  RoaringBitmap()    ratio\n    init            0.508             0.43     1.18\n    initsort        0.692            0.389     1.78\n    and             0.613         0.000309     1987\n    or              0.973         0.000317     3065\n    xor             0.891         0.000311     2864\n    sub             0.346         0.000313     1104\n    iand          0.00647         1.13e-05      575\n    ior           0.00599         1.22e-05      489\n    ixor          0.00417         1.31e-05      318\n    isub          0.00431         1.18e-05      363\n    eq             0.0982         0.000112      873\n    neq          9.87e-06         1.29e-05    0.763\n    jaccard          1.59         0.000315     5047\n\n    dense set / high load factor\n    100 runs with sets of 39800 random elements n s.t. 0 <= n < 40000\n                    set()  RoaringBitmap()    ratio\n    init            0.313            0.114     2.75\n    initsort        0.341            0.199     1.71\n    and              0.23         0.000165     1394\n    or              0.453         0.000153     2958\n    xor              0.41         0.000174     2361\n    sub             0.168         0.000163     1030\n    iand          0.00288         5.95e-06      484\n    ior           0.00166         5.91e-06      281\n    ixor          0.00194         5.68e-06      342\n    isub           0.0017         6.48e-06      262\n    eq             0.0493         4.51e-05     1092\n    neq          9.85e-06          1.3e-05    0.759\n    jaccard         0.717         0.000154     4641\n\nReferences\n----------\nSamy Chambi, Daniel Lemire, Owen Kaser, Robert Godin (2014),\nBetter bitmap performance with Roaring bitmaps,\nhttp://arxiv.org/abs/1402.6407\n\n- http://roaringbitmap.org/\n- https://github.com/lemire/RoaringBitmap\n- https://issues.apache.org/jira/browse/LUCENE-5983\n", 
  "description": "Roaring Bitmap in Cython"
}
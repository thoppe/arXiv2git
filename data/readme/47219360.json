{
  "read_at": 1462550041, 
  "description": "Roaring bitmaps in C (Currently being developed)", 
  "README.md": "# CRoaring\nRoaring bitmaps in C\n\n# Current status\n\nThis library is being actively developed. For the time being, this library is not **usable for anything but\n _research_**. **Do not attempt to use this library in production systems**. See http://roaringbitmap.org for\na list of supported libraries.\n\n# Introduction\n\nBitsets, also called bitmaps, are commonly used as fast data structures. Unfortunately, they can use too much memory.\n To compensate, we often use compressed bitmaps.\n\nRoaring bitmaps are compressed bitmaps which tend to outperform conventional compressed bitmaps such as WAH, EWAH or Concise.\nThey are used by several major systems such as [Apache Lucene][lucene] and derivative systems such as [Solr][solr] and\n[Elasticsearch][elasticsearch], [Metamarkets' Druid][druid], [Apache Spark][spark], [Whoosh][whoosh] and eBay's [Apache Kylin][kylin].\n\n[lucene]: https://lucene.apache.org/\n[solr]: https://lucene.apache.org/solr/\n[elasticsearch]: https://www.elastic.co/products/elasticsearch\n[druid]: http://druid.io/\n[spark]: https://spark.apache.org/\n[whoosh]: https://bitbucket.org/mchaput/whoosh/wiki/Home\n[kylin]: http://kylin.apache.org/\n\n# Objective\n\nThe primary goal of the CRoaring is to provide a high performance low-level implementation that fully take advantage\nof the latest hardware. Roaring bitmaps are already available on a variety of platform through Java, Go, Rust... implementations. CRoaring is a library that seeks to achieve superior performance by staying close to the latest hardware.\n\n# Requirements\n\n- 64-bit Linux-like operating system (including MacOS)\n- Recent Intel processor: Haswell (2013) or better.\n- Recent C compiler (GCC 4.8 or better)\n- CMake\n- clang-format (optional)\n\nSupport for legacy hardware and compiler might be added later.\n\n# Example\n\n```c\n////\n//// #include \"roaring.h\"\n////\n\n// create a new empty bitmap\nroaring_bitmap_t *r1 = roaring_bitmap_create();\n// then we can add values\nfor (uint32_t i = 100; i < 1000; i++) roaring_bitmap_add(r1, i);\n// check whether a value is contained\nassert(roaring_bitmap_contains(r1, 500));\n// compute how many bits there are:\nuint32_t cardinality = roaring_bitmap_get_cardinality(r1);\nprintf(\"Cardinality = %d \\n\", cardinality);\n\n// if your bitmaps have long runs, you can compress them by calling\n// run_optimize\nuint32_t expectedsizebasic = roaring_bitmap_portable_size_in_bytes(r1);\nroaring_bitmap_run_optimize(r1);\nuint32_t expectedsizerun = roaring_bitmap_portable_size_in_bytes(r1);\nprintf(\"size before run optimize %d bytes, and after %d bytes\\n\",\n       expectedsizebasic, expectedsizerun);\n\n// create a new bitmap containing the values {1,2,3,5,6}\nroaring_bitmap_t *r2 = roaring_bitmap_of(5, 1, 2, 3, 5, 6);\nroaring_bitmap_printf(r2);  // print it\n\n// we can also create a bitmap from a pointer to 32-bit integers\nuint32_t somevalues[] = {2, 3, 4};\nroaring_bitmap_t *r3 = roaring_bitmap_of_ptr(3, somevalues);\n\n// we can also go in reverse and go from arrays to bitmaps\nuint32_t card1;\nuint32_t *arr1 = roaring_bitmap_to_uint32_array(r1, &card1);\nroaring_bitmap_t *r1f = roaring_bitmap_of_ptr(card1, arr1);\nfree(arr1);\nassert(roaring_bitmap_equals(r1, r1f));  // what we recover is equal\n\n// we can copy and compare bitmaps\nroaring_bitmap_t *z = roaring_bitmap_copy(r3);\nassert(roaring_bitmap_equals(r3, z));  // what we recover is equal\nroaring_bitmap_free(z);\n\n// we can compute union two-by-two\nroaring_bitmap_t *r1_2_3 = roaring_bitmap_or(r1, r2);\nroaring_bitmap_or_inplace(r1_2_3, r3);\n\n// we can compute a big union\nconst roaring_bitmap_t *allmybitmaps[] = {r1, r2, r3};\nroaring_bitmap_t *bigunion = roaring_bitmap_or_many(3, allmybitmaps);\nassert(\n    roaring_bitmap_equals(r1_2_3, bigunion));  // what we recover is equal\n// can also do the big union with a heap\nroaring_bitmap_t *bigunionheap = roaring_bitmap_or_many_heap(3, allmybitmaps);\nassert_true(roaring_bitmap_equals(r1_2_3, bigunionheap));\n\nroaring_bitmap_free(r1_2_3);\nroaring_bitmap_free(bigunion);\nroaring_bitmap_free(bigunionheap);\n\n// we can compute intersection two-by-two\nroaring_bitmap_t *i1_2 = roaring_bitmap_and(r1, r2);\nroaring_bitmap_free(i1_2);\n\n// we can write a bitmap to a pointer and recover it later\nuint32_t expectedsize = roaring_bitmap_portable_size_in_bytes(r1);\nchar *serializedbytes = malloc(expectedsize);\nroaring_bitmap_portable_serialize(r1, serializedbytes);\nroaring_bitmap_t *t = roaring_bitmap_portable_deserialize(serializedbytes);\nassert(roaring_bitmap_equals(r1, t));  // what we recover is equal\nroaring_bitmap_free(t);\nfree(serializedbytes);\n\n// we can iterate over all values using custom functions\nuint32_t counter = 0;\nroaring_iterate(r1, roaring_iterator_sumall, &counter);\n/**\n * void roaring_iterator_sumall(uint32_t value, void *param) {\n *        *(uint32_t *) param += value;\n *  }\n *\n */\n\nroaring_bitmap_free(r1);\nroaring_bitmap_free(r2);\nroaring_bitmap_free(r3);\n```\n\n# Building\n\nCRoaring follows the standard cmake workflow. Starting from the root directory of\nthe project (CRoaring), you can do:\n\n```\nmkdir -p build\ncd build\ncmake ..\nmake\n```\n(You can replace the ``build`` directory with any other directory name.)\n\nFor a debug release, starting from the root directory of the project (CRoaring), try\n\n```\nmkdir -p debug\ncd debug\ncmake -DCMAKE_BUILD_TYPE=Debug -DSANITIZE=ON ..\nmake\n```\n\n(Of course you can replace the ``debug`` directory with any other directory name.)\n\n\nTo run unit tests (you must first run ``make``):\n\n```\nmake test\n```\n\nThe detailed output of the tests can be found in ``Testing/Temporary/LastTest.log``.\n\nTo run real-data benchmark\n\n```\n./real_bitmaps_benchmark ../benchmarks/realdata/census1881\n```\nwhere you must adjust the path \"../benchmarks/realdata/census1881\" so that it points to one of the directories in the benchmarks/realdata directory.\n\n\nTo check that your code abides by the style convention (make sure that ``clang-format`` is installed):\n\n```\n./tools/clang-format-check.sh\n```\n\nTo reformat your code according to the style convention (make sure that ``clang-format`` is installed):\n\n```\n./tools/clang-format.sh\n```\n\n# References and further reading\n\n-  Array layouts for comparison-based searching http://arxiv.org/pdf/1509.05053.pdf\n-  Schlegel et al., Fast Sorted-Set Intersection using SIMD Instructions\n\n### References about Roaring\n\n-  Samy Chambi, Daniel Lemire, Owen Kaser, Robert Godin,\nBetter bitmap performance with Roaring bitmaps,\nSoftware: Practice and Experience Volume 46, Issue 5, pages 709-719, May 2016\nhttp://arxiv.org/abs/1402.6407 This paper used data from http://lemire.me/data/realroaring2014.html\n- Daniel Lemire, Gregory Ssi-Yan-Kai, Owen Kaser, Consistently faster and smaller compressed bitmaps with Roaring, Software: Practice and Experience (accepted in 2016, to appear) http://arxiv.org/abs/1603.06549\n\n# Issues to consider\n\nAVX operations take a while before they warm up to their best speed\nas documented by Agner Fog and others.\n\nThere is a trade-off between throughput and latency. For example,\nprefetching might improve latency, but at the expense of throughput\non a multicore system.\n\nSome instructions, like POPCNT,  take a serious hit under hyperthreading.\n", 
  "id": 47219360
}
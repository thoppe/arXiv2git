{
  "README": "___________________PyCOOL README____________________\n\nPyCOOL v. 0.997300203937\nCopyright (C) 2011 Jani Sainio <jani.sainio at utu.fi>\nDistributed under the terms of the GNU General Public License\nhttp://www.gnu.org/licenses/old-licenses/gpl-2.0.txt\n\nPlease cite http://arxiv.org/abs/1201.5029\nif you use this code in your research.\nSee also http://www.physics.utu.fi/tiedostot/theory/particlecosmology/pycool/\n\nI have done my best to add comments and info texts into different\nfunctions in the Python and CUDA codes in order to make the program\nmore understandable. If you still have questions please email me or\npost them at https://github.com/jtksai/PyCOOL/ .\n\nPlease submit any errors at https://github.com/jtksai/PyCOOL/issues .\n\n------------------------------------------------------\n\n1 Introduction\n\nPyCOOL is a Python + CUDA program that solves the evolution of interacting\nscalar fields in an expanding universe. PyCOOL uses modern GPUs\nto solve this evolution and to make the computation much faster.\nSee http://arxiv.org/abs/0911.5692 for more information on the GPU\nalgorithm.\n\nThe program has been written in the Python language in order to make it really\neasy to adapt the code to different scalar field models. What this means is\nthat in an ideal situation only a list of potential functions in a model file\nhas to be changed to study a new preheating model. Everything else should be\ndone automatically. Please see the included model files for guidance on how\nto write a model file.\n\nFiles included:\n\n  - Python files:\n    - calc_spect.pyx\n    - f_init.pyx\n    - field_init.py\n    - lattice.py\n    - main_program.py\n    - misc_functions.py\n    - procedures.py\n    - setup.py\n    - solvers.py\n    - spectrum.py\n    - symp_integrator.py\n\n  - CUDA and template files:\n    - gpu_3dconv.cu\n    - kernel_gws.cu\n    - kernel_gws_new.cu\n    - kernel_H2.cu\n    - kernel_H3.cu\n    - kernel_H3_new.cu\n    - kernel_k2.cu\n    - kernel_linear_evo.cu\n    - pd_kernel.cu\n    - rho_pres.cu\n    - spatial_corr.cu\n\n  - Model files:\n    - AD.py\n    - AD2.py\n    - chaotic.py\n    - chaotic_massless.py\n    - curvaton.py\n    - curvaton_si.py\n    - curvaton_single.py\n    - oscillon.py\n    - q_ball.py\n\n  - README-file\n  - compile_libs script\n\n------------------------------------------------------\n\n2 Installation and dependencies\n\nPyCOOL naturally needs CUDA drivers installed into your machine\nand preferably a fast NVIDIA GPU (GTX 470 and Tesla C2050 cards tested)\nin order to achieve the speed advantage it can give. PyCOOL is built on \nPyCUDA http://mathema.tician.de/software/pycuda which needs to be installed.\nThe data output also uses Pyvisfile http://mathema.tician.de/software/pyvisfile\nto write SILO files that are visualized in LLNL VisIt program.\n\nShort description of the installation process:\n\nIt is highly recommended to use SILO files for the output.\nHDF5 files are supported in theory but they have not been tested properly\nand the program writes much more data in the SILO files.\nSILO can be downloaded from https://wci.llnl.gov/codes/silo/downloads.html\nand installed with the given instructions.\n\nThe easiest way to install PyCUDA and Pyvisfile is to use\ngit and the following commands:\n\ngit clone http://git.tiker.net/trees/pycuda.git\ngit clone http://git.tiker.net/trees/pyublas.git\ngit clone http://git.tiker.net/trees/pyvisfile.git\n\nwhich will create new folders and download the necessary files.\nBefore proceeding it is recommended to create .aksetup-defaults.py file\nin your $HOME folder or in /etc folder (in Linux). I have included an example\nof an .aksetup-defaults.py file at end of this README. The next step is to\ninstall the python libraries by running\n\n  python setup.py build\n  sudo python setup.py install\n\nin the downloaded package folders. Further PyCUDA install instructions\nare available in http://wiki.tiker.net/PyCuda/Installation .\n\nThe field initialization also uses pyfftw package to calculate DST-II. This can\nbe downloaded from https://launchpad.net/pyfftw . Note that there was an error\nin older version of pyfftw that caused an error in DST-II calculations \nhttps://bugs.launchpad.net/pyfftw/+bug/585809 . In newer version this is fixed.\n\nThe analytical calculations needed when calculating field potentials and\npotential derivatives are done with SymPy http://sympy.org/ . This can be\ninstalled with easy_install or downloaded from https://github.com/sympy/sympy .\n\nPyCOOL uses then textual templating to write the necessary CUDA files. This is\ndone with jinja2 library http://jinja.pocoo.org/docs/ . 'easy_install jinja2'\nshould install this library.\n\nThe spectrum calculations are done with Cython to speed the calculations\n(~200 times compared to ordinary Python code). Therefore Cython has to be also\ninstalled. This can done for example with 'sudo easy_install cython' in Linux.\n\nFinally run the compile_libs script that runs\n'python setup.py build_ext --inplace' to make the calc_spect.pyx into\na shared library file that the PyCOOL can use to calculate the spectra.\n\nAfter all these necessary steps the program is ready to be used.\n\nIn summary, install\n  - Numpy\n  - Scipy\n  - SymPy\n  - SILO libraries\n  - PyCUDA (and CUDA)\n  - Pyublas\n  - Pyvisfile\n  - pyfftw\n  - jinja2\n  - VisIt\n  Then run compile_libs script to build the shared library file for\n  the spectrum  calculations.\n\nCurrent version has been tested in Debian Squeeze and Ubuntu 10.04 but it\nshould work also in other operating systems.\n\n------------------------------------------------------\n\n3 Running\n\nTyping 'python main_program.py' runs the code for a specific model that is\nimported from the models directory. The current program prints to the screen\ninformation of current step number, scale factor, Hubble parameter,\nphysical time and the numerical error. How frequently these are calculated is\ndetermined by flush and flush_hom parameters in the model file.\n\nThe initial field perturbations are created with the method that was\nalso used in Defrost.\n\nThe main program is divided into\n - Homogeneous system solver\n - Non-linear solver that includes a linearized perturbation solver\n\nThe program creates a new folder by time stamp in the data folder.\nFor large lattices and frequent data writing the generated data can be\nseveral hundred gigabytes if the fields are also stored. The created folder\nwill also include a simple info file that tells basic information about\nthe model used to generate the data. These include the initial values and\nthe potential functions.\n\nDuring a simulation run PyCOOL can also calculate various spectra used\npreviously in LatticeEasy and Defrost that are written into the generated SILO\nfiles. In VisIt these are available under Add -> Curve. See section 5 for\ndetails.\n\n------------------------------------------------------\n\n4 Running your own models\n\nThe code has been tested with the included models.\n\nIn order to simulate your own model create a model file in models folder\nthat has the model object and then import this python file in main_program.py.\n\nPossible variables to change/consider include:\n - n controls the number of points per side of lattice\n - L is the length of the side of the lattice\n - mpl is the reduced Planck mass\n - Mpl is the unreduced Planck mass\n - number of fields\n - initial field values\n - field potential\n - flush_freq determines how frequently to calculate the\n   selected postprocessing functions and to write data to disk if\n   saveQ is True.\n\nWe've done our best to test the functionality of the program with different\npotential functions. It might however fail to write CUDA compatible code in\nsome cases. In this case the code in lattice.py and misc_functions.py should\nbe studied carefully to understand why the program failed. One cause of\nerrors is exponentiation e.g. terms of the form f**n. Currently the program\nuses format_to_cuda function (found in misc_functions.py) to write these terms\nopen in to form f**n = f*f*****f. The code is also able to write powers of\nfunctions into suitable CUDA form,\ne.g. Cos(f1)**n = Cos(f1)*Cos(f1)*...*Cos(f1). User has to include\nthe function into a power_list in the used model file.\n\n------------------------------------------------------\n\n5 Output and Post-processing functions\n\nPyCOOL writes variety of variables into the Silo files during run time. Which\nof these and how often to write are determined in the scalar field model\nobject. Note that the different spectra are calculated on the CPU and therefore\nthe data must be transferred from the device to the host memory.\nThis can significantly hinder the performance of the code.\n\nThe variables include:\n - scale factor a\n - Hubble parameter H\n - Comoving horizon in units of lattice length 1/(a*H)/L\n - field f\n - canonical momentum of field pi\n - energy density rho\n - fractional energy densities of fields rho_field(n)/rho_total (omega_field(n)\n   in Silo output)\n - fractional energy density of the interaction term between fields (omega_int\n   in Silo output)\n - Absolute and relative numerical errors\n - spatial correlation length of the total energy density (l_p in Silo output)\n   (See Defrost paper for the definition.)\n\nWhen solving homogeneous equations for the fields the program writes\n - scale factor a\n - Hubble parameter H\n - Comoving horizon in units of lattice length 1/(a*H)/L\n - homogeneous field f\n - homogeneous canonical momentum of field pi\n - energy density rho\n   These are labeled by adding '_hom' at the end of the variable name in Silo\n   output.\n In addition the program writes\n - field_i as a function field_j where i and j label the different fields. This\n   can be used to see if the (field_i(t),field_j(t)) space is confined to some\n   area.\n\nPyCOOL has also various post-processing functions.\nThese include:\n - field spectrum (S_k in Silo output)\n - number density spectrum (n_k in Silo output)\n - energy density spectrum (rho_k in Silo output)\n - effective mass of the field(s) (m_eff in Silo output)\n - comoving number density (n_cov in Silo output)\n - the fraction of particles in relativistic regime (n_rel in Silo output)\n - empirical CDF and PDF from energy densities (rho_CDF and rho_PDF\n   respectively) (This is still experimental!)\n - skewness and kurtosis of the scalar field(s) (field(n)_skew and\n   field(n)_kurt in Silo output)\n\nMost of these functions are defined/used in 'Dmitry I. Podolsky et al. :\nEquation of state and Beginning of Thermalization After Preheating'\nhttp://arxiv.org/abs/hep-ph/0507096v1 .\n\nN.B. These functions have been tested but not thoroughly. If you notice that\nthe output is clearly wrong please submit this to the issues page at github\nand/or create a functioning fork.\n\nN.B.2 Currently PyCOOL uses effective momenta when calculating\nthe number spectra and this can't be turned off without modifying\nlattice.py file.\n\n------------------------------------------------------\n\n6 Curvature perturbation \\zeta\n\nTo calculate the curvature perturbation \\zeta zetaQ should be set to True in\nthe model file. It is also recommended to switch off all the post-processing\nfunctions and saveQ should be set to False (See for example curvaton_single.py\nin models folder). The number of simulations to run with the same initial\nvalues is controlled by sim_num parameter in the used model object.\nsuperfolderQ term should be set to True so that all the curvature perturbation\nsimulation data is stored in a same folder. The name of this folder is\ncontrolled by superfolder parameter in the model file.\nThe range of the homogeneous initial field values over which the calculations\nare performed is determined by fields0 list in the main_program.py. This uses\ndelta_f10 parameter from the model which has been included only with\nthe curvaton model files. How this parameter is calculated has been explained\nin 'Non-Gaussianity from resonant curvaton decay'\nhttp://arxiv.org/abs/0909.4535v3 on page 13 starting from equation (55).\n\nN.B. The currently used method has been applied only to the curvaton model.\nTherefore when applying this to a different model the way \\zeta is calculated\nmight be quite different. The relevant files that might have to be edited are\nmain_program.py (f0list and r_decay), procedures.py in postprocess folder\n(calc_zeta function) and solvers.py (run_non_linear function starting from\nline 154 onwards).\n\nN.B.2 If for some reason the calculation of curvature perturbation zeta has\nterminated before completion it is possible to continue the calculations from\nthe last completed homogeneous initial value onwards. All the completed values\nshould be removed from f0list (Check info.txt files from the data folders\nfor the last values) and after the remaining f0_list values have been also\ncomputed zeta_data_from_file function in the postprocess procedures can read\nthe necessary data from zeta_data.csv files stored in the used superfolder.\n\n------------------------------------------------------\n\n7 Tensor perturbations\n\nTensor perturbations are solved with the method presented in 'A Gravitational\nWave Background from Reheating after Hybrid Inflation'\nhttp://arxiv.org/abs/0707.0839v2 meaning that the tensor components are solved\nseparately and the transverse-traceless part is extracted only when needed.\n\nGravitational waves are solved if self.gwsQ == True in the model file.\nCurrent output of the program is the gravitational wave spectrum (gw_spectrum)\nand the fractional energy density of the gravitational waves (omega_gw).\n\nN.B. Note that this method has not been tested thoroughly. Especially the\nused projector operators should be verified. (These are in\npostprocess/procedures.py and calc_spect.pyx files.)\n\n------------------------------------------------------\n\n8 Different dicretizations\n\nPyCOOL has three different dicretizations implemented: the one presented in\nDEFROST, the one implemented in Latticeeasy and the one used in HLattice.\nThe last two of these use an identical CUDA implementation and are also more\nsuitable for a multi-GPU implementation.\n\nThe used stencil can be currently chosen with the self.discQ parameter in\nthe model file by setting it equal to 'defrost', 'latticeeasy' or 'hlattice'.\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nN.B. Note that currently the 'hlattice' discretization leads to higher errors\nthan the 'Defrost' stencil. Haven't figured what's causing this\n(could be anisotropic errors?). In simulations this also causes very clear\nartifacts in the fields. Therefore it is recommended to use 'Defrost' stencil.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n------------------------------------------------------\n\n9 To Do list/Improvements\n\n- Multi-GPU support should be included. This might however take some\nwork due to the periodicity of the lattice.\n\n- OpenCL support would allow to run the simulations also on AMD Radeon cards.\n  Kernel functions would have to be however rewritten (completely?) and also\n  tested on Radeon cards. This might take a long time and a lot of work.\n\n------------------------------------------------------\nThis is an example of an .aksetup-defaults.py file.\nRemember to modify this to your systems settings.\n\n.aksetup-defaults.py:\n------------------------------------------------------\nBOOST_COMPILER = 'gcc43'\nBOOST_INC_DIR = ['/usr/include']\nBOOST_LIB_DIR = ['/usr/lib']\nBOOST_PYTHON_LIBNAME = ['boost_python-mt-py26']\nBOOST_THREAD_LIBNAME = ['boost_thread-mt']\nCUDADRV_LIBNAME = ['cuda']\nCUDADRV_LIB_DIR = ['/usr/lib']\nCUDA_ENABLE_GL = False\nCUDA_ROOT = '/usr/local/cuda'\nCUDA_TRACE = False\nCXXFLAGS = []\nLDFLAGS = []\nSILO_INC_DIR = ['/usr/local/silo/include']\nSILO_LIBNAME = ['silo']\nSILO_LIB_DIR = ['/usr/local/silo/lib']\nUSE_SHIPPED_BOOST = True\nUSE_SILO = True\n\n------------------------------------------------------\n\n\nJani Sainio\njani.sainio@utu.fi\nhttp://www.physics.utu.fi/tiedostot/theory/particlecosmology/pycool/\nDepartment of Physics and Astronomy\nUniversity of Turku\n\n", 
  "read_at": 1462552182, 
  "description": "A fast object-oriented Python program that uses symplectic algorithms and GPU(s) to simulate scalar fields in the early universe", 
  "id": 2288392
}
{
  "README": "MITMS -- A tool for synthesizing quantum circuits based on the\n         \"meet-in-the-middle\" algorithm (arXiv:1206.0758)\n\nWritten by Matthew Amy\n\nWe kindly request that anyone using this code to synthesize circuits\nacknowledges the tool and/or the paper on which it is based in their work\n\nBUILD\n------------------------------\n\nTo build mitms, run make in the top level folder.\n\nmitms requires the following libraries to be installed:\n\n-- Lapack\n-- Blas\n-- Lapack++\n\nLapack and Blas (I forget whether they're separate) can be a massive pain\nto compile, so if you can get them through your package manager, that is\nmuch preferred.\n\nLapack++ can be found on sourceforge by searching either lapack++ or lapackpp.\nCompiling it shouldn't be too difficult, but if you install it outside of\n/usr or /usr/local you may have to modify the makefile\n\nAdditionally, if your compiler doesn't support the c++0x/c++11 standard,\nyou'll need to change HAS_HASH in configs.h to \"false\" and remove the std=c++0x\nflag from the Makefile.\n\n\nUSAGE\n------------------------------\nRun mitms with\n  mitms [options] <circuit-label>\n\nThe options are documented in mitms -help. Not all of them will work with one\nanother, and certain combinations may break the program. Most of the options\nare experiments and shouldn't be of much concern to most users anyways.\n\nThe standard use case is to exactly synthesize a unitary over the ring \nZ[1/sqrt(2), i], which due to recent results admits a factorization over\nClifford group gates and the T-gate. To synthesize such a unitary, you must\nfirst have a circuit over Clifford group and T gates with arbitrarily many\ncontrols -- this circuit must be added to the file \"searches\" with the\nfollowing syntax:\n  \n  <circuit-label> <number of qubits>\n  <circuit>\n\nThe circuit format should be easy to figure out by looking at the other\ncircuits, but basically you write which gate is being applied at each stage\n(I, H, T, S, X, Y, Z and S*, T* for their inverses, or C(i) for a control on\nthe gate performed on qubit #i). Also, the last stage must have no spaces after\nany of the gates.\n\nWhen mitms is run with <circuit-label>, it will find the circuit in \"searches\",\ncompute the unitary representation over Z[1/sqrt(2), i], then perform the\nsearch. Circuits implementing the unitary over Clifford + T are returned in\norder of increasing depth.\n\n-------------------------------\nAnother possibility is to use this tool to approximate unitaries. The idea is\ndocumented in the author's Master's thesis \"Algorithms for the Optimization\nof Quantum Circuits.\" It uses a vantage-point tree to perform nearest neighbour\nsearches in the space of unitaries over Z[1/sqrt(2), i].\n\nTo approximate a unitary over Z[1/sqrt(2), i], run\n\n  mitms [options] -approximate <circuit-label>\n\nAlternately, you can approximate a rotation matrix of the form \ndiag(1, e^i*PI *(n/d)) with the following option\n\n  mitms [options] -rotation n d\n\nmitms will repeatedly search for better approximations, with the default\nprecision starting at 1. To specify a different default precision, use the \noption \"-precision k\" which searches for approximations with distance at most\n1x10^(-k) in the frobenius norm. The operator norm can be used instead by \nadding the option \"-frobenius\"\n\n-------------------------------\nMitms includes a utility to compute unitaries from a .qc circuit. To use mitms\nin this way execute\n  \n  mitms -matrix\n\nand feed it a .qc circuit on standard input.\n\n-------------------------------\nSome other options that may be of interest to the general population include:\n\n  \"-no-phase\"     if you want all results to have the correct global phase\n                  (this is important if you're decomposing a controlled circuit)\n  \"-tdepth\"       if you want T-depth optimal decompositions. There are much\n                  better algorithms out there for this (arXiv:1210.0974)\n  \"-threads n\"    to specify the number n of threads to run on\n  \"-ancilla n\"    to decompose unitaries using n ancillas\n  \"-paulis\"       if you want to include the pauli group in searches\n  \"-no-serialize\" if you don't want to store circuit database on disk\n\n-------------------------------\nAs one other point, circuit databases are by default stored on disk in the \nlibraries folder, so that they don't have to be generated each time a search is\nmade. You should exercise caution as these databases can be large, and I\nhaven't implemented any sort of filesystem checks.\n\nThis README is far from complete, so please feel free to email me at \nmatt.e.amy@gmail.com if you have any questions or if you find any bugs.\n", 
  "read_at": 1462551007, 
  "description": "A meet-in-the-middle quantum circuit synthesizer", 
  "id": 21791510
}